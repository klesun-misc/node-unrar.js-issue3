{"version":3,"sources":["./src/cpp/unrar/dll.cpp","./src/cpp/unrar/errhnd.hpp","./src/cpp/unrar/array.hpp","./src/cpp/unrar/archive.hpp","./src/cpp/unrar/file.hpp","./src/cpp/unrar/cmddata.hpp","./src/cpp/unrar/strlist.hpp","./src/cpp/unrar/qopen.cpp","./src/cpp/unrar/savepos.hpp","./src/cpp/unrar/headers.hpp","./src/cpp/unrar/secpassword.hpp","./src/cpp/unrar/rawread.hpp","./src/cpp/unrar/strlist.cpp","./src/cpp/unrar/strfn.cpp","./src/cpp/unrar/pathfn.cpp","/emscripten/system/include/libcxx/wchar.h","./src/cpp/unrar/find.hpp","./src/cpp/unrar/timefn.hpp","./src/cpp/unrar/smallfn.cpp","./src/cpp/unrar/filcreat.cpp","./src/cpp/unrar/archive.cpp","./src/cpp/unrar/qopen.hpp","./src/cpp/unrar/arccmt.cpp","./src/cpp/unrar/ui.hpp","./src/cpp/unrar/rdwrfn.hpp","./src/cpp/unrar/unpack.hpp","./src/cpp/unrar/consio.hpp","./src/cpp/unrar/arcread.cpp","./src/cpp/unrar/unicode.cpp","./src/cpp/unrar/system.cpp","./src/cpp/unrar/crypt1.cpp","./src/cpp/unrar/crypt2.cpp","./src/cpp/unrar/crypt3.cpp","./src/cpp/unrar/crypt5.cpp","./src/cpp/unrar/crypt.cpp","./src/cpp/unrar/crypt.hpp","./src/cpp/unrar/crc.cpp","./src/cpp/unrar/rawread.cpp","./src/cpp/unrar/encname.cpp","./src/cpp/unrar/match.cpp","./src/cpp/unrar/timefn.cpp","./src/cpp/unrar/rdwrfn.cpp","./src/cpp/unrar/options.cpp","./src/cpp/unrar/errhnd.cpp","./src/cpp/unrar/rarvm.cpp","./src/cpp/unrar/getbits.hpp","./src/cpp/unrar/secpassword.cpp","./src/cpp/unrar/rijndael.cpp","./src/cpp/unrar/getbits.cpp","./src/cpp/unrar/sha1.cpp","./src/cpp/unrar/sha256.cpp","./src/cpp/unrar/blake2sp.cpp","./src/cpp/unrar/blake2s.cpp","./src/cpp/unrar/blake2s.hpp","./src/cpp/unrar/hash.cpp","./src/cpp/unrar/hardlinks.cpp","./src/cpp/unrar/pathfn.hpp","./src/cpp/unrar/uowners.cpp","./src/cpp/unrar/ulinks.cpp","./src/cpp/unrar/extinfo.cpp","./src/cpp/unrar/extract.cpp","./src/cpp/unrar/volume.cpp","./src/cpp/unrar/coder.cpp","./src/cpp/unrar/unpack50.cpp","./src/cpp/unrar/suballoc.cpp","./src/cpp/unrar/suballoc.hpp","./src/cpp/unrar/model.cpp","./src/cpp/unrar/model.hpp","./src/cpp/unrar/unpack15.cpp","./src/cpp/unrar/unpack.cpp","./src/cpp/unrar/unpack20.cpp","./src/cpp/unrar/unpack30.cpp","./src/cpp/unrar/rarvm.hpp","./src/cpp/unrar/unpackinline.cpp","./src/cpp/unrar/unpack50frag.cpp","./src/cpp/unrar/headers.cpp","./src/cpp/unrar/cmddata.cpp","./src/cpp/unrar/uicommon.cpp","./src/cpp/unrar/uisilent.cpp","./src/cpp/bridge/bridge.cpp","/emscripten/system/include/emscripten/bind.h","/emscripten/system/include/emscripten/wire.h","/emscripten/system/include/libcxx/string","/emscripten/system/include/libcxx/memory","/emscripten/system/include/libcxx/type_traits","/emscripten/system/include/libcxx/new","/emscripten/system/include/libcxx/stdexcept","/emscripten/system/include/libcxx/__string","./src/cpp/bridge/file.cpp","./src/cpp/bridge/filefn.cpp","./src/cpp/bridge/find.cpp","/emscripten/system/lib/embind/bind.cpp","/emscripten/system/include/libcxx/typeinfo"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;;;AAEA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;AAIA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AAAA;;;;;;;;;;AAAA;AAAA;AANA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;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;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;AAIA;AAAA;;;;AAIA;AAAA;;;;AAGA;AAAA;;;;;;AAIA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AAGA;AAAA;;;AADA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AA8kCA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;;;;AACA;;AAAA;;;;;AAEA;;;;;AACA;;;;AAAA;AAAA;;AACA;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;;;;AACA;;AAAA;;;;AAEA;AAAA;AAAA;;AACA;;;;AAAA;AAAA;AAAA;;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;;;;AAAA;;AACA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;AAAA;AAAA;;AACA;;;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;;;;AAEA;;AAAA;;;;AAGA;AAAA;AAAA;AAAA;;AAAA;;;;AACA;AAAA;AAAA;;AACA;;;;AACA;AAAA;;AAAA;;;;AACA;AAAA;;AAAA;;;;;AAEA;;;;;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;;AADA;;;;;AACA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvjCA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAEA;AAAA;;;;AAKA;;;;AAGA;AAAA;AAAA;;AAAA;;;;AAAA;;AAKA;AAAA;AAAA;AAAA;;AAAA;;;;;;AACA;;AAAA;;;;;;;;;;;AAJA;;;;AACA;;AAqaA;AAAA;AAAA;;;;;;;;;;;AA9ZA;;;;;AACA;;;;AAAA;;;AAEA;;;;;;AACA;;AA0ZA;AAAA;AAAA;;;AAvZA;;;;AAAA;AAAA;AAAA;AAEA;;AAAA;;;;;AAEA;;;;AAAA;AAAA;;AACA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA;;;;;;AACA;;AA0YA;AAAA;AAAA;;AApYA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;AAKA;;;;;;;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAOA;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;AAGA;;AAAA;;;;;;AACA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAEA;;;;;AACA;;;;;AAEA;;;;;AACA;;;;;;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;AACA;;;;;;AAHA;;;;;;;;AAKA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;;AAEA;;;;;;AAAA;;AACA;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAIA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;AACA;AAAA;AAAA;AAEA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;;;;;;AACA;;;;;;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AADA;;;;;;;AAKA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;;;;;;;AAGA;AAAA;;AAAA;;;;;;AAEA;;AAAA;;;;;;;AAIA;AAAA;;AAAA;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;;;AAIA;AAAA;AAAA;;AAAA;;;;;;AACA;AAAA;;AAAA;;;;;;AAAA;;AAAA;;;;;;AACA;;AAAA;;;;;;;;;AAEA;AAAA;;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;AAIA;;AAAA;;;;;;;;;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;;;;;;;AACA;AAAA;AAAA;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;;;;;;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;AAEA;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;;AAGA;;AAAA;;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;;AAEA;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAKA;;AAAA;;;;;;;AAtBA;AAAA;AAAA;;;;AAyBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;;AACA;;;;;;AAOA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;;;;;;;;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AACA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;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;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AACA;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAEA;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAGA;AAAA;AAAA;AAAA;;;;AACA;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;AACA;AAAA;AAAA;AAEA;AAAA;;AAAA;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAEA;AAAA;;AAGA;AAAA;;AAAA;;;;;;AAEA;;AAAA;;;;;;;AAGA;AAAA;;;AAAA;;AAAA;;;;;;;;;AACA;AAAA;;;AAGA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;;;;;;;;;AAKA;AAAA;AAAA;;AACA;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;;;;;AACA;;AAGA;AAAA;AAAA;;;AADA;;;;;;AAAA;;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAtvBA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;;AAyvBA;AAAA;AAAA;AAAA;;AAsCA;;AAnCA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;;AAWA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;AAjzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;;;AAHA;AAAA;AACA;AAEA;;;;;;;;;;;AhB3DA;AAAA;AAAA;AAAA;;;;;;;;;AFgHA;AAAA;AACA;;;;;;;;;AEzHA;AAAA;AAAA;;;;;;;;;;;AgBgFA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+xBA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AA0NA;;AAxNA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAUA;AAAA;AAGA;AACA;AAAA;AAAA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAEA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAKA;AAAA;AAAA;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;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AAA;AAAA;AACA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;ACnDA;AAAA;AAGA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAJA;AAAA;AAAA;;AADA;AAAA;AAAA;;AAUA;AAAA;AAAA;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AADA;AAAA;AAAA;;;;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;;;;;;;;;;;AAqIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AAjIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AATA;AAAA;AAAA;;AAYA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AACA;;;;;;;;;;;;;AAgEA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AAAA;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA/DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AACA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AATA;AAAA;AAAA;;AAYA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;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AAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;;AADA;AACA;AAAA;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;;AADA;AACA;AAAA;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AAJA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAMA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AADA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;;;AADA;AACA;AAAA;;;;;;;;;;;;;;;;;AAKA;AAAA;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A;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAMA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAWA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAAA;;AACA;AAAA;;;;;AAEA;AAAA;AAAA;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;;;;AAGA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAVA;AAAA;AAAA;;AAYA;;;;;;;;;;;;;;;;;;;;;AApRA;;;AAGA;;;;;;AAIA;;;;;;AAIA;;;;;;;;;;;;AAOA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;;;AACA;AAAA;;AAEA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;AAGA;AAEA;AAAA;;AAEA;;AADA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkHA;AAIA;AAAA;AAAA;AAAA;AAMA;AAAA;AAEA;AACA;AAGA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;;;;AAEA;AAAA;AAAA;AACA;;;AAIA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;AACA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AADA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AADA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AADA;AAAA;;;;AAIA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;;;AAEA;AAAA;AAAA;AACA;;;AAIA;;;;;;;;;;;;;AAIA;;AAAA;AAAA;AAAA;AAAA;;;;AAGA;;AAAA;AAAA;;;;AACA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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A;AAAA;AACA;;;;;;;;;;AAKA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;;;AACA;;;;;;;;;;;AAMA;AAAA;AACA;;;;;;;;;;;AHRA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AGWA;AAAA;;;;;;;;;;AHLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AIgCA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;;AAmCA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAEA;;;;;;;;;;;;;;;;AAnGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AA0GA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AARA;AAAA;AAAA;;AAyBA;;AAEA;;AACA;AAAA;AAAA;;AAEA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AAUA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;;AAGA;;AAFA;AAAA;AAAA;AAEA;;;;;;;;;AC/MA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAyEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAEA;AACA;AAAA;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA9EA;AAAA;;AAEA;AACA;AA6CA;;AAxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAlBA;AAAA;AAAA;;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AA1DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AA6FA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;;;AAEA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAKA;AAAA;AAEA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;AC/JA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;ACqCA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;ACZA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;AFrBA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;;;;AAOA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;AC2EA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAYA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;AAGA;;;;;;;;;;;AApHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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;;;;;;;AACA;AAAA;AAAA;;AAAA;;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;;;AACA;AAAA;;;AACA;AAAA;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;;;;;;;;;;;;;AAIA;AAAA;;;;;;;;;;;;AAKA;;AAAA;AAAA;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;AACA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;;AAAA;;;;;;;AACA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;AAAA;;AAAA;;;;;;;AAaA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAEA;AAAA;;;;;AAAA;AAAA;;;;;AAAA;AAAA;;;;AAAA;AAAA;AACA;AAEA;AACA;AAAA;;;;;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;A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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AADA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AA3CA;;AAGA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;ArCzoBA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;AnB5DA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AyDxFA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;;AADA;AAAA;AAGA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AADA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;;;;;;;;;;;AAvKA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;AAQA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AALA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAzCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;ADuBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;ACHA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAWA;;AAAA;AAAA;;;;AACA;;AAAA;AAAA;;;;AACA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AADA;AAAA;;AADA;AAAA;AAAA;;AAIA;;AAAA;AAAA;;;;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AADA;AAAA;AAAA;;AAGA;;;;;;;;;AFsLA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;AAHA;AAAA;AAAA;;AACA;AAAA;AAEA;AAAA;;AADA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;AAnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAOA;AAAA;;AANA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAGA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;AG7NA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;ADgDA;AAAA;AAkBA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AANA;AAAA;AAAA;;AASA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAQA;;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AAxJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AF0RA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AArBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAaA;AAAA;;AAZA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAOA;AAAA;;AAHA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;;;;;;;;;;;AE4PA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAkBA;AAAA;AAAA;;;AAjBA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;AAKA;AAAA;AAAA;AACA;AAAA;;;AAJA;AACA;AAAA;AAMA;AAAA;AAAA;;;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;AD/eA;AAAA;;;;;;;;;;;;;;;;;;ACofA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;;AACA;AA8BA;AAAA;;;AAhCA;AAgCA;AAAA;;AA3BA;;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;;;;AAEA;AAAA;;;AAJA;AAiBA;AAAA;;;AAdA;AAcA;AAAA;;;AAXA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;AACA;AAAA;AAAA;AAAA;;AACA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;;;AApCA;AAoCA;AAAA;;;;;;;;;;;;;;;;;;;;AAnNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAmCA;AAAA;AAAA;;AAlCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAyBA;AAAA;AAAA;;AAtBA;AAAA;AAAA;AAAA;;AACA;AAAA;AAqBA;AAAA;AAAA;;AApBA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;;;;;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AAfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAKA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AAxFA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AAAA;AADA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAFA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAaA;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;;;;;;;;;AJnVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AIobA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAyBA;AAAA;AAAA;;AAxBA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;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AA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AACA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAhKA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;AACA;AAAA;;;AAEA;;AAEA;AAAA;AACA;AAAA;;;AAIA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;AACA;AAAA;;;AAEA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AACA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;AA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A;AACA;AAAA;AAAA;;;;;;;AAGA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAEA;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;;AAGA;;AAEA;;;;;;;AAIA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;;AAuBA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;;;AA7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;;;AAiBA;;AAFA;AACA;AACA;;;;;;;;;;;;;;;;;;;AAwBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AA8EA;AAAA;AAAA;;;AA7EA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AAGA;;AAEA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAHA;AAAA;AAAA;;AAKA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;;;;;;AAEA;AAAA;;AACA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAKA;AAAA;;AAEA;;AAAA;AAAA;AAAA;AACA;AAAA;;AAIA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAhCA;AAAA;AAgDA;AAAA;AAAA;;AAbA;;AACA;AAAA;AAYA;AAAA;AAAA;;AAXA;AAAA;AAAA;;;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;AGtKA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiCA;AAAA;;AA7BA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AADA;AAAA;;;AAGA;;AAIA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AHgKA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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A;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;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AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;AVMA;AAAA;;;;;AUrBA;;;;;AVfA;;;;;AAoCA;AAAA;;;;;AUrBA;;;;;AVfA;;;;;AAoCA;AAAA;;;;;AUrBA;;;;;AVfA;;;;;AAoCA;AAAA;;;;;AUrBA;;;;;AVfA;;;;;AAoCA;AAAA;;;;;AUrBA;;;;;AVfA;;;;;AAoCA;AAAA;;;;;AUrBA;;;;;AVfA;;;;;AAoCA;AAAA;;;;;AUrBA;;;;;AVfA;;;;;AAoCA;AAAA;;;;;AUrBA;;;;;AVfA;;;;;AAoCA;AAAA;;;;;AUrBA;;;;;AVfA;;;;;AAoCA;AAAA;;;;;AUrBA;;;;;AVfA;;;;;AAoCA;AAAA;;;;;AUrBA;;;;;AVfA;;;;;AAoCA;AAAA;;;;;AUrBA;;;;;AVfA;;;;;AAAA;;;;;AAAA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAAA;;;;;AAAA;;;;;;;;AUzBA;;;ACmHA;AAAA;ADnHA;AAAA","file":"./dist/js/unrar.js","sourcesContent":["#include \"rar.hpp\"\n\nstatic int RarErrorToDll(RAR_EXIT ErrCode);\n\nstruct DataSet\n{\n  CommandData Cmd;\n  Archive Arc;\n  CmdExtract Extract;\n  int OpenMode;\n  int HeaderSize;\n\n  DataSet():Arc(&Cmd),Extract(&Cmd) {};\n};\n\n\nHANDLE PASCAL RAROpenArchive(struct RAROpenArchiveData *r)\n{\n  RAROpenArchiveDataEx rx;\n  memset(&rx,0,sizeof(rx));\n  rx.ArcName=r->ArcName;\n  rx.OpenMode=r->OpenMode;\n  rx.CmtBuf=r->CmtBuf;\n  rx.CmtBufSize=r->CmtBufSize;\n  HANDLE hArc=RAROpenArchiveEx(&rx);\n  r->OpenResult=rx.OpenResult;\n  r->CmtSize=rx.CmtSize;\n  r->CmtState=rx.CmtState;\n  return hArc;\n}\n\n\nHANDLE PASCAL RAROpenArchiveEx(struct RAROpenArchiveDataEx *r)\n{\n  DataSet *Data=NULL;\n  try\n  {\n    r->OpenResult=0;\n    Data=new DataSet;\n    Data->Cmd.DllError=0;\n    Data->OpenMode=r->OpenMode;\n    Data->Cmd.FileArgs.AddString(L\"*\");\n\n    char AnsiArcName[NM];\n    *AnsiArcName=0;\n    if (r->ArcName!=NULL)\n    {\n      strncpyz(AnsiArcName,r->ArcName,ASIZE(AnsiArcName));\n#ifdef _WIN_ALL\n      if (!AreFileApisANSI())\n      {\n        OemToCharBuffA(r->ArcName,AnsiArcName,ASIZE(AnsiArcName));\n        AnsiArcName[ASIZE(AnsiArcName)-1]=0;\n      }\n#endif\n    }\n\n    wchar ArcName[NM];\n    GetWideName(AnsiArcName,r->ArcNameW,ArcName,ASIZE(ArcName));\n\n    Data->Cmd.AddArcName(ArcName);\n    Data->Cmd.Overwrite=OVERWRITE_ALL;\n    Data->Cmd.VersionControl=1;\n\n    Data->Cmd.Callback=r->Callback;\n    Data->Cmd.UserData=r->UserData;\n\n    // Open shared mode is added by request of dll users, who need to\n    // browse and unpack archives while downloading.\n    Data->Cmd.OpenShared = true;\n    if (!Data->Arc.Open(ArcName,FMF_OPENSHARED))\n    {\n      r->OpenResult=ERAR_EOPEN;\n      delete Data;\n      return NULL;\n    }\n    if (!Data->Arc.IsArchive(true))\n    {\n      if (Data->Cmd.DllError!=0)\n        r->OpenResult=Data->Cmd.DllError;\n      else\n      {\n        RAR_EXIT ErrCode=ErrHandler.GetErrorCode();\n        if (ErrCode!=RARX_SUCCESS && ErrCode!=RARX_WARNING)\n          r->OpenResult=RarErrorToDll(ErrCode);\n        else\n          r->OpenResult=ERAR_BAD_ARCHIVE;\n      }\n      delete Data;\n      return NULL;\n    }\n    r->Flags=0;\n    \n    if (Data->Arc.Volume)\n      r->Flags|=0x01;\n    if (Data->Arc.Locked)\n      r->Flags|=0x04;\n    if (Data->Arc.Solid)\n      r->Flags|=0x08;\n    if (Data->Arc.NewNumbering)\n      r->Flags|=0x10;\n    if (Data->Arc.Signed)\n      r->Flags|=0x20;\n    if (Data->Arc.Protected)\n      r->Flags|=0x40;\n    if (Data->Arc.Encrypted)\n      r->Flags|=0x80;\n    if (Data->Arc.FirstVolume)\n      r->Flags|=0x100;\n\n    Array<wchar> CmtDataW;\n    if (r->CmtBufSize!=0 && Data->Arc.GetComment(&CmtDataW))\n    {\n      Array<char> CmtData(CmtDataW.Size()*4+1);\n      memset(&CmtData[0],0,CmtData.Size());\n      WideToChar(&CmtDataW[0],&CmtData[0],CmtData.Size()-1);\n      size_t Size=strlen(&CmtData[0])+1;\n\n      r->Flags|=2;\n      r->CmtState=Size>r->CmtBufSize ? ERAR_SMALL_BUF:1;\n      r->CmtSize=(uint)Min(Size,r->CmtBufSize);\n      memcpy(r->CmtBuf,&CmtData[0],r->CmtSize-1);\n      if (Size<=r->CmtBufSize)\n        r->CmtBuf[r->CmtSize-1]=0;\n    }\n    else\n      r->CmtState=r->CmtSize=0;\n    Data->Extract.ExtractArchiveInit(Data->Arc);\n    return (HANDLE)Data;\n  }\n  catch (RAR_EXIT ErrCode)\n  {\n    if (Data!=NULL && Data->Cmd.DllError!=0)\n      r->OpenResult=Data->Cmd.DllError;\n    else\n      r->OpenResult=RarErrorToDll(ErrCode);\n    if (Data != NULL)\n      delete Data;\n    return NULL;\n  }\n  catch (std::bad_alloc&) // Catch 'new' exception.\n  {\n    r->OpenResult=ERAR_NO_MEMORY;\n    if (Data != NULL)\n      delete Data;\n  }\n  return NULL; // To make compilers happy.\n}\n\n\nint PASCAL RARCloseArchive(HANDLE hArcData)\n{\n  DataSet *Data=(DataSet *)hArcData;\n  bool Success=Data==NULL ? false:Data->Arc.Close();\n  delete Data;\n  return Success ? ERAR_SUCCESS : ERAR_ECLOSE;\n}\n\n\nint PASCAL RARReadHeader(HANDLE hArcData,struct RARHeaderData *D)\n{\n  struct RARHeaderDataEx X;\n  memset(&X,0,sizeof(X));\n\n  int Code=RARReadHeaderEx(hArcData,&X);\n\n  strncpyz(D->ArcName,X.ArcName,ASIZE(D->ArcName));\n  strncpyz(D->FileName,X.FileName,ASIZE(D->FileName));\n  D->Flags=X.Flags;\n  D->PackSize=X.PackSize;\n  D->UnpSize=X.UnpSize;\n  D->HostOS=X.HostOS;\n  D->FileCRC=X.FileCRC;\n  D->FileTime=X.FileTime;\n  D->UnpVer=X.UnpVer;\n  D->Method=X.Method;\n  D->FileAttr=X.FileAttr;\n  D->CmtSize=0;\n  D->CmtState=0;\n\n  return Code;\n}\n\n\nint PASCAL RARReadHeaderEx(HANDLE hArcData,struct RARHeaderDataEx *D)\n{\n  DataSet *Data=(DataSet *)hArcData;\n  try\n  {\n    if ((Data->HeaderSize=(int)Data->Arc.SearchBlock(HEAD_FILE))<=0)\n    {\n      if (Data->Arc.Volume && Data->Arc.GetHeaderType()==HEAD_ENDARC &&\n          Data->Arc.EndArcHead.NextVolume)\n        if (MergeArchive(Data->Arc,NULL,false,'L'))\n        {\n          Data->Arc.Seek(Data->Arc.CurBlockPos,SEEK_SET);\n          return RARReadHeaderEx(hArcData,D);\n        }\n        else\n          return ERAR_EOPEN;\n\n      if (Data->Arc.BrokenHeader)\n        return ERAR_BAD_DATA;\n\n      // Might be necessary if RARSetPassword is still called instead of\n      // open callback for RAR5 archives and if password is invalid.\n      if (Data->Arc.FailedHeaderDecryption)\n        return ERAR_BAD_PASSWORD;\n      \n      return ERAR_END_ARCHIVE;\n    }\n    FileHeader *hd=&Data->Arc.FileHead;\n    if (Data->OpenMode==RAR_OM_LIST && hd->SplitBefore)\n    {\n      int Code=RARProcessFile(hArcData,RAR_SKIP,NULL,NULL);\n      if (Code==0)\n        return RARReadHeaderEx(hArcData,D);\n      else\n        return Code;\n    }\n    wcsncpy(D->ArcNameW,Data->Arc.FileName,ASIZE(D->ArcNameW));\n    WideToChar(D->ArcNameW,D->ArcName,ASIZE(D->ArcName));\n\n    wcsncpy(D->FileNameW,hd->FileName,ASIZE(D->FileNameW));\n    WideToChar(D->FileNameW,D->FileName,ASIZE(D->FileName));\n#ifdef _WIN_ALL\n    CharToOemA(D->FileName,D->FileName);\n#endif\n\n    D->Flags=0;\n    if (hd->SplitBefore)\n      D->Flags|=RHDF_SPLITBEFORE;\n    if (hd->SplitAfter)\n      D->Flags|=RHDF_SPLITAFTER;\n    if (hd->Encrypted)\n      D->Flags|=RHDF_ENCRYPTED;\n    if (hd->Solid)\n      D->Flags|=RHDF_SOLID;\n    if (hd->Dir)\n      D->Flags|=RHDF_DIRECTORY;\n\n    D->PackSize=uint(hd->PackSize & 0xffffffff);\n    D->PackSizeHigh=uint(hd->PackSize>>32);\n    D->UnpSize=uint(hd->UnpSize & 0xffffffff);\n    D->UnpSizeHigh=uint(hd->UnpSize>>32);\n    D->HostOS=hd->HSType==HSYS_WINDOWS ? HOST_WIN32:HOST_UNIX;\n    if (Data->Arc.Format==RARFMT50)\n      D->UnpVer=Data->Arc.FileHead.UnpVer==0 ? 50 : 200; // If it is not 0, just set it to something big.\n    else\n      D->UnpVer=Data->Arc.FileHead.UnpVer;\n    D->FileCRC=hd->FileHash.CRC32;\n    D->FileTime=hd->mtime.GetDos();\n    D->Method=hd->Method+0x30;\n    D->FileAttr=hd->FileAttr;\n    D->CmtSize=0;\n    D->CmtState=0;\n\n    D->DictSize=uint(hd->WinSize/1024);\n\n    switch (hd->FileHash.Type)\n    {\n      case HASH_RAR14:\n      case HASH_CRC32:\n        D->HashType=RAR_HASH_CRC32;\n        break;\n      case HASH_BLAKE2:\n        D->HashType=RAR_HASH_BLAKE2;\n        memcpy(D->Hash,hd->FileHash.Digest,BLAKE2_DIGEST_SIZE);\n        break;\n      default:\n        D->HashType=RAR_HASH_NONE;\n        break;\n    }\n\n    D->RedirType=hd->RedirType;\n    // RedirNameSize sanity check is useful in case some developer\n    // did not initialize Reserved area with 0 as required in docs.\n    // We have taken 'Redir*' fields from Reserved area. We may remove\n    // this RedirNameSize check sometimes later.\n    if (hd->RedirType!=FSREDIR_NONE && D->RedirName!=NULL &&\n        D->RedirNameSize>0 && D->RedirNameSize<100000)\n      wcsncpyz(D->RedirName,hd->RedirName,D->RedirNameSize);\n    D->DirTarget=hd->DirTarget;\n  }\n  catch (RAR_EXIT ErrCode)\n  {\n    return Data->Cmd.DllError!=0 ? Data->Cmd.DllError : RarErrorToDll(ErrCode);\n  }\n  return ERAR_SUCCESS;\n}\n\n\nint PASCAL ProcessFile(HANDLE hArcData,int Operation,char *DestPath,char *DestName,wchar *DestPathW,wchar *DestNameW)\n{\n  DataSet *Data=(DataSet *)hArcData;\n  try\n  {\n    Data->Cmd.DllError=0;\n    if (Data->OpenMode==RAR_OM_LIST || Data->OpenMode==RAR_OM_LIST_INCSPLIT ||\n        Operation==RAR_SKIP && !Data->Arc.Solid)\n    {\n      if (Data->Arc.Volume && Data->Arc.GetHeaderType()==HEAD_FILE &&\n          Data->Arc.FileHead.SplitAfter)\n        if (MergeArchive(Data->Arc,NULL,false,'L'))\n        {\n          Data->Arc.Seek(Data->Arc.CurBlockPos,SEEK_SET);\n          return ERAR_SUCCESS;\n        }\n        else\n          return ERAR_EOPEN;\n      Data->Arc.SeekToNext();\n    }\n    else\n    {\n      Data->Cmd.DllOpMode=Operation;\n\n      *Data->Cmd.ExtrPath=0;\n      *Data->Cmd.DllDestName=0;\n\n      if (DestPath!=NULL)\n      {\n        char ExtrPathA[NM];\n        strncpyz(ExtrPathA,DestPath,ASIZE(ExtrPathA)-2);\n#ifdef _WIN_ALL\n        // We must not apply OemToCharBuffA directly to DestPath,\n        // because we do not know DestPath length and OemToCharBuffA\n        // does not stop at 0.\n        OemToCharA(ExtrPathA,ExtrPathA);\n#endif\n        CharToWide(ExtrPathA,Data->Cmd.ExtrPath,ASIZE(Data->Cmd.ExtrPath));\n        AddEndSlash(Data->Cmd.ExtrPath,ASIZE(Data->Cmd.ExtrPath));\n      }\n      if (DestName!=NULL)\n      {\n        char DestNameA[NM];\n        strncpyz(DestNameA,DestName,ASIZE(DestNameA)-2);\n#ifdef _WIN_ALL\n        // We must not apply OemToCharBuffA directly to DestName,\n        // because we do not know DestName length and OemToCharBuffA\n        // does not stop at 0.\n        OemToCharA(DestNameA,DestNameA);\n#endif\n        CharToWide(DestNameA,Data->Cmd.DllDestName,ASIZE(Data->Cmd.DllDestName));\n      }\n\n      if (DestPathW!=NULL)\n      {\n        wcsncpy(Data->Cmd.ExtrPath,DestPathW,ASIZE(Data->Cmd.ExtrPath));\n        AddEndSlash(Data->Cmd.ExtrPath,ASIZE(Data->Cmd.ExtrPath));\n      }\n\n      if (DestNameW!=NULL)\n        wcsncpyz(Data->Cmd.DllDestName,DestNameW,ASIZE(Data->Cmd.DllDestName));\n\n      wcscpy(Data->Cmd.Command,Operation==RAR_EXTRACT ? L\"X\":L\"T\");\n      Data->Cmd.Test=Operation!=RAR_EXTRACT;\n      bool Repeat=false;\n      Data->Extract.ExtractCurrentFile(Data->Arc,Data->HeaderSize,Repeat);\n\n      // Now we process extra file information if any.\n      //\n      // Archive can be closed if we process volumes, next volume is missing\n      // and current one is already removed or deleted. So we need to check\n      // if archive is still open to avoid calling file operations on\n      // the invalid file handle. Some of our file operations like Seek()\n      // process such invalid handle correctly, some not.\n      while (Data->Arc.IsOpened() && Data->Arc.ReadHeader()!=0 && \n             Data->Arc.GetHeaderType()==HEAD_SERVICE)\n      {\n        Data->Extract.ExtractCurrentFile(Data->Arc,Data->HeaderSize,Repeat);\n        Data->Arc.SeekToNext();\n      }\n      Data->Arc.Seek(Data->Arc.CurBlockPos,SEEK_SET);\n    }\n  }\n  catch (std::bad_alloc&)\n  {\n    return ERAR_NO_MEMORY;\n  }\n  catch (RAR_EXIT ErrCode)\n  {\n    return Data->Cmd.DllError!=0 ? Data->Cmd.DllError : RarErrorToDll(ErrCode);\n  }\n  return Data->Cmd.DllError;\n}\n\n\nint PASCAL RARProcessFile(HANDLE hArcData,int Operation,char *DestPath,char *DestName)\n{\n  return(ProcessFile(hArcData,Operation,DestPath,DestName,NULL,NULL));\n}\n\n\nint PASCAL RARProcessFileW(HANDLE hArcData,int Operation,wchar *DestPath,wchar *DestName)\n{\n  return(ProcessFile(hArcData,Operation,NULL,NULL,DestPath,DestName));\n}\n\n\nvoid PASCAL RARSetChangeVolProc(HANDLE hArcData,CHANGEVOLPROC ChangeVolProc)\n{\n  DataSet *Data=(DataSet *)hArcData;\n  Data->Cmd.ChangeVolProc=ChangeVolProc;\n}\n\n\nvoid PASCAL RARSetCallback(HANDLE hArcData,UNRARCALLBACK Callback,LPARAM UserData)\n{\n  DataSet *Data=(DataSet *)hArcData;\n  Data->Cmd.Callback=Callback;\n  Data->Cmd.UserData=UserData;\n}\n\n\nvoid PASCAL RARSetProcessDataProc(HANDLE hArcData,PROCESSDATAPROC ProcessDataProc)\n{\n  DataSet *Data=(DataSet *)hArcData;\n  Data->Cmd.ProcessDataProc=ProcessDataProc;\n}\n\n\n#ifndef RAR_NOCRYPT\nvoid PASCAL RARSetPassword(HANDLE hArcData,char *Password)\n{\n  DataSet *Data=(DataSet *)hArcData;\n  wchar PasswordW[MAXPASSWORD];\n  GetWideName(Password,NULL,PasswordW,ASIZE(PasswordW));\n  Data->Cmd.Password.Set(PasswordW);\n  cleandata(PasswordW,sizeof(PasswordW));\n}\n#endif\n\n\nint PASCAL RARGetDllVersion()\n{\n  return RAR_DLL_VERSION;\n}\n\n\nstatic int RarErrorToDll(RAR_EXIT ErrCode)\n{\n  switch(ErrCode)\n  {\n    case RARX_FATAL:\n      return ERAR_EREAD;\n    case RARX_CRC:\n      return ERAR_BAD_DATA;\n    case RARX_WRITE:\n      return ERAR_EWRITE;\n    case RARX_OPEN:\n      return ERAR_EOPEN;\n    case RARX_CREATE:\n      return ERAR_ECREATE;\n    case RARX_MEMORY:\n      return ERAR_NO_MEMORY;\n    case RARX_BADPWD:\n      return ERAR_BAD_PASSWORD;\n    case RARX_SUCCESS:\n      return ERAR_SUCCESS; // 0.\n    default:\n      return ERAR_UNKNOWN;\n  }\n}\n","#ifndef _RAR_ERRHANDLER_\n#define _RAR_ERRHANDLER_\n\nenum RAR_EXIT // RAR exit code.\n{ \n  RARX_SUCCESS   =   0,\n  RARX_WARNING   =   1,\n  RARX_FATAL     =   2,\n  RARX_CRC       =   3,\n  RARX_LOCK      =   4,\n  RARX_WRITE     =   5,\n  RARX_OPEN      =   6,\n  RARX_USERERROR =   7,\n  RARX_MEMORY    =   8,\n  RARX_CREATE    =   9,\n  RARX_NOFILES   =  10,\n  RARX_BADPWD    =  11,\n  RARX_USERBREAK = 255\n};\n\nclass ErrorHandler\n{\n  private:\n    RAR_EXIT ExitCode;\n    uint ErrCount;\n    bool EnableBreak;\n    bool Silent;\n    bool DisableShutdown; // Shutdown is not suitable after last error.\n  public:\n    ErrorHandler();\n    void Clean();\n    void MemoryError();\n    void OpenError(const wchar *FileName);\n    void CloseError(const wchar *FileName);\n    void ReadError(const wchar *FileName);\n    bool AskRepeatRead(const wchar *FileName);\n    void WriteError(const wchar *ArcName,const wchar *FileName);\n    void WriteErrorFAT(const wchar *FileName);\n    bool AskRepeatWrite(const wchar *FileName,bool DiskFull);\n    void SeekError(const wchar *FileName);\n    void GeneralErrMsg(const wchar *fmt,...);\n    void MemoryErrorMsg();\n    void OpenErrorMsg(const wchar *FileName);\n    void OpenErrorMsg(const wchar *ArcName,const wchar *FileName);\n    void CreateErrorMsg(const wchar *FileName);\n    void CreateErrorMsg(const wchar *ArcName,const wchar *FileName);\n    void ReadErrorMsg(const wchar *FileName);\n    void ReadErrorMsg(const wchar *ArcName,const wchar *FileName);\n    void WriteErrorMsg(const wchar *ArcName,const wchar *FileName);\n    void ArcBrokenMsg(const wchar *ArcName);\n    void ChecksumFailedMsg(const wchar *ArcName,const wchar *FileName);\n    void UnknownMethodMsg(const wchar *ArcName,const wchar *FileName);\n    void Exit(RAR_EXIT ExitCode);\n    void SetErrorCode(RAR_EXIT Code);\n    RAR_EXIT GetErrorCode() {return ExitCode;}\n    uint GetErrorCount() {return ErrCount;}\n    void SetSignalHandlers(bool Enable);\n    void Throw(RAR_EXIT Code);\n    void SetSilent(bool Mode) {Silent=Mode;};\n    void SysErrMsg();\n    int GetSystemErrorCode();\n    void SetSystemErrorCode(int Code);\n    bool IsShutdownEnabled() {return !DisableShutdown;}\n\n    bool UserBreak; // Ctrl+Break is pressed.\n    bool MainExit; // main() is completed.\n};\n\n\n#endif\n","#ifndef _RAR_ARRAY_\n#define _RAR_ARRAY_\n\nextern ErrorHandler ErrHandler;\n\ntemplate <class T> class Array\n{\n  private:\n    T *Buffer;\n    size_t BufSize;\n    size_t AllocSize;\n    size_t MaxSize;\n  public:\n    Array();\n    Array(size_t Size);\n    Array(const Array &Src); // Copy constructor.\n    ~Array();\n    inline void CleanData();\n    inline T& operator [](size_t Item) const;\n    inline T* operator + (size_t Pos);\n    inline size_t Size(); // Returns the size in items, not in bytes.\n    void Add(size_t Items);\n    void Alloc(size_t Items);\n    void Reset();\n    void SoftReset();\n    void operator = (Array<T> &Src);\n    void Push(T Item);\n    void Append(T *Item,size_t Count);\n    T* Addr(size_t Item) {return Buffer+Item;}\n    void SetMaxSize(size_t Size) {MaxSize=Size;}\n};\n\ntemplate <class T> void Array<T>::CleanData()\n{\n  Buffer=NULL;\n  BufSize=0;\n  AllocSize=0;\n  MaxSize=0;\n}\n\n\ntemplate <class T> Array<T>::Array()\n{\n  CleanData();\n}\n\n\ntemplate <class T> Array<T>::Array(size_t Size)\n{\n  CleanData();\n  Add(Size);\n}\n\n\n// Copy constructor in case we need to pass an object as value.\ntemplate <class T> Array<T>::Array(const Array &Src)\n{\n  CleanData();\n  Alloc(Src.BufSize);\n  if (Src.BufSize!=0)\n    memcpy((void *)Buffer,(void *)Src.Buffer,Src.BufSize*sizeof(T));\n}\n\n\ntemplate <class T> Array<T>::~Array()\n{\n  if (Buffer!=NULL)\n    free(Buffer);\n}\n\n\ntemplate <class T> inline T& Array<T>::operator [](size_t Item) const\n{\n  return Buffer[Item];\n}\n\n\ntemplate <class T> inline T* Array<T>::operator +(size_t Pos)\n{\n  return Buffer+Pos;\n}\n\n\ntemplate <class T> inline size_t Array<T>::Size()\n{\n  return BufSize;\n}\n\n\ntemplate <class T> void Array<T>::Add(size_t Items)\n{\n  BufSize+=Items;\n  if (BufSize>AllocSize)\n  {\n    if (MaxSize!=0 && BufSize>MaxSize)\n    {\n      ErrHandler.GeneralErrMsg(L\"Maximum allowed array size (%u) is exceeded\",MaxSize);\n      ErrHandler.MemoryError();\n    }\n\n    size_t Suggested=AllocSize+AllocSize/4+32;\n    size_t NewSize=Max(BufSize,Suggested);\n\n    T *NewBuffer=(T *)realloc(Buffer,NewSize*sizeof(T));\n    if (NewBuffer==NULL)\n      ErrHandler.MemoryError();\n    Buffer=NewBuffer;\n    AllocSize=NewSize;\n  }\n}\n\n\ntemplate <class T> void Array<T>::Alloc(size_t Items)\n{\n  if (Items>AllocSize)\n    Add(Items-BufSize);\n  else\n    BufSize=Items;\n}\n\n\ntemplate <class T> void Array<T>::Reset()\n{\n  if (Buffer!=NULL)\n  {\n    free(Buffer);\n    Buffer=NULL;\n  }\n  BufSize=0;\n  AllocSize=0;\n}\n\n\n// Reset buffer size, but preserve already allocated memory if any,\n// so we can reuse it without wasting time to allocation.\ntemplate <class T> void Array<T>::SoftReset()\n{\n  BufSize=0;\n}\n\n\ntemplate <class T> void Array<T>::operator =(Array<T> &Src)\n{\n  Reset();\n  Alloc(Src.BufSize);\n  if (Src.BufSize!=0)\n    memcpy((void *)Buffer,(void *)Src.Buffer,Src.BufSize*sizeof(T));\n}\n\n\ntemplate <class T> void Array<T>::Push(T Item)\n{\n  Add(1);\n  (*this)[Size()-1]=Item;\n}\n\n\ntemplate <class T> void Array<T>::Append(T *Items,size_t Count)\n{\n  size_t CurSize=Size();\n  Add(Count);\n  memcpy(Buffer+CurSize,Items,Count*sizeof(T));\n}\n\n#endif\n","#ifndef _RAR_ARCHIVE_\n#define _RAR_ARCHIVE_\n\nclass PPack;\nclass RawRead;\nclass RawWrite;\n\nenum NOMODIFY_FLAGS \n{\n  NMDF_ALLOWLOCK=1,NMDF_ALLOWANYVOLUME=2,NMDF_ALLOWFIRSTVOLUME=4\n};\n\nenum RARFORMAT {RARFMT_NONE,RARFMT14,RARFMT15,RARFMT50,RARFMT_FUTURE};\n\nenum ADDSUBDATA_FLAGS\n{\n  ASDF_SPLIT          = 1, // Allow to split archive just before header if necessary.\n  ASDF_COMPRESS       = 2, // Allow to compress data following subheader.\n  ASDF_CRYPT          = 4, // Encrypt data after subheader if password is set.\n  ASDF_CRYPTIFHEADERS = 8  // Encrypt data after subheader only in -hp mode.\n};\n\nclass Archive:public File\n{\n  private:\n    void UpdateLatestTime(FileHeader *CurBlock);\n    void ConvertNameCase(wchar *Name);\n    void ConvertFileHeader(FileHeader *hd);\n    void WriteBlock50(HEADER_TYPE HeaderType,BaseBlock *wb,bool OnlySetSize,bool NonFinalWrite);\n    size_t ReadHeader14();\n    size_t ReadHeader15();\n    size_t ReadHeader50();\n    void ProcessExtra50(RawRead *Raw,size_t ExtraSize,BaseBlock *bb);\n    void RequestArcPassword();\n    void UnexpEndArcMsg();\n    void BrokenHeaderMsg();\n    void UnkEncVerMsg(const wchar *Name);\n    void UnkEncVerMsg();\n    bool ReadCommentData(Array<wchar> *CmtData);\n\n#if !defined(SHELL_EXT) && !defined(RAR_NOCRYPT)\n    CryptData HeadersCrypt;\n#endif\n#ifndef SHELL_EXT\n    ComprDataIO SubDataIO;\n#endif\n    bool DummyCmd;\n    RAROptions *Cmd;\n\n    int64 RecoverySize;\n    int RecoveryPercent;\n\n    RarTime LatestTime;\n    int LastReadBlock;\n    HEADER_TYPE CurHeaderType;\n\n    bool SilentOpen;\n#ifdef USE_QOPEN\n    QuickOpen QOpen;\n#endif\n  public:\n    Archive(RAROptions *InitCmd=NULL);\n    ~Archive();\n    static RARFORMAT IsSignature(const byte *D,size_t Size);\n    bool IsArchive(bool EnableBroken);\n    size_t SearchBlock(HEADER_TYPE HeaderType);\n    size_t SearchSubBlock(const wchar *Type);\n    size_t SearchRR();\n    void WriteBlock(HEADER_TYPE HeaderType,BaseBlock *wb=NULL,bool OnlySetSize=false,bool NonFinalWrite=false);\n    void SetBlockSize(HEADER_TYPE HeaderType,BaseBlock *wb=NULL) {WriteBlock(HeaderType,wb,true);}\n    size_t ReadHeader();\n    void CheckArc(bool EnableBroken);\n    void CheckOpen(const wchar *Name);\n    bool WCheckOpen(const wchar *Name);\n    bool GetComment(Array<wchar> *CmtData);\n    void ViewComment();\n    void SetLatestTime(RarTime *NewTime);\n    void SeekToNext();\n    bool CheckAccess();\n    bool IsArcDir();\n    void ConvertAttributes();\n    void VolSubtractHeaderSize(size_t SubSize);\n    uint FullHeaderSize(size_t Size);\n    int64 GetStartPos();\n    void AddSubData(byte *SrcData,uint64 DataSize,File *SrcFile,\n         const wchar *Name,uint Flags);\n    bool ReadSubData(Array<byte> *UnpData,File *DestFile);\n    HEADER_TYPE GetHeaderType() {return CurHeaderType;};\n    RAROptions* GetRAROptions() {return Cmd;}\n    void SetSilentOpen(bool Mode) {SilentOpen=Mode;}\n#ifdef USE_QOPEN\n    bool Open(const wchar *Name,uint Mode=FMF_READ);\n    int Read(void *Data,size_t Size);\n    void Seek(int64 Offset,int Method);\n    int64 Tell();\n    void QOpenUnload() {QOpen.Unload();}\n#endif\n\n    BaseBlock ShortBlock;\n    MarkHeader MarkHead;\n    MainHeader MainHead;\n    CryptHeader CryptHead;\n    FileHeader FileHead;\n    EndArcHeader EndArcHead;\n    SubBlockHeader SubBlockHead;\n    FileHeader SubHead;\n    CommentHeader CommHead;\n    ProtectHeader ProtectHead;\n    AVHeader AVHead;\n    SignHeader SignHead;\n    UnixOwnersHeader UOHead;\n    MacFInfoHeader MACHead;\n    EAHeader EAHead;\n    StreamHeader StreamHead;\n\n    int64 CurBlockPos;\n    int64 NextBlockPos;\n\n    RARFORMAT Format;\n    bool Solid;\n    bool Volume;\n    bool MainComment;\n    bool Locked;\n    bool Signed;\n    bool FirstVolume;\n    bool NewNumbering;\n    bool Protected;\n    bool Encrypted;\n    size_t SFXSize;\n    bool BrokenHeader;\n    bool FailedHeaderDecryption;\n\n#if !defined(SHELL_EXT) && !defined(RAR_NOCRYPT)\n    byte ArcSalt[SIZE_SALT50];\n#endif\n\n    bool Splitting;\n\n    uint VolNumber;\n    int64 VolWrite;\n    uint64 AddingFilesSize;\n    uint64 AddingHeadersSize;\n\n    bool NewArchive;\n\n    wchar FirstVolumeName[NM];\n};\n\n\n#endif\n","#ifndef _RAR_FILE_\n#define _RAR_FILE_\n\n#ifdef _ANDROID // Need lseek64 to handle >2 GB files in Android.\n#define FILE_USE_OPEN\n#endif\n\n#ifdef _WIN_ALL\n  typedef HANDLE FileHandle;\n  #define FILE_BAD_HANDLE INVALID_HANDLE_VALUE\n#elif defined(FILE_USE_OPEN)\n  typedef off_t FileHandle;\n  #define FILE_BAD_HANDLE -1\n#else\n  typedef FILE* FileHandle;\n  #define FILE_BAD_HANDLE NULL\n#endif\n\nclass RAROptions;\n\nenum FILE_HANDLETYPE {FILE_HANDLENORMAL,FILE_HANDLESTD};\n\nenum FILE_ERRORTYPE {FILE_SUCCESS,FILE_NOTFOUND,FILE_READERROR};\n\nenum FILE_MODE_FLAGS {\n  // Request read only access to file. Default for Open.\n  FMF_READ=0,\n\n  // Request both read and write access to file. Default for Create.\n  FMF_UPDATE=1,\n\n  // Request write only access to file.\n  FMF_WRITE=2,\n\n  // Open files which are already opened for write by other programs.\n  FMF_OPENSHARED=4,\n\n  // Open files only if no other program is opened it even in shared mode.\n  FMF_OPENEXCLUSIVE=8,\n\n  // Provide read access to created file for other programs.\n  FMF_SHAREREAD=16,\n\n  // Mode flags are not defined yet.\n  FMF_UNDEFINED=256\n};\n\n\nclass File\n{\n  private:\n    FileHandle hFile;\n    bool LastWrite;\n    FILE_HANDLETYPE HandleType;\n    bool SkipClose;\n    bool IgnoreReadErrors;\n    bool NewFile;\n    bool AllowDelete;\n    bool AllowExceptions;\n#ifdef _WIN_ALL\n    bool NoSequentialRead;\n    uint CreateMode;\n#endif\n  protected:\n    bool OpenShared; // Set by 'Archive' class.\n  public:\n    wchar FileName[NM];\n\n    FILE_ERRORTYPE ErrorType;\n  public:\n    File();\n    virtual ~File();\n    void operator = (File &SrcFile);\n    virtual bool Open(const wchar *Name,uint Mode=FMF_READ);\n    void TOpen(const wchar *Name);\n    bool WOpen(const wchar *Name);\n    bool Create(const wchar *Name,uint Mode=FMF_UPDATE|FMF_SHAREREAD);\n    void TCreate(const wchar *Name,uint Mode=FMF_UPDATE|FMF_SHAREREAD);\n    bool WCreate(const wchar *Name,uint Mode=FMF_UPDATE|FMF_SHAREREAD);\n    bool Close();\n    bool Delete();\n    bool Rename(const wchar *NewName);\n    bool Write(const void *Data,size_t Size);\n    virtual int Read(void *Data,size_t Size);\n    int DirectRead(void *Data,size_t Size);\n    virtual void Seek(int64 Offset,int Method);\n    bool RawSeek(int64 Offset,int Method);\n    virtual int64 Tell();\n    void Prealloc(int64 Size);\n    byte GetByte();\n    void PutByte(byte Byte);\n    bool Truncate();\n    void Flush();\n    void SetOpenFileTime(RarTime *ftm,RarTime *ftc=NULL,RarTime *fta=NULL);\n    void SetCloseFileTime(RarTime *ftm,RarTime *fta=NULL);\n    static void SetCloseFileTimeByName(const wchar *Name,RarTime *ftm,RarTime *fta);\n    void GetOpenFileTime(RarTime *ft);\n    bool IsOpened() {return hFile!=FILE_BAD_HANDLE;};\n    int64 FileLength();\n    void SetHandleType(FILE_HANDLETYPE Type) {HandleType=Type;}\n    FILE_HANDLETYPE GetHandleType() {return HandleType;}\n    bool IsDevice();\n    static bool RemoveCreated();\n    FileHandle GetHandle() {return hFile;}\n    void SetHandle(FileHandle Handle) {Close();hFile=Handle;}\n    void SetIgnoreReadErrors(bool Mode) {IgnoreReadErrors=Mode;}\n    int64 Copy(File &Dest,int64 Length=INT64NDF);\n    void SetAllowDelete(bool Allow) {AllowDelete=Allow;}\n    void SetExceptions(bool Allow) {AllowExceptions=Allow;}\n#ifdef _WIN_ALL\n    void RemoveSequentialFlag() {NoSequentialRead=true;}\n#endif\n#ifdef _UNIX\n    int GetFD()\n    {\n#ifdef FILE_USE_OPEN\n      return hFile;\n#else\n      return fileno(hFile);\n#endif\n    }\n#endif\n};\n\n#endif\n","#ifndef _RAR_CMDDATA_\n#define _RAR_CMDDATA_\n\n\n#define DefaultStoreList L\"7z;ace;arj;bz2;cab;gz;jpeg;jpg;lha;lzh;mp3;rar;taz;tgz;xz;z;zip\"\n\nenum RAR_CMD_LIST_MODE {RCLM_AUTO,RCLM_REJECT_LISTS,RCLM_ACCEPT_LISTS};\n\nclass CommandData:public RAROptions\n{\n  private:\n    void ProcessSwitchesString(const wchar *Str);\n    void ProcessSwitch(const wchar *Switch);\n    void BadSwitch(const wchar *Switch);\n    uint GetExclAttr(const wchar *Str);\n\n    bool FileLists;\n    bool NoMoreSwitches;\n    RAR_CMD_LIST_MODE ListMode;\n    bool BareOutput;\n  public:\n    CommandData();\n    void Init();\n\n    void ParseCommandLine(bool Preprocess,int argc, char *argv[]);\n    void ParseArg(wchar *ArgW);\n    void ParseDone();\n    void ParseEnvVar();\n    void ReadConfig();\n    void PreprocessArg(const wchar *Arg);\n    void OutTitle();\n    void OutHelp(RAR_EXIT ExitCode);\n    bool IsSwitch(int Ch);\n    bool ExclCheck(const wchar *CheckName,bool Dir,bool CheckFullPath,bool CheckInclList);\n    static bool CheckArgs(StringList *Args,bool Dir,const wchar *CheckName,bool CheckFullPath,int MatchMode);\n    bool ExclDirByAttr(uint FileAttr);\n    bool TimeCheck(RarTime &ft);\n    bool SizeCheck(int64 Size);\n    bool AnyFiltersActive();\n    int IsProcessFile(FileHeader &FileHead,bool *ExactMatch=NULL,int MatchType=MATCH_WILDSUBPATH,\n                      wchar *MatchedArg=NULL,uint MatchedArgSize=0);\n    void ProcessCommand();\n    void AddArcName(const wchar *Name);\n    bool GetArcName(wchar *Name,int MaxSize);\n    bool CheckWinSize();\n\n    int GetRecoverySize(const wchar *Str,int DefSize);\n\n#ifndef SFX_MODULE\n    void ReportWrongSwitches(RARFORMAT Format);\n#endif\n\n    wchar Command[NM+16];\n\n    wchar ArcName[NM];\n\n    StringList FileArgs;\n    StringList ExclArgs;\n    StringList InclArgs;\n    StringList ArcNames;\n    StringList StoreArgs;\n};\n\n#endif\n","#ifndef _RAR_STRLIST_\n#define _RAR_STRLIST_\n\nclass StringList\n{\n  private:\n    Array<wchar> StringData;\n    size_t CurPos;\n\n    uint StringsCount;\n\n    size_t SaveCurPos[16],SavePosNumber;\n  public:\n    StringList();\n    void Reset();\n    void AddStringA(const char *Str);\n    void AddString(const wchar *Str);\n    bool GetStringA(char *Str,size_t MaxLength);\n    bool GetString(wchar *Str,size_t MaxLength);\n    bool GetString(wchar *Str,size_t MaxLength,int StringNum);\n    wchar* GetString();\n    bool GetString(wchar **Str);\n    void Rewind();\n    uint ItemsCount() {return StringsCount;};\n    size_t GetCharCount() {return StringData.Size();}\n    bool Search(const wchar *Str,bool CaseSensitive);\n    void SavePosition();\n    void RestorePosition();\n};\n\n#endif\n","#include \"rar.hpp\"\n\nQuickOpen::QuickOpen()\n{\n  Buf=NULL;\n  Init(NULL,false);\n}\n\n\nQuickOpen::~QuickOpen()\n{\n  Close();\n  delete[] Buf;\n}\n\n\nvoid QuickOpen::Init(Archive *Arc,bool WriteMode)\n{\n  if (Arc!=NULL) // Unless called from constructor.\n    Close();\n\n  QuickOpen::Arc=Arc;\n  QuickOpen::WriteMode=WriteMode;\n\n  ListStart=NULL;\n  ListEnd=NULL;\n\n  if (Buf==NULL)\n    Buf=new byte[MaxBufSize];\n\n  CurBufSize=0; // Current size of buffered data in write mode.\n\n  Loaded=false;\n}\n\n\nvoid QuickOpen::Close()\n{\n  QuickOpenItem *Item=ListStart;\n  while (Item!=NULL)\n  {\n    QuickOpenItem *Next=Item->Next;\n    delete[] Item->Header;\n    delete Item;\n    Item=Next;\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid QuickOpen::Load(uint64 BlockPos)\n{\n  if (!Loaded) // If loading the first time, perform additional intialization.\n  {\n    SeekPos=Arc->Tell();\n    UnsyncSeekPos=false;\n\n    SaveFilePos SavePos(*Arc);\n    Arc->Seek(BlockPos,SEEK_SET);\n    if (Arc->ReadHeader()==0 || Arc->GetHeaderType()!=HEAD_SERVICE ||\n        !Arc->SubHead.CmpName(SUBHEAD_TYPE_QOPEN))\n      return;\n    QLHeaderPos=Arc->CurBlockPos;\n    RawDataStart=Arc->Tell();\n    RawDataSize=Arc->SubHead.UnpSize;\n\n    Loaded=true; // Set only after all file processing calls like Tell, Seek, ReadHeader.\n  }\n\n  if (Arc->SubHead.Encrypted)\n  {\n    RAROptions *Cmd=Arc->GetRAROptions();\n#ifndef RAR_NOCRYPT\n    if (Cmd->Password.IsSet())\n      Crypt.SetCryptKeys(false,CRYPT_RAR50,&Cmd->Password,Arc->SubHead.Salt,\n                         Arc->SubHead.InitV,Arc->SubHead.Lg2Count,\n                         Arc->SubHead.HashKey,Arc->SubHead.PswCheck);\n    else\n#endif\n      return;\n  }\n\n  RawDataPos=0;\n  ReadBufSize=0;\n  ReadBufPos=0;\n  LastReadHeader.Reset();\n  LastReadHeaderPos=0;\n\n  ReadBuffer();\n}\n\n\nbool QuickOpen::Read(void *Data,size_t Size,size_t &Result)\n{\n  if (!Loaded)\n    return false;\n  // Find next suitable cached block.\n  while (LastReadHeaderPos+LastReadHeader.Size()<=SeekPos)\n    if (!ReadNext())\n      break;\n  if (!Loaded)\n  {\n    // If something wrong happened, let's set the correct file pointer\n    // and stop further quick open processing.\n    if (UnsyncSeekPos)\n      Arc->File::Seek(SeekPos,SEEK_SET);\n    return false;\n  }\n\n  if (SeekPos>=LastReadHeaderPos && SeekPos+Size<=LastReadHeaderPos+LastReadHeader.Size())\n  {\n    memcpy(Data,LastReadHeader+size_t(SeekPos-LastReadHeaderPos),Size);\n    Result=Size;\n    SeekPos+=Size;\n    UnsyncSeekPos=true;\n  }\n  else\n  {\n    if (UnsyncSeekPos)\n    {\n      Arc->File::Seek(SeekPos,SEEK_SET);\n      UnsyncSeekPos=false;\n    }\n    int ReadSize=Arc->File::Read(Data,Size);\n    if (ReadSize<0)\n    {\n      Loaded=false;\n      return false;\n    }\n    Result=ReadSize;\n    SeekPos+=ReadSize;\n  }\n  \n  return true;\n}\n\n\nbool QuickOpen::Seek(int64 Offset,int Method)\n{\n  if (!Loaded)\n    return false;\n\n  // Normally we process an archive sequentially from beginning to end,\n  // so we read quick open data sequentially. But some operations like\n  // archive updating involve several passes. So if we detect that file\n  // pointer is moved back, we reload quick open data from beginning.\n  if (Method==SEEK_SET && (uint64)Offset<SeekPos && (uint64)Offset<LastReadHeaderPos)\n    Load(QLHeaderPos);\n\n  if (Method==SEEK_SET)\n    SeekPos=Offset;\n  if (Method==SEEK_CUR)\n    SeekPos+=Offset;\n  UnsyncSeekPos=true;\n\n  if (Method==SEEK_END)\n  {\n    Arc->File::Seek(Offset,SEEK_END);\n    SeekPos=Arc->File::Tell();\n    UnsyncSeekPos=false;\n  }\n  return true;\n}\n\n\nbool QuickOpen::Tell(int64 *Pos)\n{\n  if (!Loaded)\n    return false;\n  *Pos=SeekPos;\n  return true;\n}\n\n\nuint QuickOpen::ReadBuffer()\n{\n  SaveFilePos SavePos(*Arc);\n  Arc->File::Seek(RawDataStart+RawDataPos,SEEK_SET);\n  size_t SizeToRead=(size_t)Min(RawDataSize-RawDataPos,MaxBufSize-ReadBufSize);\n  if (Arc->SubHead.Encrypted)\n    SizeToRead &= ~CRYPT_BLOCK_MASK;\n  if (SizeToRead==0)\n    return 0;\n  int ReadSize=Arc->File::Read(Buf+ReadBufSize,SizeToRead);\n  if (ReadSize<=0)\n    return 0;\n#ifndef RAR_NOCRYPT\n  if (Arc->SubHead.Encrypted)\n    Crypt.DecryptBlock(Buf+ReadBufSize,ReadSize & ~CRYPT_BLOCK_MASK);\n#endif\n  RawDataPos+=ReadSize;\n  ReadBufSize+=ReadSize;\n  return ReadSize;\n}\n\n\n// Fill RawRead object from buffer.\nbool QuickOpen::ReadRaw(RawRead &Raw)\n{\n  if (MaxBufSize-ReadBufPos<0x100) // We are close to end of buffer.\n  {\n    // Ensure that we have enough data to read CRC and header size.\n    size_t DataLeft=ReadBufSize-ReadBufPos;\n    memcpy(Buf,Buf+ReadBufPos,DataLeft);\n    ReadBufPos=0;\n    ReadBufSize=DataLeft;\n    ReadBuffer();\n  }\n  const size_t FirstReadSize=7;\n  if (ReadBufPos+FirstReadSize>ReadBufSize)\n    return false;\n  Raw.Read(Buf+ReadBufPos,FirstReadSize);\n  ReadBufPos+=FirstReadSize;\n\n  uint SavedCRC=Raw.Get4();\n  uint SizeBytes=Raw.GetVSize(4);\n  uint64 BlockSize=Raw.GetV();\n  int SizeToRead=int(BlockSize);\n  SizeToRead-=FirstReadSize-SizeBytes-4; // Adjust overread size bytes if any.\n  if (SizeToRead<0 || SizeBytes==0 || BlockSize==0)\n  {\n    Loaded=false; // Invalid data.\n    return false;\n  }\n\n  // If rest of block data crosses buffer boundary, read it in loop.\n  size_t DataLeft=ReadBufSize-ReadBufPos;\n  while (SizeToRead>0)\n  {\n    size_t CurSizeToRead=Min(DataLeft,(size_t)SizeToRead);\n    Raw.Read(Buf+ReadBufPos,CurSizeToRead);\n    ReadBufPos+=CurSizeToRead;\n    SizeToRead-=int(CurSizeToRead);\n    if (SizeToRead>0) // We read the entire buffer and still need more data.\n    {\n      ReadBufPos=0;\n      ReadBufSize=0;\n      if (ReadBuffer()==0)\n        return false;\n    }\n  }\n\n  return SavedCRC==Raw.GetCRC50();\n}\n\n\n// Read next cached header.\nbool QuickOpen::ReadNext()\n{\n  RawRead Raw(NULL);\n  if (!ReadRaw(Raw)) // Read internal quick open header preceding stored block.\n    return false;\n  uint Flags=(uint)Raw.GetV();\n  uint64 Offset=Raw.GetV();\n  size_t HeaderSize=(size_t)Raw.GetV();\n  LastReadHeader.Alloc(HeaderSize);\n  Raw.GetB(&LastReadHeader[0],HeaderSize);\n  // Calculate the absolute position as offset from quick open service header.\n  LastReadHeaderPos=QLHeaderPos-Offset;\n  return true;\n}\n","#ifndef _RAR_SAVEPOS_\n#define _RAR_SAVEPOS_\n\nclass SaveFilePos\n{\n  private:\n    File *SaveFile;\n    int64 SavePos;\n  public:\n    SaveFilePos(File &Src)\n    {\n      SaveFile=&Src;\n      SavePos=Src.Tell();\n    }\n    ~SaveFilePos()\n    {\n      SaveFile->Seek(SavePos,SEEK_SET);\n    }\n};\n\n#endif\n","#ifndef _RAR_HEADERS_\n#define _RAR_HEADERS_\n\n#define  SIZEOF_MARKHEAD3        7 // Size of RAR 4.x archive mark header.\n#define  SIZEOF_MAINHEAD14       7 // Size of RAR 1.4 main archive header.\n#define  SIZEOF_MAINHEAD3       13 // Size of RAR 4.x main archive header.\n#define  SIZEOF_FILEHEAD14      21 // Size of RAR 1.4 file header.\n#define  SIZEOF_FILEHEAD3       32 // Size of RAR 3.0 file header.\n#define  SIZEOF_SHORTBLOCKHEAD   7\n#define  SIZEOF_LONGBLOCKHEAD   11\n#define  SIZEOF_SUBBLOCKHEAD    14\n#define  SIZEOF_COMMHEAD        13\n#define  SIZEOF_PROTECTHEAD     26\n#define  SIZEOF_AVHEAD          14\n#define  SIZEOF_SIGNHEAD        15\n#define  SIZEOF_UOHEAD          18\n#define  SIZEOF_MACHEAD         22\n#define  SIZEOF_EAHEAD          24\n#define  SIZEOF_BEEAHEAD        24\n#define  SIZEOF_STREAMHEAD      26\n\n#define  VER_PACK               29\n#define  VER_PACK5              50 // It is stored as 0, but we subtract 50 when saving an archive.\n#define  VER_UNPACK             29\n#define  VER_UNPACK5            50 // It is stored as 0, but we add 50 when reading an archive.\n\n#define  MHD_VOLUME         0x0001U\n\n// Old style main archive comment embed into main archive header. Must not\n// be used in new archives anymore.\n#define  MHD_COMMENT        0x0002U\n\n#define  MHD_LOCK           0x0004U\n#define  MHD_SOLID          0x0008U\n#define  MHD_PACK_COMMENT   0x0010U\n#define  MHD_NEWNUMBERING   0x0010U\n#define  MHD_AV             0x0020U\n#define  MHD_PROTECT        0x0040U\n#define  MHD_PASSWORD       0x0080U\n#define  MHD_FIRSTVOLUME    0x0100U\n\n#define  LHD_SPLIT_BEFORE   0x0001U\n#define  LHD_SPLIT_AFTER    0x0002U\n#define  LHD_PASSWORD       0x0004U\n\n// Old style file comment embed into file header. Must not be used\n// in new archives anymore.\n#define  LHD_COMMENT        0x0008U\n\n// For non-file subheaders it denotes 'subblock having a parent file' flag.\n#define  LHD_SOLID          0x0010U\n\n\n#define  LHD_WINDOWMASK     0x00e0U\n#define  LHD_WINDOW64       0x0000U\n#define  LHD_WINDOW128      0x0020U\n#define  LHD_WINDOW256      0x0040U\n#define  LHD_WINDOW512      0x0060U\n#define  LHD_WINDOW1024     0x0080U\n#define  LHD_WINDOW2048     0x00a0U\n#define  LHD_WINDOW4096     0x00c0U\n#define  LHD_DIRECTORY      0x00e0U\n\n#define  LHD_LARGE          0x0100U\n#define  LHD_UNICODE        0x0200U\n#define  LHD_SALT           0x0400U\n#define  LHD_VERSION        0x0800U\n#define  LHD_EXTTIME        0x1000U\n\n#define  SKIP_IF_UNKNOWN    0x4000U\n#define  LONG_BLOCK         0x8000U\n\n#define  EARC_NEXT_VOLUME   0x0001U // Not last volume.\n#define  EARC_DATACRC       0x0002U // Store CRC32 of RAR archive (now is used only in volumes).\n#define  EARC_REVSPACE      0x0004U // Reserve space for end of REV file 7 byte record.\n#define  EARC_VOLNUMBER     0x0008U // Store a number of current volume.\n\nenum HEADER_TYPE {\n  // RAR 5.0 header types.\n  HEAD_MARK=0x00, HEAD_MAIN=0x01, HEAD_FILE=0x02, HEAD_SERVICE=0x03,\n  HEAD_CRYPT=0x04, HEAD_ENDARC=0x05, HEAD_UNKNOWN=0xff,\n\n  // RAR 1.5 - 4.x header types.\n  HEAD3_MARK=0x72,HEAD3_MAIN=0x73,HEAD3_FILE=0x74,HEAD3_CMT=0x75,\n  HEAD3_AV=0x76,HEAD3_OLDSERVICE=0x77,HEAD3_PROTECT=0x78,HEAD3_SIGN=0x79,\n  HEAD3_SERVICE=0x7a,HEAD3_ENDARC=0x7b\n};\n\nenum { EA_HEAD=0x100,UO_HEAD=0x101,MAC_HEAD=0x102,BEEA_HEAD=0x103,\n       NTACL_HEAD=0x104,STREAM_HEAD=0x105 };\n\n\n// Internal implementation, depends on archive format version.\nenum HOST_SYSTEM {\n  // RAR 5.0 host OS\n  HOST5_WINDOWS=0,HOST5_UNIX=1,\n\n  // RAR 3.0 host OS.\n  HOST_MSDOS=0,HOST_OS2=1,HOST_WIN32=2,HOST_UNIX=3,HOST_MACOS=4,\n  HOST_BEOS=5,HOST_MAX\n};\n\n// Unified archive format independent implementation.\nenum HOST_SYSTEM_TYPE {\n  HSYS_WINDOWS, HSYS_UNIX, HSYS_UNKNOWN\n};\n\n\n// We also use these values in extra field, so do not modify them.\nenum FILE_SYSTEM_REDIRECT {\n  FSREDIR_NONE=0, FSREDIR_UNIXSYMLINK, FSREDIR_WINSYMLINK, FSREDIR_JUNCTION,\n  FSREDIR_HARDLINK, FSREDIR_FILECOPY\n};\n\n\n#define SUBHEAD_TYPE_CMT      L\"CMT\"\n#define SUBHEAD_TYPE_QOPEN    L\"QO\"\n#define SUBHEAD_TYPE_ACL      L\"ACL\"\n#define SUBHEAD_TYPE_STREAM   L\"STM\"\n#define SUBHEAD_TYPE_UOWNER   L\"UOW\"\n#define SUBHEAD_TYPE_AV       L\"AV\"\n#define SUBHEAD_TYPE_RR       L\"RR\"\n#define SUBHEAD_TYPE_OS2EA    L\"EA2\"\n\n/* new file inherits a subblock when updating a host file */\n#define SUBHEAD_FLAGS_INHERITED    0x80000000\n\n#define SUBHEAD_FLAGS_CMT_UNICODE  0x00000001\n\n\nstruct MarkHeader\n{\n  byte Mark[8];\n\n  // Following fields are virtual and not present in real blocks.\n  uint HeadSize;\n};\n\n\nstruct BaseBlock\n{\n  uint HeadCRC;  // 'ushort' for RAR 1.5.\n  HEADER_TYPE HeaderType; // 1 byte for RAR 1.5.\n  uint Flags;    // 'ushort' for RAR 1.5.\n  uint HeadSize; // 'ushort' for RAR 1.5, up to 2 MB for RAR 5.0.\n\n  bool SkipIfUnknown;\n\n  void Reset()\n  {\n    SkipIfUnknown=false;\n  }\n};\n\n\nstruct BlockHeader:BaseBlock\n{\n  uint DataSize;\n};\n\n\nstruct MainHeader:BaseBlock\n{\n  ushort HighPosAV;\n  uint PosAV;\n  bool CommentInHeader;\n  bool PackComment; // For RAR 1.4 archive format only.\n  bool Locator;\n  uint64 QOpenOffset;  // Offset of quick list record.\n  uint64 QOpenMaxSize; // Maximum size of QOpen offset in locator extra field.\n  uint64 RROffset;     // Offset of recovery record.\n  uint64 RRMaxSize;    // Maximum size of RR offset in locator extra field.\n  void Reset();\n};\n\n\nstruct FileHeader:BlockHeader\n{\n  byte HostOS;\n  byte UnpVer;\n  byte Method;\n  union {\n    uint FileAttr;\n    uint SubFlags;\n  };\n  wchar FileName[NM];\n\n  Array<byte> SubData;\n\n  RarTime mtime;\n  RarTime ctime;\n  RarTime atime;\n\n  int64 PackSize;\n  int64 UnpSize;\n  int64 MaxSize; // Reserve size bytes for vint of this size.\n\n  HashValue FileHash;\n\n  uint FileFlags;\n\n  bool SplitBefore;\n  bool SplitAfter;\n\n  bool UnknownUnpSize;\n\n  bool Encrypted;\n  CRYPT_METHOD CryptMethod;\n  bool SaltSet;\n  byte Salt[SIZE_SALT50];\n  byte InitV[SIZE_INITV];\n  bool UsePswCheck;\n  byte PswCheck[SIZE_PSWCHECK];\n\n  // Use HMAC calculated from HashKey and checksum instead of plain checksum.\n  bool UseHashKey;\n\n  // Key to convert checksum to HMAC. Derived from password with PBKDF2\n  // using additional iterations.\n  byte HashKey[SHA256_DIGEST_SIZE];\n\n  uint Lg2Count; // Log2 of PBKDF2 repetition count.\n\n  bool Solid;\n  bool Dir;\n  bool CommentInHeader; // RAR 2.0 file comment.\n  bool Version;   // name.ext;ver file name containing the version number.\n  size_t WinSize;\n  bool Inherited; // New file inherits a subblock when updating a host file (for subblocks only).\n\n  // 'true' if file sizes use 8 bytes instead of 4. Not used in RAR 5.0.\n  bool LargeFile;\n  \n  // 'true' for HEAD_SERVICE block, which is a child of preceding file block.\n  // RAR 4.x uses 'solid' flag to indicate child subheader blocks in archives.\n  bool SubBlock;\n\n  HOST_SYSTEM_TYPE HSType;\n\n  FILE_SYSTEM_REDIRECT RedirType;\n  wchar RedirName[NM];\n  bool DirTarget;\n\n  bool UnixOwnerSet,UnixOwnerNumeric,UnixGroupNumeric;\n  char UnixOwnerName[256],UnixGroupName[256];\n#ifdef _UNIX\n  uid_t UnixOwnerID;\n  gid_t UnixGroupID;\n#else // Need these Unix fields in Windows too for 'list' command.\n  uint UnixOwnerID;\n  uint UnixGroupID;\n#endif\n\n  void Reset(size_t SubDataSize=0);\n\n  bool CmpName(const wchar *Name)\n  {\n    return(wcscmp(FileName,Name)==0);\n  }\n\n  FileHeader& operator = (FileHeader &hd);\n};\n\n\nstruct EndArcHeader:BaseBlock\n{\n  // Optional CRC32 of entire archive up to start of EndArcHeader block.\n  // Present in RAR 4.x archives if EARC_DATACRC flag is set.\n  uint ArcDataCRC;  \n  \n  uint VolNumber; // Optional number of current volume.\n\n  // 7 additional zero bytes can be stored here if EARC_REVSPACE is set.\n\n  bool NextVolume; // Not last volume.\n  bool DataCRC;\n  bool RevSpace;\n  bool StoreVolNumber;\n  void Reset()\n  {\n    BaseBlock::Reset();\n    NextVolume=false;\n    DataCRC=false;\n    RevSpace=false;\n    StoreVolNumber=false;\n  }\n};\n\n\nstruct CryptHeader:BaseBlock\n{\n  bool UsePswCheck;\n  uint Lg2Count; // Log2 of PBKDF2 repetition count.\n  byte Salt[SIZE_SALT50];\n  byte PswCheck[SIZE_PSWCHECK];\n};\n\n\n// SubBlockHeader and its successors were used in RAR 2.x format.\n// RAR 4.x uses FileHeader with HEAD_SERVICE HeaderType for subblocks.\nstruct SubBlockHeader:BlockHeader\n{\n  ushort SubType;\n  byte Level;\n};\n\n\nstruct CommentHeader:BaseBlock\n{\n  ushort UnpSize;\n  byte UnpVer;\n  byte Method;\n  ushort CommCRC;\n};\n\n\nstruct ProtectHeader:BlockHeader\n{\n  byte Version;\n  ushort RecSectors;\n  uint TotalBlocks;\n  byte Mark[8];\n};\n\n\nstruct AVHeader:BaseBlock\n{\n  byte UnpVer;\n  byte Method;\n  byte AVVer;\n  uint AVInfoCRC;\n};\n\n\nstruct SignHeader:BaseBlock\n{\n  uint CreationTime;\n  ushort ArcNameSize;\n  ushort UserNameSize;\n};\n\n\nstruct UnixOwnersHeader:SubBlockHeader\n{\n  ushort OwnerNameSize;\n  ushort GroupNameSize;\n/* dummy */\n  char OwnerName[256];\n  char GroupName[256];\n};\n\n\nstruct EAHeader:SubBlockHeader\n{\n  uint UnpSize;\n  byte UnpVer;\n  byte Method;\n  uint EACRC;\n};\n\n\nstruct StreamHeader:SubBlockHeader\n{\n  uint UnpSize;\n  byte UnpVer;\n  byte Method;\n  uint StreamCRC;\n  ushort StreamNameSize;\n  char StreamName[260];\n};\n\n\nstruct MacFInfoHeader:SubBlockHeader\n{\n  uint fileType;\n  uint fileCreator;\n};\n\n\n#endif\n","#ifndef _RAR_SECURE_PASSWORD_\n#define _RAR_SECURE_PASSWORD_\n\n// Store a password securely (if data encryption is provided by OS)\n// or obfuscated to make search for password in memory dump less trivial.\nclass SecPassword\n{\n  private:\n    void Process(const wchar *Src,size_t SrcSize,wchar *Dst,size_t DstSize,bool Encode);\n\n    wchar Password[MAXPASSWORD];\n\n    // It is important to have this 'bool' value, so if our object is cleaned\n    // with memset as a part of larger structure, it is handled correctly.\n    bool PasswordSet;\n  public:\n    SecPassword();\n    ~SecPassword();\n    void Clean();\n    void Get(wchar *Psw,size_t MaxSize);\n    void Set(const wchar *Psw);\n    bool IsSet() {return PasswordSet;}\n    size_t Length();\n    bool operator == (SecPassword &psw);\n\n    // Set to true if we need to pass a password to another process.\n    // We use it when transferring parameters to UAC elevated WinRAR.\n    bool CrossProcess;\n};\n\n\nvoid cleandata(void *data,size_t size);\nvoid SecHideData(void *Data,size_t DataSize,bool Encode,bool CrossProcess);\n\n#endif\n","#ifndef _RAR_RAWREAD_\n#define _RAR_RAWREAD_\n\nclass RawRead\n{\n  private:\n    Array<byte> Data;\n    File *SrcFile;\n    size_t DataSize;\n    size_t ReadPos;\n#ifndef SHELL_EXT\n    CryptData *Crypt;\n#endif\n  public:\n    RawRead();\n    RawRead(File *SrcFile);\n    void Reset();\n    size_t Read(size_t Size);\n    void Read(byte *SrcData,size_t Size);\n    byte   Get1();\n    ushort Get2();\n    uint   Get4();\n    uint64 Get8();\n    uint64 GetV();\n    uint   GetVSize(size_t Pos);\n    size_t GetB(void *Field,size_t Size);\n    void GetW(wchar *Field,size_t Size);\n    uint GetCRC15(bool ProcessedOnly);\n    uint GetCRC50();\n    byte* GetDataPtr() {return &Data[0];}\n    size_t Size() {return DataSize;}\n    size_t PaddedSize() {return Data.Size()-DataSize;}\n    size_t DataLeft() {return DataSize-ReadPos;}\n    size_t GetPos() {return ReadPos;}\n    void SetPos(size_t Pos) {ReadPos=Pos;}\n    void Skip(size_t Size) {ReadPos+=Size;}\n    void Rewind() {SetPos(0);}\n#ifndef SHELL_EXT\n    void SetCrypt(CryptData *Crypt) {RawRead::Crypt=Crypt;}\n#endif\n};\n\nuint64 RawGetV(const byte *Data,uint &ReadPos,uint DataSize,bool &Overflow);\n\ninline uint RawGet2(const void *Data)\n{\n  byte *D=(byte *)Data;\n  return D[0]+(D[1]<<8);\n}\n\ninline uint RawGet4(const void *Data)\n{\n  byte *D=(byte *)Data;\n#if defined(BIG_ENDIAN) || !defined(ALLOW_MISALIGNED) || !defined(PRESENT_INT32)\n  return D[0]+(D[1]<<8)+(D[2]<<16)+(D[3]<<24);\n#else\n  return GET_UINT32(*(uint32 *)D);\n#endif\n}\n\ninline uint64 RawGet8(const void *Data)\n{\n  byte *D=(byte *)Data;\n  return INT32TO64(RawGet4(D+4),RawGet4(D));\n}\n\n\n// We need these \"put\" functions also in UnRAR code. This is why they are\n// in rawread.hpp file even though they are \"write\" functions.\ninline void RawPut2(uint Field,void *Data)\n{\n  byte *D=(byte *)Data;\n  D[0]=(byte)(Field);\n  D[1]=(byte)(Field>>8);\n}\n\n\ninline void RawPut4(uint Field,void *Data)\n{\n  byte *D=(byte *)Data;\n#if defined(BIG_ENDIAN) || !defined(ALLOW_MISALIGNED) || !defined(PRESENT_INT32)\n  D[0]=(byte)(Field);\n  D[1]=(byte)(Field>>8);\n  D[2]=(byte)(Field>>16);\n  D[3]=(byte)(Field>>24);\n#else\n  *(uint32 *)D=Field;\n#endif\n}\n\n\ninline void RawPut8(uint64 Field,void *Data)\n{\n  byte *D=(byte *)Data;\n  D[0]=(byte)(Field);\n  D[1]=(byte)(Field>>8);\n  D[2]=(byte)(Field>>16);\n  D[3]=(byte)(Field>>24);\n  D[4]=(byte)(Field>>32);\n  D[5]=(byte)(Field>>40);\n  D[6]=(byte)(Field>>48);\n  D[7]=(byte)(Field>>56);\n}\n\n#endif\n","#include \"rar.hpp\"\n\nStringList::StringList()\n{\n  Reset();\n}\n\n\nvoid StringList::Reset()\n{\n  Rewind();\n  StringData.Reset();\n  StringsCount=0;\n  SavePosNumber=0;\n}\n\n\nvoid StringList::AddStringA(const char *Str)\n{\n  Array<wchar> StrW(strlen(Str));\n  CharToWide(Str,&StrW[0],StrW.Size());\n  AddString(&StrW[0]);\n}\n\n\nvoid StringList::AddString(const wchar *Str)\n{\n  if (Str==NULL)\n    Str=L\"\";\n\n  size_t PrevSize=StringData.Size();\n  StringData.Add(wcslen(Str)+1);\n  wcscpy(&StringData[PrevSize],Str);\n\n  StringsCount++;\n}\n\n\nbool StringList::GetStringA(char *Str,size_t MaxLength)\n{\n  Array<wchar> StrW(MaxLength);\n  if (!GetString(&StrW[0],StrW.Size()))\n    return false;\n  WideToChar(&StrW[0],Str,MaxLength);\n  return true;\n}\n\n\nbool StringList::GetString(wchar *Str,size_t MaxLength)\n{\n  wchar *StrPtr;\n  if (!GetString(&StrPtr))\n    return false;\n  wcsncpyz(Str,StrPtr,MaxLength);\n  return true;\n}\n\n\n#ifndef SFX_MODULE\nbool StringList::GetString(wchar *Str,size_t MaxLength,int StringNum)\n{\n  SavePosition();\n  Rewind();\n  bool RetCode=true;\n  while (StringNum-- >=0)\n    if (!GetString(Str,MaxLength))\n    {\n      RetCode=false;\n      break;\n    }\n  RestorePosition();\n  return RetCode;\n}\n#endif\n\n\nwchar* StringList::GetString()\n{\n  wchar *Str;\n  GetString(&Str);\n  return Str;\n}\n\n\nbool StringList::GetString(wchar **Str)\n{\n  if (CurPos>=StringData.Size()) // No more strings left unprocessed.\n  {\n    if (Str!=NULL)\n      *Str=NULL;\n    return false;\n  }\n\n  wchar *CurStr=&StringData[CurPos];\n  CurPos+=wcslen(CurStr)+1;\n  if (Str!=NULL)\n    *Str=CurStr;\n\n  return true;\n}\n\n\nvoid StringList::Rewind()\n{\n  CurPos=0;\n}\n\n\n#ifndef SFX_MODULE\nbool StringList::Search(const wchar *Str,bool CaseSensitive)\n{\n  SavePosition();\n  Rewind();\n  bool Found=false;\n  wchar *CurStr;\n  while (GetString(&CurStr))\n  {\n    if (Str!=NULL && CurStr!=NULL)\n      if ((CaseSensitive ? wcscmp(Str,CurStr):wcsicomp(Str,CurStr))!=0)\n        continue;\n    Found=true;\n    break;\n  }\n  RestorePosition();\n  return Found;\n}\n#endif\n\n\n#ifndef SFX_MODULE\nvoid StringList::SavePosition()\n{\n  if (SavePosNumber<ASIZE(SaveCurPos))\n  {\n    SaveCurPos[SavePosNumber]=CurPos;\n    SavePosNumber++;\n  }\n}\n#endif\n\n\n#ifndef SFX_MODULE\nvoid StringList::RestorePosition()\n{\n  if (SavePosNumber>0)\n  {\n    SavePosNumber--;\n    CurPos=SaveCurPos[SavePosNumber];\n  }\n}\n#endif\n","#include \"rar.hpp\"\n\nconst char *NullToEmpty(const char *Str)\n{\n  return Str==NULL ? \"\":Str;\n}\n\n\nconst wchar *NullToEmpty(const wchar *Str)\n{\n  return Str==NULL ? L\"\":Str;\n}\n\n\nvoid IntToExt(const char *Src,char *Dest,size_t DestSize)\n{\n#ifdef _WIN_ALL\n  // OemToCharBuff does not stop at 0, so let's check source length.\n  size_t SrcLength=strlen(Src)+1;\n  if (DestSize>SrcLength)\n    DestSize=SrcLength;\n  OemToCharBuffA(Src,Dest,(DWORD)DestSize);\n  Dest[DestSize-1]=0;\n#elif defined(_ANDROID)\n  wchar DestW[NM];\n  JniCharToWide(Src,DestW,ASIZE(DestW),true);\n  WideToChar(DestW,Dest,DestSize);\n#else\n  if (Dest!=Src)\n    strncpyz(Dest,Src,DestSize);\n#endif\n}\n\n\n// Convert archived names to Unicode. Allow user to select a code page in GUI.\nvoid ArcCharToWide(const char *Src,wchar *Dest,size_t DestSize,ACTW_ENCODING Encoding)\n{\n  if (Encoding==ACTW_UTF8)\n    UtfToWide(Src,Dest,DestSize);\n  else\n    CharToWide(Src,Dest,DestSize);\n  // Ensure that we return a zero terminate string for security reason.\n  // While [Jni]CharToWide might already do it, be protected in case of future\n  // changes in these functions.\n  if (DestSize>0)\n    Dest[DestSize-1]=0;\n}\n\n\nint stricomp(const char *s1,const char *s2)\n{\n#ifdef _WIN_ALL\n  return CompareStringA(LOCALE_USER_DEFAULT,NORM_IGNORECASE|SORT_STRINGSORT,s1,-1,s2,-1)-2;\n#else\n  while (toupper(*s1)==toupper(*s2))\n  {\n    if (*s1==0)\n      return 0;\n    s1++;\n    s2++;\n  }\n  return s1 < s2 ? -1 : 1;\n#endif\n}\n\n\nint strnicomp(const char *s1,const char *s2,size_t n)\n{\n#ifdef _WIN_ALL\n  // If we specify 'n' exceeding the actual string length, CompareString goes\n  // beyond the trailing zero and compares garbage. So we need to limit 'n'\n  // to real string length.\n  // It is important to use strnlen (or memchr(...,0)) instead of strlen,\n  // because data can be not zero terminated.\n  size_t l1=Min(strnlen(s1,n),n);\n  size_t l2=Min(strnlen(s2,n),n);\n  return CompareStringA(LOCALE_USER_DEFAULT,NORM_IGNORECASE|SORT_STRINGSORT,s1,(int)l1,s2,(int)l2)-2;\n#else\n  if (n==0)\n    return 0;\n  while (toupper(*s1)==toupper(*s2))\n  {\n    if (*s1==0 || --n==0)\n      return 0;\n    s1++;\n    s2++;\n  }\n  return s1 < s2 ? -1 : 1;\n#endif\n}\n\n\nwchar* RemoveEOL(wchar *Str)\n{\n  for (int I=(int)wcslen(Str)-1;I>=0 && (Str[I]=='\\r' || Str[I]=='\\n' || Str[I]==' ' || Str[I]=='\\t');I--)\n    Str[I]=0;\n  return Str;\n}\n\n\nwchar* RemoveLF(wchar *Str)\n{\n  for (int I=(int)wcslen(Str)-1;I>=0 && (Str[I]=='\\r' || Str[I]=='\\n');I--)\n    Str[I]=0;\n  return Str;\n}\n\n\nunsigned char loctolower(unsigned char ch)\n{\n#ifdef _WIN_ALL\n  // Convert to LPARAM first to avoid a warning in 64 bit mode.\n  return (int)(LPARAM)CharLowerA((LPSTR)ch);\n#else\n  return tolower(ch);\n#endif\n}\n\n\nunsigned char loctoupper(unsigned char ch)\n{\n#ifdef _WIN_ALL\n  // Convert to LPARAM first to avoid a warning in 64 bit mode.\n  return (int)(LPARAM)CharUpperA((LPSTR)ch);\n#else\n  return toupper(ch);\n#endif\n}\n\n\n// toupper with English only results if English input is provided.\n// It avoids Turkish (small i) -> (big I with dot) conversion problem.\n// We do not define 'ch' as 'int' to avoid necessity to cast all\n// signed chars passed to this function to unsigned char.\nunsigned char etoupper(unsigned char ch)\n{\n  if (ch=='i')\n    return 'I';\n  return toupper(ch);\n}\n\n\n// Unicode version of etoupper.\nwchar etoupperw(wchar ch)\n{\n  if (ch=='i')\n    return 'I';\n  return toupperw(ch);\n}\n\n\n// We do not want to cast every signed char to unsigned when passing to\n// isdigit, so we implement the replacement. Shall work for Unicode too.\n// If chars are signed, conversion from char to int could generate negative\n// values, resulting in undefined behavior in standard isdigit.\nbool IsDigit(int ch)\n{\n  return ch>='0' && ch<='9';\n}\n\n\n// We do not want to cast every signed char to unsigned when passing to\n// isspace, so we implement the replacement. Shall work for Unicode too.\n// If chars are signed, conversion from char to int could generate negative\n// values, resulting in undefined behavior in standard isspace.\nbool IsSpace(int ch)\n{\n  return ch==' ' || ch=='\\t';\n}\n\n\n// We do not want to cast every signed char to unsigned when passing to\n// isalpha, so we implement the replacement. Shall work for Unicode too.\n// If chars are signed, conversion from char to int could generate negative\n// values, resulting in undefined behavior in standard function.\nbool IsAlpha(int ch)\n{\n  return ch>='A' && ch<='Z' || ch>='a' && ch<='z';\n}\n\n\n\n\nvoid BinToHex(const byte *Bin,size_t BinSize,char *HexA,wchar *HexW,size_t HexSize)\n{\n  uint A=0,W=0; // ASCII and Unicode hex output positions.\n  for (uint I=0;I<BinSize;I++)\n  {\n    uint High=Bin[I] >> 4;\n    uint Low=Bin[I] & 0xf;\n    uint HighHex=High>9 ? 'a'+High-10:'0'+High;\n    uint LowHex=Low>9 ? 'a'+Low-10:'0'+Low;\n    if (HexA!=NULL && A<HexSize-2) // Need space for 2 chars and final zero.\n    {\n      HexA[A++]=(char)HighHex;\n      HexA[A++]=(char)LowHex;\n    }\n    if (HexW!=NULL && W<HexSize-2) // Need space for 2 chars and final zero.\n    {\n      HexW[W++]=HighHex;\n      HexW[W++]=LowHex;\n    }\n  }\n  if (HexA!=NULL && HexSize>0)\n    HexA[A]=0;\n  if (HexW!=NULL && HexSize>0)\n    HexW[W]=0;\n}\n\n\n#ifndef SFX_MODULE\nuint GetDigits(uint Number)\n{\n  uint Digits=1;\n  while (Number>=10)\n  {\n    Number/=10;\n    Digits++;\n  }\n  return Digits;\n}\n#endif\n\n\nbool LowAscii(const char *Str)\n{\n  for (int I=0;Str[I]!=0;I++)\n    if ((byte)Str[I]<32 || (byte)Str[I]>127)\n      return false;\n  return true;\n}\n\n\nbool LowAscii(const wchar *Str)\n{\n  for (int I=0;Str[I]!=0;I++)\n  {\n    // We convert wchar_t to uint just in case if some compiler\n    // uses signed wchar_t.\n    if ((uint)Str[I]<32 || (uint)Str[I]>127)\n      return false;\n  }\n  return true;\n}\n\n\nint wcsicompc(const wchar *Str1,const wchar *Str2)\n{\n#if defined(_UNIX)\n  return wcscmp(Str1,Str2);\n#else\n  return wcsicomp(Str1,Str2);\n#endif\n}\n\n\n// safe strncpy: copies maxlen-1 max and always returns zero terminated dest\nchar* strncpyz(char *dest, const char *src, size_t maxlen)\n{\n  if (maxlen>0)\n  {\n    strncpy(dest,src,maxlen-1);\n    dest[maxlen-1]=0;\n  }\n  return dest;\n}\n\n\n// Safe wcsncpy: copies maxlen-1 max and always returns zero terminated dest.\nwchar* wcsncpyz(wchar *dest, const wchar *src, size_t maxlen)\n{\n  if (maxlen>0)\n  {\n    wcsncpy(dest,src,maxlen-1);\n    dest[maxlen-1]=0;\n  }\n  return dest;\n}\n\n\n// Safe strncat: resulting dest length cannot exceed maxlen and dest \n// is always zero terminated. Note that 'maxlen' parameter defines the entire\n// dest buffer size and is not compatible with standard strncat.\nchar* strncatz(char* dest, const char* src, size_t maxlen)\n{\n  size_t Length = strlen(dest);\n  int avail=int(maxlen - Length - 1);\n  if (avail > 0)\n    strncat(dest, src, avail);\n  return dest;\n}\n\n\n// Safe wcsncat: resulting dest length cannot exceed maxlen and dest \n// is always zero terminated. Note that 'maxlen' parameter defines the entire\n// dest buffer size and is not compatible with standard wcsncat.\nwchar* wcsncatz(wchar* dest, const wchar* src, size_t maxlen)\n{\n  size_t Length = wcslen(dest);\n  int avail=int(maxlen - Length - 1);\n  if (avail > 0)\n    wcsncat(dest, src, avail);\n  return dest;\n}\n\n\nvoid itoa(int64 n,char *Str,size_t MaxSize)\n{\n  char NumStr[50];\n  size_t Pos=0;\n\n  int Neg=n < 0 ? 1 : 0;\n  if (Neg)\n    n=-n;\n\n  do\n  {\n    if (Pos+1>=MaxSize-Neg)\n      break;\n    NumStr[Pos++]=char(n%10)+'0';\n    n=n/10;\n  } while (n!=0);\n\n  if (Neg)\n    NumStr[Pos++]='-';\n\n  for (size_t I=0;I<Pos;I++)\n    Str[I]=NumStr[Pos-I-1];\n  Str[Pos]=0;\n}\n\n\nvoid itoa(int64 n,wchar *Str,size_t MaxSize)\n{\n  wchar NumStr[50];\n  size_t Pos=0;\n\n  int Neg=n < 0 ? 1 : 0;\n  if (Neg)\n    n=-n;\n\n  do\n  {\n    if (Pos+1>=MaxSize-Neg)\n      break;\n    NumStr[Pos++]=wchar(n%10)+'0';\n    n=n/10;\n  } while (n!=0);\n\n  if (Neg)\n    NumStr[Pos++]='-';\n\n  for (size_t I=0;I<Pos;I++)\n    Str[I]=NumStr[Pos-I-1];\n  Str[Pos]=0;\n}\n\n\nconst wchar* GetWide(const char *Src)\n{\n  const size_t MaxLength=NM;\n  static wchar StrTable[4][MaxLength];\n  static uint StrNum=0;\n  if (++StrNum >= ASIZE(StrTable))\n    StrNum=0;\n  wchar *Str=StrTable[StrNum];\n  CharToWide(Src,Str,MaxLength);\n  Str[MaxLength-1]=0;\n  return Str;\n}\n\n\n// Parse string containing parameters separated with spaces.\n// Support quote marks. Param can be NULL to return the pointer to next\n// parameter, which can be used to estimate the buffer size for Param.\nconst wchar* GetCmdParam(const wchar *CmdLine,wchar *Param,size_t MaxSize)\n{\n  while (IsSpace(*CmdLine))\n    CmdLine++;\n  if (*CmdLine==0)\n    return NULL;\n\n  size_t ParamSize=0;\n  bool Quote=false;\n  while (*CmdLine!=0 && (Quote || !IsSpace(*CmdLine)))\n  {\n    if (*CmdLine=='\\\"')\n    {\n      if (CmdLine[1]=='\\\"')\n      {\n        // Insert the quote character instead of two adjoining quote characters.\n        if (Param!=NULL && ParamSize<MaxSize-1)\n          Param[ParamSize++]='\\\"';\n        CmdLine++;\n      }\n      else\n        Quote=!Quote;\n    }\n    else\n      if (Param!=NULL && ParamSize<MaxSize-1)\n        Param[ParamSize++]=*CmdLine;\n    CmdLine++;\n  }\n  if (Param!=NULL)\n    Param[ParamSize]=0;\n  return CmdLine;\n}\n\n\n#ifndef SILENT\n// For compatibility with existing translations we use %s to print Unicode\n// strings in format strings and convert them to %ls here. %s could work\n// without such conversion in Windows, but not in Unix wprintf.\nvoid PrintfPrepareFmt(const wchar *Org,wchar *Cvt,size_t MaxSize)\n{\n  uint Src=0,Dest=0;\n  while (Org[Src]!=0 && Dest<MaxSize-1)\n  {\n    if (Org[Src]=='%' && (Src==0 || Org[Src-1]!='%'))\n    {\n      uint SPos=Src+1;\n      // Skipping a possible width specifier like %-50s.\n      while (IsDigit(Org[SPos]) || Org[SPos]=='-')\n        SPos++;\n      if (Org[SPos]=='s' && Dest<MaxSize-(SPos-Src+1))\n      {\n        while (Src<SPos)\n          Cvt[Dest++]=Org[Src++];\n        Cvt[Dest++]='l';\n      }\n    }\n#ifdef _WIN_ALL\n    // Convert \\n to \\r\\n in Windows. Important when writing to log,\n    // so other tools like Notebook can view resulting log properly.\n    if (Org[Src]=='\\n' && (Src==0 || Org[Src-1]!='\\r'))\n      Cvt[Dest++]='\\r';\n#endif\n\n    Cvt[Dest++]=Org[Src++];\n  }\n  Cvt[Dest]=0;\n}\n#endif\n","#include \"rar.hpp\"\n\nwchar* PointToName(const wchar *Path)\n{\n  for (int I=(int)wcslen(Path)-1;I>=0;I--)\n    if (IsPathDiv(Path[I]))\n      return (wchar*)&Path[I+1];\n  return (wchar*)((*Path && IsDriveDiv(Path[1])) ? Path+2:Path);\n}\n\n\nwchar* PointToLastChar(const wchar *Path)\n{\n  size_t Length=wcslen(Path);\n  return (wchar*)(Length>0 ? Path+Length-1:Path);\n}\n\n\nwchar* ConvertPath(const wchar *SrcPath,wchar *DestPath)\n{\n  const wchar *DestPtr=SrcPath;\n\n  // Prevent \\..\\ in any part of path string.\n  for (const wchar *s=DestPtr;*s!=0;s++)\n    if (IsPathDiv(s[0]) && s[1]=='.' && s[2]=='.' && IsPathDiv(s[3]))\n      DestPtr=s+4;\n\n  // Remove <d>:\\ and any sequence of . and \\ in the beginning of path string.\n  while (*DestPtr!=0)\n  {\n    const wchar *s=DestPtr;\n    if (s[0]!=0 && IsDriveDiv(s[1]))\n      s+=2;\n    if (s[0]=='\\\\' && s[1]=='\\\\')\n    {\n      const wchar *Slash=wcschr(s+2,'\\\\');\n      if (Slash!=NULL && (Slash=wcschr(Slash+1,'\\\\'))!=NULL)\n        s=Slash+1;\n    }\n    for (const wchar *t=s;*t!=0;t++)\n      if (IsPathDiv(*t))\n        s=t+1;\n      else\n        if (*t!='.')\n          break;\n    if (s==DestPtr)\n      break;\n    DestPtr=s;\n  }\n\n  // Code above does not remove last \"..\", doing here.\n  if (DestPtr[0]=='.' && DestPtr[1]=='.' && DestPtr[2]==0)\n    DestPtr+=2;\n  \n  if (DestPath!=NULL)\n  {\n    // SrcPath and DestPath can point to same memory area,\n    // so we use the temporary buffer for copying.\n    wchar TmpStr[NM];\n    wcsncpyz(TmpStr,DestPtr,ASIZE(TmpStr));\n    wcscpy(DestPath,TmpStr);\n  }\n  return (wchar *)DestPtr;\n}\n\n\nvoid SetName(wchar *FullName,const wchar *Name,size_t MaxSize)\n{\n  wchar *NamePtr=PointToName(FullName);\n  wcsncpyz(NamePtr,Name,MaxSize-(NamePtr-FullName));\n}\n\n\nvoid SetExt(wchar *Name,const wchar *NewExt,size_t MaxSize)\n{\n  if (Name==NULL || *Name==0)\n    return;\n  wchar *Dot=GetExt(Name);\n  if (Dot!=NULL)\n    *Dot=0;\n  if (NewExt!=NULL)\n  {\n    wcsncatz(Name,L\".\",MaxSize);\n    wcsncatz(Name,NewExt,MaxSize);\n  }\n}\n\n\n#ifndef SFX_MODULE\nvoid SetSFXExt(wchar *SFXName,size_t MaxSize)\n{\n  if (SFXName==NULL || *SFXName==0)\n    return;\n\n#ifdef _UNIX\n  SetExt(SFXName,L\"sfx\",MaxSize);\n#endif\n\n#if defined(_WIN_ALL) || defined(_EMX)\n  SetExt(SFXName,L\"exe\",MaxSize);\n#endif\n}\n#endif\n\n\n// 'Ext' is an extension with the leading dot, like L\".rar\".\nwchar *GetExt(const wchar *Name)\n{\n  return Name==NULL ? NULL:wcsrchr(PointToName(Name),'.');\n}\n\n\n// 'Ext' is an extension without the leading dot, like L\"rar\".\nbool CmpExt(const wchar *Name,const wchar *Ext)\n{\n  wchar *NameExt=GetExt(Name);\n  return NameExt!=NULL && wcsicomp(NameExt+1,Ext)==0;\n}\n\n\nbool IsWildcard(const wchar *Str)\n{\n  return Str==NULL ? false:wcspbrk(Str,L\"*?\")!=NULL;\n}\n\n\nbool IsPathDiv(int Ch)\n{\n#ifdef _WIN_ALL\n  return Ch=='\\\\' || Ch=='/';\n#else\n  return Ch==CPATHDIVIDER;\n#endif\n}\n\n\nbool IsDriveDiv(int Ch)\n{\n#ifdef _UNIX\n  return false;\n#else\n  return Ch==':';\n#endif\n}\n\n\nbool IsDriveLetter(const wchar *Path)\n{\n  wchar Letter=etoupperw(Path[0]);\n  return Letter>='A' && Letter<='Z' && IsDriveDiv(Path[1]);\n}\n\n\nint GetPathDisk(const wchar *Path)\n{\n  if (IsDriveLetter(Path))\n    return etoupperw(*Path)-'A';\n  else\n    return -1;\n}\n\n\nvoid AddEndSlash(wchar *Path,size_t MaxLength)\n{\n  size_t Length=wcslen(Path);\n  if (Length>0 && Path[Length-1]!=CPATHDIVIDER && Length+1<MaxLength)\n    wcscat(Path,SPATHDIVIDER);\n}\n\n\nvoid MakeName(const wchar *Path,const wchar *Name,wchar *Pathname,size_t MaxSize)\n{\n  // 'Name' and 'Pathname' can point to same memory area. This is why we use\n  // the temporary buffer instead of constructing the name in 'Pathname'.\n  wchar OutName[NM];\n  wcsncpyz(OutName,Path,ASIZE(OutName));\n  AddEndSlash(OutName,ASIZE(OutName));\n  wcsncatz(OutName,Name,ASIZE(OutName));\n  wcsncpyz(Pathname,OutName,MaxSize);\n}\n\n\n// Returns file path including the trailing path separator symbol.\nvoid GetFilePath(const wchar *FullName,wchar *Path,size_t MaxLength)\n{\n  if (MaxLength==0)\n    return;\n  size_t PathLength=Min(MaxLength-1,size_t(PointToName(FullName)-FullName));\n  wcsncpy(Path,FullName,PathLength);\n  Path[PathLength]=0;\n}\n\n\n// Removes name and returns file path without the trailing\n// path separator symbol.\nvoid RemoveNameFromPath(wchar *Path)\n{\n  wchar *Name=PointToName(Path);\n  if (Name>=Path+2 && (!IsDriveDiv(Path[1]) || Name>=Path+4))\n    Name--;\n  *Name=0;\n}\n\n\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\nbool GetAppDataPath(wchar *Path,size_t MaxSize,bool Create)\n{\n  LPMALLOC g_pMalloc;\n  SHGetMalloc(&g_pMalloc);\n  LPITEMIDLIST ppidl;\n  *Path=0;\n  bool Success=false;\n  if (SHGetSpecialFolderLocation(NULL,CSIDL_APPDATA,&ppidl)==NOERROR &&\n      SHGetPathFromIDList(ppidl,Path) && *Path!=0)\n  {\n    AddEndSlash(Path,MaxSize);\n    wcsncatz(Path,L\"WinRAR\",MaxSize);\n    Success=FileExist(Path);\n    if (!Success && Create)\n      Success=MakeDir(Path,false,0)==MKDIR_SUCCESS;\n  }\n  g_pMalloc->Free(ppidl);\n  return Success;\n}\n#endif\n\n\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\nvoid GetRarDataPath(wchar *Path,size_t MaxSize,bool Create)\n{\n  *Path=0;\n\n  HKEY hKey;\n  if (RegOpenKeyEx(HKEY_CURRENT_USER,L\"Software\\\\WinRAR\\\\Paths\",0,\n                   KEY_QUERY_VALUE,&hKey)==ERROR_SUCCESS)\n  {\n    DWORD DataSize=(DWORD)MaxSize,Type;\n    RegQueryValueEx(hKey,L\"AppData\",0,&Type,(BYTE *)Path,&DataSize);\n    RegCloseKey(hKey);\n  }\n\n  if (*Path==0 || !FileExist(Path))\n    if (!GetAppDataPath(Path,MaxSize,Create))\n    {\n      GetModuleFileName(NULL,Path,(DWORD)MaxSize);\n      RemoveNameFromPath(Path);\n    }\n}\n#endif\n\n\n#ifndef SFX_MODULE\nbool EnumConfigPaths(uint Number,wchar *Path,size_t MaxSize,bool Create)\n{\n#ifdef _UNIX\n  static const wchar *ConfPath[]={\n    L\"/etc\", L\"/etc/rar\", L\"/usr/lib\", L\"/usr/local/lib\", L\"/usr/local/etc\"\n  };\n  if (Number==0)\n  {\n    char *EnvStr=getenv(\"HOME\");\n    if (EnvStr!=NULL)\n      GetWideName(EnvStr,NULL,Path,MaxSize);\n    else\n      wcsncpyz(Path, ConfPath[0], MaxSize);\n    return true;\n  }\n  Number--;\n  if (Number>=ASIZE(ConfPath))\n    return false;\n  wcsncpyz(Path,ConfPath[Number], MaxSize);\n  return true;\n#elif defined(_WIN_ALL)\n  if (Number>1)\n    return false;\n  if (Number==0)\n    GetRarDataPath(Path,MaxSize,Create);\n  else\n  {\n    GetModuleFileName(NULL,Path,(DWORD)MaxSize);\n    RemoveNameFromPath(Path);\n  }\n  return true;\n#else\n  return false;\n#endif\n}\n#endif\n\n\n#ifndef SFX_MODULE\nvoid GetConfigName(const wchar *Name,wchar *FullName,size_t MaxSize,bool CheckExist,bool Create)\n{\n  *FullName=0;\n  for (uint I=0;EnumConfigPaths(I,FullName,MaxSize,Create);I++)\n  {\n    AddEndSlash(FullName,MaxSize);\n    wcsncatz(FullName,Name,MaxSize);\n    if (!CheckExist || WildFileExist(FullName))\n      break;\n  }\n}\n#endif\n\n\n// Returns a pointer to rightmost digit of volume number.\nwchar* GetVolNumPart(const wchar *ArcName)\n{\n  // Pointing to last name character.\n  const wchar *ChPtr=ArcName+wcslen(ArcName)-1;\n\n  // Skipping the archive extension.\n  while (!IsDigit(*ChPtr) && ChPtr>ArcName)\n    ChPtr--;\n\n  // Skipping the numeric part of name.\n  const wchar *NumPtr=ChPtr;\n  while (IsDigit(*NumPtr) && NumPtr>ArcName)\n    NumPtr--;\n\n  // Searching for first numeric part in names like name.part##of##.rar.\n  // Stop search on the first dot.\n  while (NumPtr>ArcName && *NumPtr!='.')\n  {\n    if (IsDigit(*NumPtr))\n    {\n      // Validate the first numeric part only if it has a dot somewhere \n      // before it.\n      wchar *Dot=wcschr(PointToName(ArcName),'.');\n      if (Dot!=NULL && Dot<NumPtr)\n        ChPtr=NumPtr;\n      break;\n    }\n    NumPtr--;\n  }\n  return (wchar *)ChPtr;\n}\n\n\nvoid NextVolumeName(wchar *ArcName,uint MaxLength,bool OldNumbering)\n{\n  wchar *ChPtr;\n  if ((ChPtr=GetExt(ArcName))==NULL)\n  {\n    wcsncatz(ArcName,L\".rar\",MaxLength);\n    ChPtr=GetExt(ArcName);\n  }\n  else\n    if (ChPtr[1]==0 && wcslen(ArcName)<MaxLength-3 || wcsicomp(ChPtr+1,L\"exe\")==0 || wcsicomp(ChPtr+1,L\"sfx\")==0)\n      wcscpy(ChPtr+1,L\"rar\");\n  if (!OldNumbering)\n  {\n    ChPtr=GetVolNumPart(ArcName);\n\n    while ((++(*ChPtr))=='9'+1)\n    {\n      *ChPtr='0';\n      ChPtr--;\n      if (ChPtr<ArcName || !IsDigit(*ChPtr))\n      {\n        for (wchar *EndPtr=ArcName+wcslen(ArcName);EndPtr!=ChPtr;EndPtr--)\n          *(EndPtr+1)=*EndPtr;\n        *(ChPtr+1)='1';\n        break;\n      }\n    }\n  }\n  else\n    if (!IsDigit(*(ChPtr+2)) || !IsDigit(*(ChPtr+3)))\n      wcscpy(ChPtr+2,L\"00\");\n    else\n    {\n      ChPtr+=3;\n      while ((++(*ChPtr))=='9'+1)\n        if (*(ChPtr-1)=='.')\n        {\n          *ChPtr='A';\n          break;\n        }\n        else\n        {\n          *ChPtr='0';\n          ChPtr--;\n        }\n    }\n}\n\n\nbool IsNameUsable(const wchar *Name)\n{\n#ifndef _UNIX\n  if (Name[0] && Name[1] && wcschr(Name+2,':')!=NULL)\n    return false;\n  for (const wchar *s=Name;*s!=0;s++)\n  {\n    if ((uint)*s<32)\n      return false;\n    if ((*s==' ' || *s=='.') && IsPathDiv(s[1]))\n      return false;\n  }\n#endif\n  return *Name!=0 && wcspbrk(Name,L\"?*<>|\\\"\")==NULL;\n}\n\n\nvoid MakeNameUsable(char *Name,bool Extended)\n{\n#ifdef _WIN_ALL\n  // In Windows we also need to convert characters not defined in current\n  // code page. This double conversion changes them to '?', which is\n  // catched by code below.\n  size_t NameLength=strlen(Name);\n  wchar NameW[NM];\n  CharToWide(Name,NameW,ASIZE(NameW));\n  WideToChar(NameW,Name,NameLength+1);\n  Name[NameLength]=0;\n#endif\n  for (char *s=Name;*s!=0;s=charnext(s))\n  {\n    if (strchr(Extended ? \"?*<>|\\\"\":\"?*\",*s)!=NULL || Extended && (byte)*s<32)\n      *s='_';\n#ifdef _EMX\n    if (*s=='=')\n      *s='_';\n#endif\n#ifndef _UNIX\n    if (s-Name>1 && *s==':')\n      *s='_';\n    // Remove ' ' and '.' before path separator, but allow .\\ and ..\\.\n    if ((*s==' ' || *s=='.' && s>Name && !IsPathDiv(s[-1]) && s[-1]!='.') && IsPathDiv(s[1]))\n      *s='_';\n#endif\n  }\n}\n\n\nvoid MakeNameUsable(wchar *Name,bool Extended)\n{\n  for (wchar *s=Name;*s!=0;s++)\n  {\n    if (wcschr(Extended ? L\"?*<>|\\\"\":L\"?*\",*s)!=NULL || Extended && (uint)*s<32)\n      *s='_';\n#ifndef _UNIX\n    if (s-Name>1 && *s==':')\n      *s='_';\n#if 0  // We already can create such files.\n    // Remove ' ' and '.' before path separator, but allow .\\ and ..\\.\n    if (IsPathDiv(s[1]) && (*s==' ' || *s=='.' && s>Name &&\n        !IsPathDiv(s[-1]) && (s[-1]!='.' || s>Name+1 && !IsPathDiv(s[-2]))))\n      *s='_';\n#endif\n#endif\n  }\n}\n\n\nvoid UnixSlashToDos(const char *SrcName,char *DestName,size_t MaxLength)\n{\n  size_t Copied=0;\n  for (;Copied<MaxLength-1 && SrcName[Copied]!=0;Copied++)\n    DestName[Copied]=SrcName[Copied]=='/' ? '\\\\':SrcName[Copied];\n  DestName[Copied]=0;\n}\n\n\nvoid DosSlashToUnix(const char *SrcName,char *DestName,size_t MaxLength)\n{\n  size_t Copied=0;\n  for (;Copied<MaxLength-1 && SrcName[Copied]!=0;Copied++)\n    DestName[Copied]=SrcName[Copied]=='\\\\' ? '/':SrcName[Copied];\n  DestName[Copied]=0;\n}\n\n\nvoid UnixSlashToDos(const wchar *SrcName,wchar *DestName,size_t MaxLength)\n{\n  size_t Copied=0;\n  for (;Copied<MaxLength-1 && SrcName[Copied]!=0;Copied++)\n    DestName[Copied]=SrcName[Copied]=='/' ? '\\\\':SrcName[Copied];\n  DestName[Copied]=0;\n}\n\n\nvoid DosSlashToUnix(const wchar *SrcName,wchar *DestName,size_t MaxLength)\n{\n  size_t Copied=0;\n  for (;Copied<MaxLength-1 && SrcName[Copied]!=0;Copied++)\n    DestName[Copied]=SrcName[Copied]=='\\\\' ? '/':SrcName[Copied];\n  DestName[Copied]=0;\n}\n\n\nvoid ConvertNameToFull(const wchar *Src,wchar *Dest,size_t MaxSize)\n{\n  if (Src==NULL || *Src==0)\n  {\n    if (MaxSize>0)\n      *Dest=0;\n    return;\n  }\n#ifdef _WIN_ALL\n  {\n    wchar FullName[NM],*NamePtr;\n    DWORD Code=GetFullPathName(Src,ASIZE(FullName),FullName,&NamePtr);\n    if (Code==0 || Code>ASIZE(FullName))\n    {\n      wchar LongName[NM];\n      if (GetWinLongPath(Src,LongName,ASIZE(LongName)))\n        Code=GetFullPathName(LongName,ASIZE(FullName),FullName,&NamePtr);\n    }\n    if (Code!=0 && Code<ASIZE(FullName))\n      wcsncpyz(Dest,FullName,MaxSize);\n    else\n      if (Src!=Dest)\n        wcsncpyz(Dest,Src,MaxSize);\n  }\n#elif defined(_UNIX)\n  if (IsFullPath(Src))\n    *Dest=0;\n  else\n  {\n    char CurDirA[NM];\n    if (getcwd(CurDirA,ASIZE(CurDirA))==NULL)\n      *CurDirA=0;\n    CharToWide(CurDirA,Dest,MaxSize);\n    AddEndSlash(Dest,MaxSize);\n  }\n  wcsncatz(Dest,Src,MaxSize);\n#else\n  wcsncpyz(Dest,Src,MaxSize);\n#endif\n}\n\n\nbool IsFullPath(const wchar *Path)\n{\n/*\n  wchar PathOnly[NM];\n  GetFilePath(Path,PathOnly,ASIZE(PathOnly));\n  if (IsWildcard(PathOnly))\n    return true;\n*/\n#if defined(_WIN_ALL) || defined(_EMX)\n  return Path[0]=='\\\\' && Path[1]=='\\\\' || IsDriveLetter(Path) && IsPathDiv(Path[2]);\n#else\n  return IsPathDiv(Path[0]);\n#endif\n}\n\n\nbool IsFullRootPath(const wchar *Path)\n{\n  return IsFullPath(Path) || IsPathDiv(Path[0]);\n}\n\n\nvoid GetPathRoot(const wchar *Path,wchar *Root,size_t MaxSize)\n{\n  *Root=0;\n  if (IsDriveLetter(Path))\n    swprintf(Root,MaxSize,L\"%c:\\\\\",*Path);\n  else\n    if (Path[0]=='\\\\' && Path[1]=='\\\\')\n    {\n      const wchar *Slash=wcschr(Path+2,'\\\\');\n      if (Slash!=NULL)\n      {\n        size_t Length;\n        if ((Slash=wcschr(Slash+1,'\\\\'))!=NULL)\n          Length=Slash-Path+1;\n        else\n          Length=wcslen(Path);\n        if (Length>=MaxSize)\n          Length=0;\n        wcsncpy(Root,Path,Length);\n        Root[Length]=0;\n      }\n    }\n}\n\n\nint ParseVersionFileName(wchar *Name,bool Truncate)\n{\n  int Version=0;\n  wchar *VerText=wcsrchr(Name,';');\n  if (VerText!=NULL)\n  {\n    if (Version==0)\n      Version=atoiw(VerText+1);\n    if (Truncate)\n      *VerText=0;\n  }\n  return Version;\n}\n\n\n#if !defined(SFX_MODULE) && !defined(SETUP)\n// Get the name of first volume. Return the leftmost digit of volume number.\nwchar* VolNameToFirstName(const wchar *VolName,wchar *FirstName,size_t MaxSize,bool NewNumbering)\n{\n  if (FirstName!=VolName)\n    wcsncpyz(FirstName,VolName,MaxSize);\n  wchar *VolNumStart=FirstName;\n  if (NewNumbering)\n  {\n    wchar N='1';\n\n    // From the rightmost digit of volume number to the left.\n    for (wchar *ChPtr=GetVolNumPart(FirstName);ChPtr>FirstName;ChPtr--)\n      if (IsDigit(*ChPtr))\n      {\n        *ChPtr=N; // Set the rightmost digit to '1' and others to '0'.\n        N='0';\n      }\n      else\n        if (N=='0')\n        {\n          VolNumStart=ChPtr+1; // Store the position of leftmost digit in volume number.\n          break;\n        }\n  }\n  else\n  {\n    // Old volume numbering scheme. Just set the extension to \".rar\".\n    SetExt(FirstName,L\"rar\",MaxSize);\n    VolNumStart=GetExt(FirstName);\n  }\n  if (!FileExist(FirstName))\n  {\n    // If the first volume, which name we just generated, is not exist,\n    // check if volume with same name and any other extension is available.\n    // It can help in case of *.exe or *.sfx first volume.\n    wchar Mask[NM];\n    wcsncpyz(Mask,FirstName,ASIZE(Mask));\n    SetExt(Mask,L\"*\",ASIZE(Mask));\n    FindFile Find;\n    Find.SetMask(Mask);\n    FindData FD;\n    while (Find.Next(&FD))\n    {\n      Archive Arc;\n      if (Arc.Open(FD.Name,0) && Arc.IsArchive(true) && Arc.FirstVolume)\n      {\n        wcsncpyz(FirstName,FD.Name,MaxSize);\n        break;\n      }\n    }\n  }\n  return VolNumStart;\n}\n#endif\n\n\n#ifndef SFX_MODULE\nstatic void GenArcName(wchar *ArcName,const wchar *GenerateMask,uint ArcNumber,bool &ArcNumPresent)\n{\n  bool Prefix=false;\n  if (*GenerateMask=='+')\n  {\n    Prefix=true;    // Add the time string before the archive name.\n    GenerateMask++; // Skip '+' in the beginning of time mask.\n  }\n\n  wchar Mask[MAX_GENERATE_MASK];\n  wcsncpyz(Mask,*GenerateMask!=0 ? GenerateMask:L\"yyyymmddhhmmss\",ASIZE(Mask));\n\n  bool QuoteMode=false,Hours=false;\n  for (uint I=0;Mask[I]!=0;I++)\n  {\n    if (Mask[I]=='{' || Mask[I]=='}')\n    {\n      QuoteMode=(Mask[I]=='{');\n      continue;\n    }\n    if (QuoteMode)\n      continue;\n    int CurChar=toupperw(Mask[I]);\n    if (CurChar=='H')\n      Hours=true;\n\n    if (Hours && CurChar=='M')\n    {\n      // Replace minutes with 'I'. We use 'M' both for months and minutes,\n      // so we treat as minutes only those 'M' which are found after hours.\n      Mask[I]='I';\n    }\n    if (CurChar=='N')\n    {\n      uint Digits=GetDigits(ArcNumber);\n      uint NCount=0;\n      while (toupperw(Mask[I+NCount])=='N')\n        NCount++;\n\n      // Here we ensure that we have enough 'N' characters to fit all digits\n      // of archive number. We'll replace them by actual number later\n      // in this function.\n      if (NCount<Digits)\n      {\n        wmemmove(Mask+I+Digits,Mask+I+NCount,wcslen(Mask+I+NCount)+1);\n        wmemset(Mask+I,'N',Digits);\n      }\n      I+=Max(Digits,NCount)-1;\n      ArcNumPresent=true;\n      continue;\n    }\n  }\n\n  RarTime CurTime;\n  CurTime.SetCurrentTime();\n  RarLocalTime rlt;\n  CurTime.GetLocal(&rlt);\n\n  wchar Ext[NM],*Dot=GetExt(ArcName);\n  *Ext=0;\n  if (Dot==NULL)\n    wcscpy(Ext,*PointToName(ArcName)==0 ? L\".rar\":L\"\");\n  else\n  {\n    wcsncpyz(Ext,Dot,ASIZE(Ext));\n    *Dot=0;\n  }\n\n  int WeekDay=rlt.wDay==0 ? 6:rlt.wDay-1;\n  int StartWeekDay=rlt.yDay-WeekDay;\n  if (StartWeekDay<0)\n    if (StartWeekDay<=-4)\n      StartWeekDay+=IsLeapYear(rlt.Year-1) ? 366:365;\n    else\n      StartWeekDay=0;\n  int CurWeek=StartWeekDay/7+1;\n  if (StartWeekDay%7>=4)\n    CurWeek++;\n\n  char Field[10][6];\n\n  sprintf(Field[0],\"%04u\",rlt.Year);\n  sprintf(Field[1],\"%02u\",rlt.Month);\n  sprintf(Field[2],\"%02u\",rlt.Day);\n  sprintf(Field[3],\"%02u\",rlt.Hour);\n  sprintf(Field[4],\"%02u\",rlt.Minute);\n  sprintf(Field[5],\"%02u\",rlt.Second);\n  sprintf(Field[6],\"%02u\",(uint)CurWeek);\n  sprintf(Field[7],\"%u\",(uint)WeekDay+1);\n  sprintf(Field[8],\"%03u\",rlt.yDay+1);\n  sprintf(Field[9],\"%05u\",ArcNumber);\n\n  const wchar *MaskChars=L\"YMDHISWAEN\";\n\n  int CField[sizeof(Field)/sizeof(Field[0])];\n  memset(CField,0,sizeof(CField));\n  QuoteMode=false;\n  for (int I=0;Mask[I]!=0;I++)\n  {\n    if (Mask[I]=='{' || Mask[I]=='}')\n    {\n      QuoteMode=(Mask[I]=='{');\n      continue;\n    }\n    if (QuoteMode)\n      continue;\n    const wchar *ChPtr=wcschr(MaskChars,toupperw(Mask[I]));\n    if (ChPtr!=NULL)\n      CField[ChPtr-MaskChars]++;\n   }\n\n  wchar DateText[MAX_GENERATE_MASK];\n  *DateText=0;\n  QuoteMode=false;\n  for (size_t I=0,J=0;Mask[I]!=0 && J<ASIZE(DateText)-1;I++)\n  {\n    if (Mask[I]=='{' || Mask[I]=='}')\n    {\n      QuoteMode=(Mask[I]=='{');\n      continue;\n    }\n    const wchar *ChPtr=wcschr(MaskChars,toupperw(Mask[I]));\n    if (ChPtr==NULL || QuoteMode)\n    {\n      DateText[J]=Mask[I];\n#ifdef _WIN_ALL\n      // We do not allow ':' in Windows because of NTFS streams.\n      // Users had problems after specifying hh:mm mask.\n      if (DateText[J]==':')\n        DateText[J]='_';\n#endif\n    }\n    else\n    {\n      size_t FieldPos=ChPtr-MaskChars;\n      int CharPos=(int)strlen(Field[FieldPos])-CField[FieldPos]--;\n      if (FieldPos==1 && toupperw(Mask[I+1])=='M' && toupperw(Mask[I+2])=='M')\n      {\n        wcsncpyz(DateText+J,GetMonthName(rlt.Month-1),ASIZE(DateText)-J);\n        J=wcslen(DateText);\n        I+=2;\n        continue;\n      }\n      if (CharPos<0)\n        DateText[J]=Mask[I];\n      else\n        DateText[J]=Field[FieldPos][CharPos];\n    }\n    DateText[++J]=0;\n  }\n\n  if (Prefix)\n  {\n    wchar NewName[NM];\n    GetFilePath(ArcName,NewName,ASIZE(NewName));\n    AddEndSlash(NewName,ASIZE(NewName));\n    wcsncatz(NewName,DateText,ASIZE(NewName));\n    wcsncatz(NewName,PointToName(ArcName),ASIZE(NewName));\n    wcscpy(ArcName,NewName);\n  }\n  else\n    wcscat(ArcName,DateText);\n  wcscat(ArcName,Ext);\n}\n\n\nvoid GenerateArchiveName(wchar *ArcName,size_t MaxSize,const wchar *GenerateMask,bool Archiving)\n{\n  // Must be enough space for archive name plus all stuff in mask plus\n  // extra overhead produced by mask 'N' (archive number) characters.\n  // One 'N' character can result in several numbers if we process more\n  // than 9 archives.\n  wchar NewName[NM+MAX_GENERATE_MASK+20];\n\n  uint ArcNumber=1;\n  while (true) // Loop for 'N' (archive number) processing.\n  {\n    wcsncpyz(NewName,ArcName,ASIZE(NewName));\n    \n    bool ArcNumPresent=false;\n\n    GenArcName(NewName,GenerateMask,ArcNumber,ArcNumPresent);\n    \n    if (!ArcNumPresent)\n      break;\n    if (!FileExist(NewName))\n    {\n      if (!Archiving && ArcNumber>1)\n      {\n        // If we perform non-archiving operation, we need to use the last\n        // existing archive before the first unused name. So we generate\n        // the name for (ArcNumber-1) below.\n        wcsncpyz(NewName,NullToEmpty(ArcName),ASIZE(NewName));\n        GenArcName(NewName,GenerateMask,ArcNumber-1,ArcNumPresent);\n      }\n      break;\n    }\n    ArcNumber++;\n  }\n  wcsncpyz(ArcName,NewName,MaxSize);\n}\n#endif\n\n\nwchar* GetWideName(const char *Name,const wchar *NameW,wchar *DestW,size_t DestSize)\n{\n  if (NameW!=NULL && *NameW!=0)\n  {\n    if (DestW!=NameW)\n      wcsncpy(DestW,NameW,DestSize);\n  }\n  else\n    if (Name!=NULL)\n      CharToWide(Name,DestW,DestSize);\n    else\n      *DestW=0;\n\n  // Ensure that we return a zero terminate string for security reasons.\n  if (DestSize>0)\n    DestW[DestSize-1]=0;\n\n  return DestW;\n}\n\n\n#ifdef _WIN_ALL\n// We should return 'true' even if resulting path is shorter than MAX_PATH,\n// because we can also use this function to open files with non-standard\n// characters, even if their path length is normal.\nbool GetWinLongPath(const wchar *Src,wchar *Dest,size_t MaxSize)\n{\n  if (*Src==0)\n    return false;\n  const wchar *Prefix=L\"\\\\\\\\?\\\\\";\n  const size_t PrefixLength=4;\n  bool FullPath=IsDriveLetter(Src) && IsPathDiv(Src[2]);\n  size_t SrcLength=wcslen(Src);\n  if (IsFullPath(Src)) // Paths in d:\\path\\name format.\n  {\n    if (IsDriveLetter(Src))\n    {\n      if (MaxSize<=PrefixLength+SrcLength)\n        return false;\n      wcsncpy(Dest,Prefix,PrefixLength);\n      wcscpy(Dest+PrefixLength,Src);\n      return true;\n    }\n    else\n      if (Src[0]=='\\\\' && Src[1]=='\\\\')\n      {\n        if (MaxSize<=PrefixLength+SrcLength+2)\n          return false;\n        wcsncpy(Dest,Prefix,PrefixLength);\n        wcscpy(Dest+PrefixLength,L\"UNC\");\n        wcscpy(Dest+PrefixLength+3,Src+1);\n        return true;\n      }\n    // We may be here only if we modify IsFullPath in the future.\n    return false;\n  }\n  else\n  {\n    wchar CurDir[NM];\n    DWORD DirCode=GetCurrentDirectory(ASIZE(CurDir)-1,CurDir);\n    if (DirCode==0 || DirCode>ASIZE(CurDir)-1)\n      return false;\n\n    if (IsPathDiv(Src[0])) // Paths in \\path\\name format.\n    {\n      if (MaxSize<=PrefixLength+SrcLength+2)\n        return false;\n      wcsncpy(Dest,Prefix,PrefixLength);\n      wcsncpy(Dest+PrefixLength,CurDir,2); // Copy drive letter 'd:'.\n      wcscpy(Dest+PrefixLength+2,Src);\n      return true;\n    }\n    else  // Paths in path\\name format.\n    {\n      AddEndSlash(CurDir,ASIZE(CurDir));\n      if (MaxSize<=PrefixLength+wcslen(CurDir)+SrcLength)\n        return false;\n      wcsncpy(Dest,Prefix,PrefixLength);\n      wcscpy(Dest+PrefixLength,CurDir);\n\n      if (Src[0]=='.' && IsPathDiv(Src[1])) // Remove leading .\\ in pathname.\n        Src+=2;\n\n      wcsncatz(Dest,Src,MaxSize);\n      return true;\n    }\n  }\n  return false;\n}\n\n\n// Convert Unix, OS X and Android decomposed chracters to Windows precomposed.\nvoid ConvertToPrecomposed(wchar *Name,size_t NameSize)\n{\n  wchar FileName[NM];\n  if (WinNT()>=WNT_VISTA && // MAP_PRECOMPOSED is not supported in XP.\n      FoldString(MAP_PRECOMPOSED,Name,-1,FileName,ASIZE(FileName))!=0)\n  {\n    FileName[ASIZE(FileName)-1]=0;\n    wcsncpyz(Name,FileName,NameSize);\n  }\n}\n\n\n// Remove trailing spaces and dots in file name and in dir names in path.\nvoid MakeNameCompatible(wchar *Name)\n{\n  int Src=0,Dest=0;\n  while (true)\n  {\n    if (IsPathDiv(Name[Src]) || Name[Src]==0)\n      for (int I=Dest-1;I>0 && (Name[I]==' ' || Name[I]=='.');I--)\n      {\n        if (IsPathDiv(Name[I-1])) // Permit path1/./path2 paths.\n          break;\n        Dest--;\n      }\n    Name[Dest]=Name[Src];\n    if (Name[Src]==0)\n      break;\n    Src++;\n    Dest++;\n  }\n}\n#endif\n","// -*- C++ -*-\n//===--------------------------- wchar.h ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#if defined(__need_wint_t) || defined(__need_mbstate_t)\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#include_next <wchar.h>\n\n#elif !defined(_LIBCPP_WCHAR_H)\n#define _LIBCPP_WCHAR_H\n\n/*\n    wchar.h synopsis\n\nMacros:\n\n    NULL\n    WCHAR_MAX\n    WCHAR_MIN\n    WEOF\n\nTypes:\n\n    mbstate_t\n    size_t\n    tm\n    wint_t\n\nint fwprintf(FILE* restrict stream, const wchar_t* restrict format, ...);\nint fwscanf(FILE* restrict stream, const wchar_t* restrict format, ...);\nint swprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, ...);\nint swscanf(const wchar_t* restrict s, const wchar_t* restrict format, ...);\nint vfwprintf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);\nint vfwscanf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);  // C99\nint vswprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, va_list arg);\nint vswscanf(const wchar_t* restrict s, const wchar_t* restrict format, va_list arg);  // C99\nint vwprintf(const wchar_t* restrict format, va_list arg);\nint vwscanf(const wchar_t* restrict format, va_list arg);  // C99\nint wprintf(const wchar_t* restrict format, ...);\nint wscanf(const wchar_t* restrict format, ...);\nwint_t fgetwc(FILE* stream);\nwchar_t* fgetws(wchar_t* restrict s, int n, FILE* restrict stream);\nwint_t fputwc(wchar_t c, FILE* stream);\nint fputws(const wchar_t* restrict s, FILE* restrict stream);\nint fwide(FILE* stream, int mode);\nwint_t getwc(FILE* stream);\nwint_t getwchar();\nwint_t putwc(wchar_t c, FILE* stream);\nwint_t putwchar(wchar_t c);\nwint_t ungetwc(wint_t c, FILE* stream);\ndouble wcstod(const wchar_t* restrict nptr, wchar_t** restrict endptr);\nfloat wcstof(const wchar_t* restrict nptr, wchar_t** restrict endptr);         // C99\nlong double wcstold(const wchar_t* restrict nptr, wchar_t** restrict endptr);  // C99\nlong wcstol(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);\nlong long wcstoll(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);  // C99\nunsigned long wcstoul(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);\nunsigned long long wcstoull(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);  // C99\nwchar_t* wcscpy(wchar_t* restrict s1, const wchar_t* restrict s2);\nwchar_t* wcsncpy(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);\nwchar_t* wcscat(wchar_t* restrict s1, const wchar_t* restrict s2);\nwchar_t* wcsncat(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);\nint wcscmp(const wchar_t* s1, const wchar_t* s2);\nint wcscoll(const wchar_t* s1, const wchar_t* s2);\nint wcsncmp(const wchar_t* s1, const wchar_t* s2, size_t n);\nsize_t wcsxfrm(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);\nconst wchar_t* wcschr(const wchar_t* s, wchar_t c);\n      wchar_t* wcschr(      wchar_t* s, wchar_t c);\nsize_t wcscspn(const wchar_t* s1, const wchar_t* s2);\nsize_t wcslen(const wchar_t* s);\nconst wchar_t* wcspbrk(const wchar_t* s1, const wchar_t* s2);\n      wchar_t* wcspbrk(      wchar_t* s1, const wchar_t* s2);\nconst wchar_t* wcsrchr(const wchar_t* s, wchar_t c);\n      wchar_t* wcsrchr(      wchar_t* s, wchar_t c);\nsize_t wcsspn(const wchar_t* s1, const wchar_t* s2);\nconst wchar_t* wcsstr(const wchar_t* s1, const wchar_t* s2);\n      wchar_t* wcsstr(      wchar_t* s1, const wchar_t* s2);\nwchar_t* wcstok(wchar_t* restrict s1, const wchar_t* restrict s2, wchar_t** restrict ptr);\nconst wchar_t* wmemchr(const wchar_t* s, wchar_t c, size_t n);\n      wchar_t* wmemchr(      wchar_t* s, wchar_t c, size_t n);\nint wmemcmp(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);\nwchar_t* wmemcpy(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);\nwchar_t* wmemmove(wchar_t* s1, const wchar_t* s2, size_t n);\nwchar_t* wmemset(wchar_t* s, wchar_t c, size_t n);\nsize_t wcsftime(wchar_t* restrict s, size_t maxsize, const wchar_t* restrict format,\n                const tm* restrict timeptr);\nwint_t btowc(int c);\nint wctob(wint_t c);\nint mbsinit(const mbstate_t* ps);\nsize_t mbrlen(const char* restrict s, size_t n, mbstate_t* restrict ps);\nsize_t mbrtowc(wchar_t* restrict pwc, const char* restrict s, size_t n, mbstate_t* restrict ps);\nsize_t wcrtomb(char* restrict s, wchar_t wc, mbstate_t* restrict ps);\nsize_t mbsrtowcs(wchar_t* restrict dst, const char** restrict src, size_t len,\n                 mbstate_t* restrict ps);\nsize_t wcsrtombs(char* restrict dst, const wchar_t** restrict src, size_t len,\n                 mbstate_t* restrict ps);\n\n*/\n\n#include <__config>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#ifdef __cplusplus\n#define __CORRECT_ISO_CPP_WCHAR_H_PROTO\n#endif\n\n#include_next <wchar.h>\n\n// Determine whether we have const-correct overloads for wcschr and friends.\n#if defined(_WCHAR_H_CPLUSPLUS_98_CONFORMANCE_)\n#  define _LIBCPP_WCHAR_H_HAS_CONST_OVERLOADS 1\n#elif defined(__GLIBC_PREREQ)\n#  if __GLIBC_PREREQ(2, 10)\n#    define _LIBCPP_WCHAR_H_HAS_CONST_OVERLOADS 1\n#  endif\n#endif\n\n#if defined(__cplusplus) && !defined(_LIBCPP_WCHAR_H_HAS_CONST_OVERLOADS) && defined(_LIBCPP_PREFERRED_OVERLOAD)\nextern \"C++\" {\ninline _LIBCPP_INLINE_VISIBILITY\nwchar_t* __libcpp_wcschr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcschr(__s, __c);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst wchar_t* wcschr(const wchar_t* __s, wchar_t __c) {return __libcpp_wcschr(__s, __c);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      wchar_t* wcschr(      wchar_t* __s, wchar_t __c) {return __libcpp_wcschr(__s, __c);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nwchar_t* __libcpp_wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcspbrk(__s1, __s2);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst wchar_t* wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcspbrk(__s1, __s2);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      wchar_t* wcspbrk(      wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcspbrk(__s1, __s2);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nwchar_t* __libcpp_wcsrchr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcsrchr(__s, __c);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst wchar_t* wcsrchr(const wchar_t* __s, wchar_t __c) {return __libcpp_wcsrchr(__s, __c);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      wchar_t* wcsrchr(      wchar_t* __s, wchar_t __c) {return __libcpp_wcsrchr(__s, __c);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nwchar_t* __libcpp_wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcsstr(__s1, __s2);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst wchar_t* wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcsstr(__s1, __s2);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      wchar_t* wcsstr(      wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcsstr(__s1, __s2);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nwchar_t* __libcpp_wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return (wchar_t*)wmemchr(__s, __c, __n);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst wchar_t* wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return __libcpp_wmemchr(__s, __c, __n);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      wchar_t* wmemchr(      wchar_t* __s, wchar_t __c, size_t __n) {return __libcpp_wmemchr(__s, __c, __n);}\n}\n#endif\n\n#if defined(__cplusplus) && (defined(_LIBCPP_MSVCRT) || defined(__MINGW32__))\nextern \"C++\" {\n#include <support/win32/support.h> // pull in *swprintf defines\n}  // extern \"C++\"\n#endif  // __cplusplus && _LIBCPP_MSVCRT\n\n#endif  // _LIBCPP_WCHAR_H\n","#ifndef _RAR_FINDDATA_\n#define _RAR_FINDDATA_\n\nenum FINDDATA_FLAGS {\n  FDDF_SECONDDIR=1  // Second encounter of same directory in SCAN_GETDIRSTWICE ScanTree mode.\n};\n\nstruct FindData\n{\n  wchar Name[NM];\n  uint64 Size;\n  uint FileAttr;\n  bool IsDir;\n  bool IsLink;\n  RarTime mtime;\n  RarTime ctime;\n  RarTime atime;\n#ifdef _WIN_ALL\n  FILETIME ftCreationTime; \n  FILETIME ftLastAccessTime; \n  FILETIME ftLastWriteTime; \n#endif\n  uint Flags;\n  bool Error;\n};\n\nclass FindFile\n{\n  private:\n#ifdef _WIN_ALL\n    static HANDLE Win32Find(HANDLE hFind,const wchar *Mask,FindData *fd);\n#endif\n\n    wchar FindMask[NM];\n    bool FirstCall;\n#ifdef _WIN_ALL\n    HANDLE hFind;\n#else\n    DIR *dirp;\n#endif\n  public:\n    FindFile();\n    ~FindFile();\n    void SetMask(const wchar *Mask);\n    bool Next(FindData *fd,bool GetSymLink=false);\n    static bool FastFind(const wchar *FindMask,FindData *fd,bool GetSymLink=false);\n};\n\n#endif\n","#ifndef _RAR_TIMEFN_\n#define _RAR_TIMEFN_\n\nstruct RarLocalTime\n{\n  uint Year;\n  uint Month;\n  uint Day;\n  uint Hour;\n  uint Minute;\n  uint Second;\n  uint Reminder; // Part of time smaller than 1 second, represented in 100-nanosecond intervals.\n  uint wDay;\n  uint yDay;\n};\n\n\nclass RarTime\n{\n  public:\n    static const uint TICKS_PER_SECOND = 10000000; // Raw time items per second.\n  private:\n    // Internal FILETIME like time representation in 100 nanoseconds\n    // since 01.01.1601.\n    uint64 itime;\n  public:\n    RarTime() {Reset();}\n#ifdef _WIN_ALL\n    RarTime(FILETIME &ft) {*this=ft;}\n    RarTime& operator =(FILETIME &ft);\n    void GetWin32(FILETIME *ft);\n#endif\n    RarTime(time_t ut) {*this=ut;}\n    RarTime& operator =(time_t ut);\n    time_t GetUnix();\n    bool operator == (RarTime &rt) {return itime==rt.itime;}\n    bool operator != (RarTime &rt) {return itime!=rt.itime;}\n    bool operator < (RarTime &rt)  {return itime<rt.itime;}\n    bool operator <= (RarTime &rt) {return itime<rt.itime || itime==rt.itime;}\n    bool operator > (RarTime &rt)  {return itime>rt.itime;}\n    bool operator >= (RarTime &rt) {return itime>rt.itime || itime==rt.itime;}\n    void GetLocal(RarLocalTime *lt);\n    void SetLocal(RarLocalTime *lt);\n    void SetUTC(RarLocalTime *lt);\n    uint64 GetRaw();\n    void SetRaw(uint64 RawTime);\n    uint GetDos();\n    void SetDos(uint DosTime);\n    void GetText(wchar *DateStr,size_t MaxSize,bool FullMS);\n    void SetIsoText(const wchar *TimeText);\n    void SetAgeText(const wchar *TimeText);\n    void SetCurrentTime();\n    void Reset() {itime=0;}\n    bool IsSet() {return itime!=0;}\n};\n\nconst wchar *GetMonthName(int Month);\nbool IsLeapYear(int Year);\n\n#endif\n","#include \"rar.hpp\"\n\nint ToPercent(int64 N1,int64 N2)\n{\n  if (N2<N1)\n    return 100;\n  return ToPercentUnlim(N1,N2);\n}\n\n\n// Allows the percent larger than 100.\nint ToPercentUnlim(int64 N1,int64 N2)\n{\n  if (N2==0)\n    return 0;\n  return (int)(N1*100/N2);\n}\n\n\n","#include \"rar.hpp\"\n\n// If NewFile==NULL, we delete created file after user confirmation.\n// It is useful we we need to overwrite an existing folder or file,\n// but need user confirmation for that.\nbool FileCreate(RAROptions *Cmd,File *NewFile,wchar *Name,size_t MaxNameSize,\n                bool *UserReject,int64 FileSize,RarTime *FileTime,bool WriteOnly)\n{\n  if (UserReject!=NULL)\n    *UserReject=false;\n#ifdef _WIN_ALL\n  bool ShortNameChanged=false;\n#endif\n  while (FileExist(Name))\n  {\n#ifdef _WIN_ALL\n    if (!ShortNameChanged)\n    {\n      // Avoid the infinite loop if UpdateExistingShortName returns\n      // the same name.\n      ShortNameChanged=true;\n\n      // Maybe our long name matches the short name of existing file.\n      // Let's check if we can change the short name.\n      if (UpdateExistingShortName(Name))\n        continue;\n    }\n    // Allow short name check again. It is necessary, because rename and\n    // autorename below can change the name, so we need to check it again.\n    ShortNameChanged=false;\n#endif\n    UIASKREP_RESULT Choice=uiAskReplaceEx(Cmd,Name,MaxNameSize,FileSize,FileTime,(NewFile==NULL ? UIASKREP_F_NORENAME:0));\n\n    if (Choice==UIASKREP_R_REPLACE)\n      break;\n    if (Choice==UIASKREP_R_SKIP)\n    {\n      if (UserReject!=NULL)\n        *UserReject=true;\n      return false;\n    }\n    if (Choice==UIASKREP_R_CANCEL)\n      ErrHandler.Exit(RARX_USERBREAK);\n  }\n\n  // Try to truncate the existing file first instead of delete,\n  // so we preserve existing file permissions such as NTFS permissions.\n  uint FileMode=WriteOnly ? FMF_WRITE|FMF_SHAREREAD:FMF_UPDATE|FMF_SHAREREAD;\n  if (NewFile!=NULL && NewFile->Create(Name,FileMode))\n    return true;\n\n  CreatePath(Name,true);\n  return NewFile!=NULL ? NewFile->Create(Name,FileMode):DelFile(Name);\n}\n\n\nbool GetAutoRenamedName(wchar *Name,size_t MaxNameSize)\n{\n  wchar NewName[NM];\n  size_t NameLength=wcslen(Name);\n#ifdef _ANDROID\n  if (NameLength>ASIZE(NewName)-10)\n    return false;\n#endif\n  wchar *Ext=GetExt(Name);\n  if (Ext==NULL)\n    Ext=Name+NameLength;\n  for (uint FileVer=1;;FileVer++)\n  {\n#ifdef _ANDROID // No swprintf in Android prior to Android 5.0.\n    uint NamePrefixLength=Ext-Name;\n    wcsncpy(NewName,Name,NamePrefixLength);\n    wcscpy(NewName+NamePrefixLength,L\"(\");\n    itoa(FileVer,NewName+NamePrefixLength+1,ASIZE(NewName)-NamePrefixLength-1);\n    wcsncatz(NewName,L\")\",ASIZE(NewName));\n    wcsncatz(NewName,Ext,ASIZE(NewName));\n#else\n    swprintf(NewName,ASIZE(NewName),L\"%.*ls(%u)%ls\",uint(Ext-Name),Name,FileVer,Ext);\n#endif\n    if (!FileExist(NewName))\n    {\n      wcsncpyz(Name,NewName,MaxNameSize);\n      break;\n    }\n    if (FileVer>=1000000)\n      return false;\n  }\n  return true;\n}\n\n\n#ifdef _WIN_ALL\n// If we find a file, which short name is equal to 'Name', we try to change\n// its short name, while preserving the long name. It helps when unpacking\n// an archived file, which long name is equal to short name of already\n// existing file. Otherwise we would overwrite the already existing file,\n// even though its long name does not match the name of unpacking file.\nbool UpdateExistingShortName(const wchar *Name)\n{\n  wchar LongPathName[NM];\n  DWORD Res=GetLongPathName(Name,LongPathName,ASIZE(LongPathName));\n  if (Res==0 || Res>=ASIZE(LongPathName))\n    return false;\n  wchar ShortPathName[NM];\n  Res=GetShortPathName(Name,ShortPathName,ASIZE(ShortPathName));\n  if (Res==0 || Res>=ASIZE(ShortPathName))\n    return false;\n  wchar *LongName=PointToName(LongPathName);\n  wchar *ShortName=PointToName(ShortPathName);\n\n  // We continue only if file has a short name, which does not match its\n  // long name, and this short name is equal to name of file which we need\n  // to create.\n  if (*ShortName==0 || wcsicomp(LongName,ShortName)==0 ||\n      wcsicomp(PointToName(Name),ShortName)!=0)\n    return false;\n\n  // Generate the temporary new name for existing file.\n  wchar NewName[NM];\n  *NewName=0;\n  for (int I=0;I<10000 && *NewName==0;I+=123)\n  {\n    // Here we copy the path part of file to create. We'll make the temporary\n    // file in the same folder.\n    wcsncpyz(NewName,Name,ASIZE(NewName));\n\n    // Here we set the random name part.\n    swprintf(PointToName(NewName),ASIZE(NewName),L\"rtmp%d\",I);\n    \n    // If such file is already exist, try next random name.\n    if (FileExist(NewName))\n      *NewName=0;\n  }\n\n  // If we could not generate the name not used by any other file, we return.\n  if (*NewName==0)\n    return false;\n  \n  // FastFind returns the name without path, but we need the fully qualified\n  // name for renaming, so we use the path from file to create and long name\n  // from existing file.\n  wchar FullName[NM];\n  wcsncpyz(FullName,Name,ASIZE(FullName));\n  SetName(FullName,LongName,ASIZE(FullName));\n  \n  // Rename the existing file to randomly generated name. Normally it changes\n  // the short name too.\n  if (!MoveFile(FullName,NewName))\n    return false;\n\n  // Now we need to create the temporary empty file with same name as\n  // short name of our already existing file. We do it to occupy its previous\n  // short name and not allow to use it again when renaming the file back to\n  // its original long name.\n  File KeepShortFile;\n  bool Created=false;\n  if (!FileExist(Name))\n    Created=KeepShortFile.Create(Name,FMF_WRITE|FMF_SHAREREAD);\n\n  // Now we rename the existing file from temporary name to original long name.\n  // Since its previous short name is occupied by another file, it should\n  // get another short name.\n  MoveFile(NewName,FullName);\n\n  if (Created)\n  {\n    // Delete the temporary zero length file occupying the short name,\n    KeepShortFile.Close();\n    KeepShortFile.Delete();\n  }\n  // We successfully changed the short name. Maybe sometimes we'll simplify\n  // this function by use of SetFileShortName Windows API call.\n  // But SetFileShortName is not available in older Windows.\n  return true;\n}\n#endif\n","#include \"rar.hpp\"\n\n#ifndef SHELL_EXT\n#include \"arccmt.cpp\"\n#endif\n\n\nArchive::Archive(RAROptions *InitCmd)\n{\n  Cmd=NULL; // Just in case we'll have an exception in 'new' below.\n\n  DummyCmd=(InitCmd==NULL);\n  Cmd=DummyCmd ? (new RAROptions):InitCmd;\n\n  OpenShared=Cmd->OpenShared;\n  Format=RARFMT15;\n  Solid=false;\n  Volume=false;\n  MainComment=false;\n  Locked=false;\n  Signed=false;\n  FirstVolume=false;\n  NewNumbering=false;\n  SFXSize=0;\n  LatestTime.Reset();\n  Protected=false;\n  Encrypted=false;\n  FailedHeaderDecryption=false;\n  BrokenHeader=false;\n  LastReadBlock=0;\n\n  CurBlockPos=0;\n  NextBlockPos=0;\n\n  RecoverySize=-1;\n  RecoveryPercent=-1;\n\n  memset(&MainHead,0,sizeof(MainHead));\n  memset(&CryptHead,0,sizeof(CryptHead));\n  memset(&EndArcHead,0,sizeof(EndArcHead));\n\n  VolNumber=0;\n  VolWrite=0;\n  AddingFilesSize=0;\n  AddingHeadersSize=0;\n  *FirstVolumeName=0;\n\n  Splitting=false;\n  NewArchive=false;\n\n  SilentOpen=false;\n\n}\n\n\nArchive::~Archive()\n{\n  if (DummyCmd)\n    delete Cmd;\n}\n\n\n#ifndef SHELL_EXT\nvoid Archive::CheckArc(bool EnableBroken)\n{\n  if (!IsArchive(EnableBroken))\n  {\n    // If FailedHeaderDecryption is set, we already reported that archive\n    // password is incorrect.\n    if (!FailedHeaderDecryption)\n      uiMsg(UIERROR_BADARCHIVE,FileName);\n    ErrHandler.Exit(RARX_FATAL);\n  }\n}\n#endif\n\n\n#if !defined(SHELL_EXT) && !defined(SFX_MODULE)\nvoid Archive::CheckOpen(const wchar *Name)\n{\n  TOpen(Name);\n  CheckArc(false);\n}\n#endif\n\n\nbool Archive::WCheckOpen(const wchar *Name)\n{\n  if (!WOpen(Name))\n    return false;\n  if (!IsArchive(false))\n  {\n    uiMsg(UIERROR_BADARCHIVE,FileName);\n    Close();\n    return false;\n  }\n  return true;\n}\n\n\nRARFORMAT Archive::IsSignature(const byte *D,size_t Size)\n{\n  RARFORMAT Type=RARFMT_NONE;\n  if (Size>=1 && D[0]==0x52)\n#ifndef SFX_MODULE\n    if (Size>=4 && D[1]==0x45 && D[2]==0x7e && D[3]==0x5e)\n      Type=RARFMT14;\n    else\n#endif\n      if (Size>=7 && D[1]==0x61 && D[2]==0x72 && D[3]==0x21 && D[4]==0x1a && D[5]==0x07)\n      {\n        // We check the last signature byte, so we can return a sensible\n        // warning in case we'll want to change the archive format\n        // sometimes in the future.\n        if (D[6]==0)\n          Type=RARFMT15;\n        else\n          if (D[6]==1)\n            Type=RARFMT50;\n          else\n            if (D[6]==2)\n              Type=RARFMT_FUTURE;\n      }\n  return Type;\n}\n\n\nbool Archive::IsArchive(bool EnableBroken)\n{\n  Encrypted=false;\n  BrokenHeader=false; // Might be left from previous volume.\n  \n#ifndef SFX_MODULE\n  if (IsDevice())\n  {\n    uiMsg(UIERROR_INVALIDNAME,FileName,FileName);\n    return false;\n  }\n#endif\n  if (Read(MarkHead.Mark,SIZEOF_MARKHEAD3)!=SIZEOF_MARKHEAD3)\n    return false;\n  SFXSize=0;\n  \n  RARFORMAT Type;\n  if ((Type=IsSignature(MarkHead.Mark,SIZEOF_MARKHEAD3))!=RARFMT_NONE)\n  {\n    Format=Type;\n    if (Format==RARFMT14)\n      Seek(Tell()-SIZEOF_MARKHEAD3,SEEK_SET);\n  }\n  else\n  {\n    Array<char> Buffer(MAXSFXSIZE);\n    long CurPos=(long)Tell();\n    int ReadSize=Read(&Buffer[0],Buffer.Size()-16);\n    for (int I=0;I<ReadSize;I++)\n      if (Buffer[I]==0x52 && (Type=IsSignature((byte *)&Buffer[I],ReadSize-I))!=RARFMT_NONE)\n      {\n        Format=Type;\n        if (Format==RARFMT14 && I>0 && CurPos<28 && ReadSize>31)\n        {\n          char *D=&Buffer[28-CurPos];\n          if (D[0]!=0x52 || D[1]!=0x53 || D[2]!=0x46 || D[3]!=0x58)\n            continue;\n        }\n        SFXSize=CurPos+I;\n        Seek(SFXSize,SEEK_SET);\n        if (Format==RARFMT15 || Format==RARFMT50)\n          Read(MarkHead.Mark,SIZEOF_MARKHEAD3);\n        break;\n      }\n    if (SFXSize==0)\n      return false;\n  }\n  if (Format==RARFMT_FUTURE)\n  {\n    uiMsg(UIERROR_NEWRARFORMAT,FileName);\n    return false;\n  }\n  if (Format==RARFMT50) // RAR 5.0 signature is by one byte longer.\n  {\n    Read(MarkHead.Mark+SIZEOF_MARKHEAD3,1);\n    if (MarkHead.Mark[SIZEOF_MARKHEAD3]!=0)\n      return false;\n    MarkHead.HeadSize=SIZEOF_MARKHEAD5;\n  }\n  else\n    MarkHead.HeadSize=SIZEOF_MARKHEAD3;\n\n#ifdef RARDLL\n  // If callback function is not set, we cannot get the password,\n  // so we skip the initial header processing for encrypted header archive.\n  // It leads to skipped archive comment, but the rest of archive data\n  // is processed correctly.\n  if (Cmd->Callback==NULL)\n    SilentOpen=true;\n#endif\n\n  // Skip the archive encryption header if any and read the main header.\n  while (ReadHeader()!=0)\n  {\n    HEADER_TYPE Type=GetHeaderType();\n    // In RAR 5.0 we need to quit after reading HEAD_CRYPT if we wish to\n    // avoid the password prompt.\n    if (Type==HEAD_MAIN || SilentOpen && Type==HEAD_CRYPT)\n      break;\n    SeekToNext();\n  }\n\n  // This check allows to make RS based recovery even if password is incorrect.\n  // But we should not do it for EnableBroken or we'll get 'not RAR archive'\n  // messages when extracting encrypted archives with wrong password.\n  if (FailedHeaderDecryption && !EnableBroken)\n    return false;\n\n  SeekToNext();\n  if (BrokenHeader) // Main archive header is corrupt.\n  {\n    uiMsg(UIERROR_MHEADERBROKEN,FileName);\n    if (!EnableBroken)\n      return false;\n  }\n\n  MainComment=MainHead.CommentInHeader;\n\n  // If we process non-encrypted archive or can request a password,\n  // we set 'first volume' flag based on file attributes below.\n  // It is necessary for RAR 2.x archives, which did not have 'first volume'\n  // flag in main header. Also for all RAR formats we need to scan until\n  // first file header to set \"comment\" flag when reading service header.\n  // Unless we are in silent mode, we need to know about presence of comment\n  // immediately after IsArchive call.\n  if (!SilentOpen || !Encrypted)\n  {\n    SaveFilePos SavePos(*this);\n    int64 SaveCurBlockPos=CurBlockPos,SaveNextBlockPos=NextBlockPos;\n    HEADER_TYPE SaveCurHeaderType=CurHeaderType;\n\n    while (ReadHeader()!=0)\n    {\n      HEADER_TYPE HeaderType=GetHeaderType();\n      if (HeaderType==HEAD_SERVICE)\n      {\n        // If we have a split service headers, it surely indicates non-first\n        // volume. But not split service header does not guarantee the first\n        // volume, because we can have split file after non-split archive\n        // comment. So we do not quit from loop here.\n        FirstVolume=Volume && !SubHead.SplitBefore;\n      }\n      else\n        if (HeaderType==HEAD_FILE)\n        {\n          FirstVolume=Volume && !FileHead.SplitBefore;\n          break;\n        }\n        else\n          if (HeaderType==HEAD_ENDARC) // Might happen if archive contains only a split service header.\n            break;\n      SeekToNext();\n    }\n    CurBlockPos=SaveCurBlockPos;\n    NextBlockPos=SaveNextBlockPos;\n    CurHeaderType=SaveCurHeaderType;\n  }\n  if (!Volume || FirstVolume)\n    wcscpy(FirstVolumeName,FileName);\n\n  return true;\n}\n\n\n\n\nvoid Archive::SeekToNext()\n{\n  Seek(NextBlockPos,SEEK_SET);\n}\n\n\n\n\n\n\n// Calculate the block size including encryption fields and padding if any.\nuint Archive::FullHeaderSize(size_t Size)\n{\n  if (Encrypted)\n  {\n    Size = ALIGN_VALUE(Size, CRYPT_BLOCK_SIZE); // Align to encryption block size.\n    if (Format == RARFMT50)\n      Size += SIZE_INITV;\n    else\n      Size += SIZE_SALT30;\n  }\n  return uint(Size);\n}\n\n\n\n\n#ifdef USE_QOPEN\nbool Archive::Open(const wchar *Name,uint Mode)\n{\n  // Important if we reuse Archive object and it has virtual QOpen\n  // file position not matching real. For example, for 'l -v volname'.\n  QOpen.Unload();\n\n  return File::Open(Name,Mode);\n}\n\n\nint Archive::Read(void *Data,size_t Size)\n{\n  size_t Result;\n  if (QOpen.Read(Data,Size,Result))\n    return (int)Result;\n  return File::Read(Data,Size);\n}\n\n\nvoid Archive::Seek(int64 Offset,int Method)\n{\n  if (!QOpen.Seek(Offset,Method))\n    File::Seek(Offset,Method);\n}\n\n\nint64 Archive::Tell()\n{\n  int64 QPos;\n  if (QOpen.Tell(&QPos))\n    return QPos;\n  return File::Tell();\n}\n#endif\n\n","#ifndef _RAR_QOPEN_\n#define _RAR_QOPEN_\n\nstruct QuickOpenItem\n{\n  byte *Header;\n  size_t HeaderSize;\n  uint64 ArcPos;\n  QuickOpenItem *Next;\n};\n\n\nclass Archive;\nclass RawRead;\n\nclass QuickOpen\n{\n  private:\n    void Close();\n\n\n    uint ReadBuffer();\n    bool ReadRaw(RawRead &Raw);\n    bool ReadNext();\n\n    Archive *Arc;\n    bool WriteMode;\n\n    QuickOpenItem *ListStart;\n    QuickOpenItem *ListEnd;\n    \n    byte *Buf;\n    static const size_t MaxBufSize=0x10000; // Must be multiple of CRYPT_BLOCK_SIZE.\n    size_t CurBufSize;\n#ifndef RAR_NOCRYPT // For shell extension.\n    CryptData Crypt;\n#endif\n\n    bool Loaded;\n    uint64 QLHeaderPos;\n    uint64 RawDataStart;\n    uint64 RawDataSize;\n    uint64 RawDataPos;\n    size_t ReadBufSize;\n    size_t ReadBufPos;\n    Array<byte> LastReadHeader;\n    uint64 LastReadHeaderPos;\n    uint64 SeekPos;\n    bool UnsyncSeekPos; // QOpen SeekPos does not match an actual file pointer.\n  public:\n    QuickOpen();\n    ~QuickOpen();\n    void Init(Archive *Arc,bool WriteMode);\n    void Load(uint64 BlockPos);\n    void Unload() { Loaded=false; }\n    bool Read(void *Data,size_t Size,size_t &Result);\n    bool Seek(int64 Offset,int Method);\n    bool Tell(int64 *Pos);\n};\n\n#endif\n","static bool IsAnsiEscComment(const wchar *Data,size_t Size);\n\nbool Archive::GetComment(Array<wchar> *CmtData)\n{\n  if (!MainComment)\n    return false;\n  SaveFilePos SavePos(*this);\n\n#ifndef SFX_MODULE\n  ushort CmtLength;\n  if (Format==RARFMT14)\n  {\n    Seek(SFXSize+SIZEOF_MAINHEAD14,SEEK_SET);\n    CmtLength=GetByte();\n    CmtLength+=(GetByte()<<8);\n  }\n  else\n#endif\n  {\n    if (MainHead.CommentInHeader)\n    {\n      // Old style (RAR 2.9) archive comment embedded into the main \n      // archive header.\n      Seek(SFXSize+SIZEOF_MARKHEAD3+SIZEOF_MAINHEAD3,SEEK_SET);\n      ReadHeader();\n    }\n    else\n    {\n      // Current (RAR 3.0+) version of archive comment.\n      Seek(GetStartPos(),SEEK_SET);\n      return SearchSubBlock(SUBHEAD_TYPE_CMT)!=0 && ReadCommentData(CmtData);\n    }\n#ifndef SFX_MODULE\n    // Old style (RAR 2.9) comment header embedded into the main \n    // archive header.\n    if (BrokenHeader)\n    {\n      uiMsg(UIERROR_CMTBROKEN,FileName);\n      return false;\n    }\n    CmtLength=CommHead.HeadSize-SIZEOF_COMMHEAD;\n#endif\n  }\n#ifndef SFX_MODULE\n  if (Format==RARFMT14 && MainHead.PackComment || Format!=RARFMT14 && CommHead.Method!=0x30)\n  {\n    if (Format!=RARFMT14 && (CommHead.UnpVer < 15 || CommHead.UnpVer > VER_UNPACK || CommHead.Method > 0x35))\n      return(false);\n    ComprDataIO DataIO;\n    DataIO.SetTestMode(true);\n    uint UnpCmtLength;\n    if (Format==RARFMT14)\n    {\n#ifdef RAR_NOCRYPT\n      return(false);\n#else\n      UnpCmtLength=GetByte();\n      UnpCmtLength+=(GetByte()<<8);\n      CmtLength-=2;\n      DataIO.SetCmt13Encryption();\n      CommHead.UnpVer=15;\n#endif\n    }\n    else\n      UnpCmtLength=CommHead.UnpSize;\n    DataIO.SetFiles(this,NULL);\n    DataIO.EnableShowProgress(false);\n    DataIO.SetPackedSizeToRead(CmtLength);\n    DataIO.UnpHash.Init(HASH_CRC32,1);\n\n    Unpack CmtUnpack(&DataIO);\n    CmtUnpack.Init(0x10000,false);\n    CmtUnpack.SetDestSize(UnpCmtLength);\n    CmtUnpack.DoUnpack(CommHead.UnpVer,false);\n\n    if (Format!=RARFMT14 && (DataIO.UnpHash.GetCRC32()&0xffff)!=CommHead.CommCRC)\n    {\n      uiMsg(UIERROR_CMTBROKEN,FileName);\n      return false;\n    }\n    else\n    {\n      byte *UnpData;\n      size_t UnpDataSize;\n      DataIO.GetUnpackedData(&UnpData,&UnpDataSize);\n#ifdef _WIN_ALL\n      OemToCharBuffA((char *)UnpData,(char *)UnpData,(DWORD)UnpDataSize);\n#endif\n      CmtData->Alloc(UnpDataSize+1);\n      memset(CmtData->Addr(0),0,CmtData->Size()*sizeof(wchar));\n      CharToWide((char *)UnpData,CmtData->Addr(0),UnpDataSize);\n      CmtData->Alloc(wcslen(CmtData->Addr(0)));\n    }\n  }\n  else\n  {\n    Array<byte> CmtRaw(CmtLength);\n    Read(&CmtRaw[0],CmtLength);\n\n    if (Format!=RARFMT14 && CommHead.CommCRC!=(~CRC32(0xffffffff,&CmtRaw[0],CmtLength)&0xffff))\n    {\n      uiMsg(UIERROR_CMTBROKEN,FileName);\n      return false;\n    }\n    CmtData->Alloc(CmtLength+1);\n    CmtRaw.Push(0);\n#ifdef _WIN_ALL\n    OemToCharA((char *)&CmtRaw[0],(char *)&CmtRaw[0]);\n#endif\n    CharToWide((char *)&CmtRaw[0],CmtData->Addr(0),CmtLength);\n    CmtData->Alloc(wcslen(CmtData->Addr(0)));\n  }\n#endif\n  return CmtData->Size() > 0;\n}\n\n\nbool Archive::ReadCommentData(Array<wchar> *CmtData)\n{\n  Array<byte> CmtRaw;\n  if (!ReadSubData(&CmtRaw,NULL))\n    return false;\n  size_t CmtSize=CmtRaw.Size();\n  CmtRaw.Push(0);\n  CmtData->Alloc(CmtSize+1);\n  if (Format==RARFMT50)\n    UtfToWide((char *)&CmtRaw[0],CmtData->Addr(0),CmtData->Size());\n  else\n    if ((SubHead.SubFlags & SUBHEAD_FLAGS_CMT_UNICODE)!=0)\n    {\n      RawToWide(&CmtRaw[0],CmtData->Addr(0),CmtSize/2);\n      (*CmtData)[CmtSize/2]=0;\n\n    }\n    else\n    {\n      CharToWide((char *)&CmtRaw[0],CmtData->Addr(0),CmtData->Size());\n    }\n  CmtData->Alloc(wcslen(CmtData->Addr(0))); // Set buffer size to actual comment length.\n  return true;\n}\n\n\nvoid Archive::ViewComment()\n{\n#ifndef GUI\n  if (Cmd->DisableComment)\n    return;\n  Array<wchar> CmtBuf;\n  if (GetComment(&CmtBuf))\n  {\n    size_t CmtSize=CmtBuf.Size();\n    wchar *ChPtr=wcschr(&CmtBuf[0],0x1A);\n    if (ChPtr!=NULL)\n      CmtSize=ChPtr-&CmtBuf[0];\n    mprintf(L\"\\n\");\n    OutComment(&CmtBuf[0],CmtSize);\n  }\n#endif\n}\n\n\n","#ifndef _RAR_UI_\n#define _RAR_UI_\n\n// UIERROR_ - error message;\n// UIMSG_   - informational message;\n// UIWAIT_  - message waiting for user confirmation;\n// UIEVENT_ - if simple message is not enough;\n\nenum UIMESSAGE_CODE {\n  UIERROR_SYSERRMSG, UIERROR_GENERALERRMSG, UIERROR_INCERRCOUNT,\n  UIERROR_CHECKSUM, UIERROR_CHECKSUMENC, UIERROR_CHECKSUMPACKED,\n  UIERROR_BADPSW, UIERROR_MEMORY, UIERROR_FILEOPEN, UIERROR_FILECREATE,\n  UIERROR_FILECLOSE, UIERROR_FILESEEK, UIERROR_FILEREAD,\n  UIERROR_FILEWRITE, UIERROR_FILEDELETE, UIERROR_FILERENAME,\n  UIERROR_FILEATTR, UIERROR_FILECOPY, UIERROR_FILECOPYHINT,\n  UIERROR_DIRCREATE, UIERROR_SLINKCREATE, UIERROR_HLINKCREATE,\n  UIERROR_NEEDADMIN, UIERROR_ARCBROKEN, UIERROR_HEADERBROKEN,\n  UIERROR_MHEADERBROKEN, UIERROR_FHEADERBROKEN, UIERROR_SUBHEADERBROKEN,\n  UIERROR_SUBHEADERUNKNOWN, UIERROR_SUBHEADERDATABROKEN, UIERROR_RRDAMAGED,\n  UIERROR_UNKNOWNMETHOD, UIERROR_UNKNOWNENCMETHOD, UIERROR_RENAMING,\n  UIERROR_NEWERRAR, UIERROR_NOTSFX, UIERROR_OLDTOSFX, UIERROR_WRONGSFXVER,\n  UIERROR_ALREADYENC, UIERROR_SYNCSCAN, UIERROR_DICTOUTMEM,\n  UIERROR_USESMALLERDICT, UIERROR_MODIFYUNKNOWN, UIERROR_MODIFYOLD,\n  UIERROR_MODIFYLOCKED, UIERROR_MODIFYVOLUME, UIERROR_NOTVOLUME,\n  UIERROR_NOTFIRSTVOLUME, UIERROR_RECVOLLIMIT, UIERROR_RECVOLDIFFSETS,\n  UIERROR_RECVOLALLEXIST, UIERROR_RECVOLFOUND, UIERROR_RECONSTRUCTING,\n  UIERROR_RECVOLCANNOTFIX, UIERROR_OPFAILED, UIERROR_UNEXPEOF,\n  UIERROR_BADARCHIVE, UIERROR_CMTBROKEN, UIERROR_INVALIDNAME,\n  UIERROR_NEWRARFORMAT, UIERROR_NOTSUPPORTED, UIERROR_ENCRNOTSUPPORTED,\n  UIERROR_RARZIPONLY, UIERROR_REPAIROLDFORMAT, UIERROR_NOFILESREPAIRED,\n  UIERROR_NOFILESTOADD, UIERROR_NOFILESTODELETE, UIERROR_NOFILESTOEXTRACT,\n  UIERROR_MISSINGVOL, UIERROR_NEEDPREVVOL, UIERROR_UNKNOWNEXTRA,\n  UIERROR_NTFSREQUIRED, UIERROR_ZIPVOLSFX, UIERROR_FILERO,\n  UIERROR_TOOLARGESFX, UIERROR_EMAIL, UIERROR_ACLGET, UIERROR_ACLBROKEN,\n  UIERROR_ACLUNKNOWN, UIERROR_ACLSET, UIERROR_STREAMBROKEN,\n  UIERROR_STREAMUNKNOWN, UIERROR_INCOMPATSWITCH, UIERROR_PATHTOOLONG,\n  UIERROR_DIRSCAN, UIERROR_UOWNERGET, UIERROR_UOWNERBROKEN,\n  UIERROR_UOWNERGETOWNERID, UIERROR_UOWNERGETGROUPID, UIERROR_UOWNERSET,\n  UIERROR_ULINKREAD, UIERROR_ULINKEXIST,\n\n  UIMSG_FIRST,\n  UIMSG_STRING, UIMSG_BUILD, UIMSG_RRSEARCH, UIMSG_RRFOUND,\n  UIMSG_RRNOTFOUND, UIMSG_RRDAMAGED, UIMSG_BLOCKSRECOVERED,\n  UIMSG_COPYINGDATA, UIMSG_AREADAMAGED, UIMSG_SECTORDAMAGED,\n  UIMSG_SECTORRECOVERED, UIMSG_SECTORNOTRECOVERED, UIMSG_FOUND,\n  UIMSG_CORRECTINGNAME, UIMSG_BADARCHIVE, UIMSG_CREATING, UIMSG_RENAMING,\n  UIMSG_RECVOLCALCCHECKSUM, UIMSG_RECVOLFOUND, UIMSG_RECVOLMISSING,\n  UIMSG_MISSINGVOL, UIMSG_RECONSTRUCTING, UIMSG_CHECKSUM, UIMSG_FAT32SIZE,\n\n  UIWAIT_FIRST,\n  UIWAIT_DISKFULLNEXT, UIWAIT_FCREATEERROR,\n\n  UIEVENT_FIRST,\n  UIEVENT_SEARCHDUPFILES, UIEVENT_CLEARATTRSTART, UIEVENT_CLEARATTRFILE,\n  UIEVENT_DELADDEDSTART, UIEVENT_DELADDEDFILE, UIEVENT_FILESFOUND,\n  UIEVENT_ERASEDISK, UIEVENT_FILESUMSTART, UIEVENT_FILESUMPROGRESS,\n  UIEVENT_FILESUMEND, UIEVENT_PROTECTSTART, UIEVENT_PROTECTEND,\n  UIEVENT_TESTADDEDSTART, UIEVENT_TESTADDEDEND, UIEVENT_RRTESTINGSTART,\n  UIEVENT_RRTESTINGEND, UIEVENT_NEWARCHIVE, UIEVENT_NEWREVFILE\n};\n\n// Flags for uiAskReplace function.\nenum UIASKREP_FLAGS {\n  UIASKREP_F_NORENAME=1,UIASKREP_F_EXCHSRCDEST=2,UIASKREP_F_SHOWNAMEONLY=4\n};\n\n// Codes returned by uiAskReplace. Note that uiAskReplaceEx returns only\n// UIASKREP_R_REPLACE, UIASKREP_R_SKIP and UIASKREP_R_CANCEL codes.\nenum UIASKREP_RESULT {\n  UIASKREP_R_REPLACE,UIASKREP_R_SKIP,UIASKREP_R_REPLACEALL,UIASKREP_R_SKIPALL,\n  UIASKREP_R_RENAME,UIASKREP_R_RENAMEAUTO,UIASKREP_R_CANCEL,UIASKREP_R_UNUSED\n};\n\nUIASKREP_RESULT uiAskReplace(wchar *Name,size_t MaxNameSize,int64 FileSize,RarTime *FileTime,uint Flags);\nUIASKREP_RESULT uiAskReplaceEx(RAROptions *Cmd,wchar *Name,size_t MaxNameSize,int64 FileSize,RarTime *FileTime,uint Flags);\n\nvoid uiInit(bool Sound);\n\n\nvoid uiStartArchiveExtract(bool Extract,const wchar *ArcName);\nbool uiStartFileExtract(const wchar *FileName,bool Extract,bool Test,bool Skip);\nvoid uiExtractProgress(int64 CurFileSize,int64 TotalFileSize,int64 CurSize,int64 TotalSize);\nvoid uiProcessProgress(const char *Command,int64 CurSize,int64 TotalSize);\n\nenum UIPASSWORD_TYPE {UIPASSWORD_GLOBAL,UIPASSWORD_FILE,UIPASSWORD_ARCHIVE};\nbool uiGetPassword(UIPASSWORD_TYPE Type,const wchar *FileName,SecPassword *Password);\n\nenum UIALARM_TYPE {UIALARM_ERROR, UIALARM_INFO, UIALARM_QUESTION};\nvoid uiAlarm(UIALARM_TYPE Type);\n\n\nbool uiAskNextVolume(wchar *VolName,size_t MaxSize);\nbool uiAskRepeatRead(const wchar *FileName);\nbool uiAskRepeatWrite(const wchar *FileName,bool DiskFull);\n\n#ifndef SFX_MODULE\nconst wchar *uiGetMonthName(int Month);\n#endif\n\n\nclass uiMsgStore\n{\n  private:\n    static const size_t MAX_MSG = 8;\n    const wchar *Str[MAX_MSG];\n    uint Num[MAX_MSG];\n    uint StrSize,NumSize;\n    UIMESSAGE_CODE Code;\n  public:\n    uiMsgStore(UIMESSAGE_CODE Code)\n    {\n      NumSize=StrSize=0;\n      this->Code=Code;\n    }\n    uiMsgStore& operator << (const wchar *s)\n    {\n      if (StrSize<MAX_MSG)\n        Str[StrSize++]=s;\n      return *this;\n    }\n    uiMsgStore& operator << (uint n)\n    {\n      if (NumSize<MAX_MSG)\n        Num[NumSize++]=n;\n      return *this;\n    }\n\n    void Msg();\n};\n\n\n// Templates recognize usual NULL as integer, not wchar*.\n#define UINULL ((wchar *)NULL)\n\ninline void uiMsg(UIMESSAGE_CODE Code)\n{\n  uiMsgStore Store(Code);\n  Store.Msg();\n}\n\ntemplate<class T1> void uiMsg(UIMESSAGE_CODE Code,T1 a1)\n{\n  uiMsgStore Store(Code);\n  Store<<a1;\n  Store.Msg();\n}\n\ntemplate<class T1,class T2> void uiMsg(UIMESSAGE_CODE Code,T1 a1,T2 a2)\n{\n  uiMsgStore Store(Code);\n  Store<<a1<<a2;\n  Store.Msg();\n}\n\ntemplate<class T1,class T2,class T3> void uiMsg(UIMESSAGE_CODE code,T1 a1,T2 a2,T3 a3)\n{\n  uiMsgStore Store(code);\n  Store<<a1<<a2<<a3;\n  Store.Msg();\n}\n\n#endif\n","#ifndef _RAR_DATAIO_\n#define _RAR_DATAIO_\n\nclass CmdAdd;\nclass Unpack;\n\n\nclass ComprDataIO\n{\n  private:\n    void ShowUnpRead(int64 ArcPos,int64 ArcSize);\n    void ShowUnpWrite();\n\n\n    bool UnpackFromMemory;\n    size_t UnpackFromMemorySize;\n    byte *UnpackFromMemoryAddr;\n\n    bool UnpackToMemory;\n    size_t UnpackToMemorySize;\n    byte *UnpackToMemoryAddr;\n\n    size_t UnpWrSize;\n    byte *UnpWrAddr;\n\n    int64 UnpPackedSize;\n\n    bool ShowProgress;\n    bool TestMode;\n    bool SkipUnpCRC;\n\n    File *SrcFile;\n    File *DestFile;\n\n    CmdAdd *Command;\n\n    FileHeader *SubHead;\n    int64 *SubHeadPos;\n\n#ifndef RAR_NOCRYPT\n    CryptData *Crypt;\n    CryptData *Decrypt;\n#endif\n\n\n    int LastPercent;\n\n    wchar CurrentCommand;\n\n  public:\n    ComprDataIO();\n    ~ComprDataIO();\n    void Init();\n    int UnpRead(byte *Addr,size_t Count);\n    void UnpWrite(byte *Addr,size_t Count);\n    void EnableShowProgress(bool Show) {ShowProgress=Show;}\n    void GetUnpackedData(byte **Data,size_t *Size);\n    void SetPackedSizeToRead(int64 Size) {UnpPackedSize=Size;}\n    void SetTestMode(bool Mode) {TestMode=Mode;}\n    void SetSkipUnpCRC(bool Skip) {SkipUnpCRC=Skip;}\n    void SetFiles(File *SrcFile,File *DestFile);\n    void SetCommand(CmdAdd *Cmd) {Command=Cmd;}\n    void SetSubHeader(FileHeader *hd,int64 *Pos) {SubHead=hd;SubHeadPos=Pos;}\n    void SetEncryption(bool Encrypt,CRYPT_METHOD Method,SecPassword *Password,\n         const byte *Salt,const byte *InitV,uint Lg2Cnt,byte *HashKey,byte *PswCheck);\n    void SetAV15Encryption();\n    void SetCmt13Encryption();\n    void SetUnpackToMemory(byte *Addr,uint Size);\n    void SetCurrentCommand(wchar Cmd) {CurrentCommand=Cmd;}\n\n\n    bool PackVolume;\n    bool UnpVolume;\n    bool NextVolumeMissing;\n    int64 UnpArcSize;\n    int64 CurPackRead,CurPackWrite,CurUnpRead,CurUnpWrite;\n\n\n    // Size of already processed archives.\n    // Used to calculate the total operation progress.\n    int64 ProcessedArcSize;\n\n    int64 TotalArcSize;\n\n    DataHash PackedDataHash; // Packed write and unpack read hash.\n    DataHash PackHash; // Pack read hash.\n    DataHash UnpHash;  // Unpack write hash.\n\n    bool Encryption;\n    bool Decryption;\n};\n\n#endif\n","#ifndef _RAR_UNPACK_\n#define _RAR_UNPACK_\n\n// Maximum allowed number of compressed bits processed in quick mode.\n#define MAX_QUICK_DECODE_BITS      10\n\n// Maximum number of filters per entire data block. Must be at least\n// twice more than MAX_PACK_FILTERS to store filters from two data blocks.\n#define MAX_UNPACK_FILTERS       8192\n\n// Maximum number of filters per entire data block for RAR3 unpack.\n// Must be at least twice more than v3_MAX_PACK_FILTERS to store filters\n// from two data blocks.\n#define MAX3_UNPACK_FILTERS      8192\n\n// Write data in 4 MB or smaller blocks. Must not exceed PACK_MAX_WRITE,\n// so we keep number of buffered filter in unpacker reasonable.\n#define UNPACK_MAX_WRITE     0x400000\n\n// Decode compressed bit fields to alphabet numbers.\nstruct DecodeTable:PackDef\n{\n  // Real size of DecodeNum table.\n  uint MaxNum;\n\n  // Left aligned start and upper limit codes defining code space \n  // ranges for bit lengths. DecodeLen[BitLength-1] defines the start of\n  // range for bit length and DecodeLen[BitLength] defines next code\n  // after the end of range or in other words the upper limit code\n  // for specified bit length.\n  uint DecodeLen[16]; \n\n  // Every item of this array contains the sum of all preceding items.\n  // So it contains the start position in code list for every bit length. \n  uint DecodePos[16];\n\n  // Number of compressed bits processed in quick mode.\n  // Must not exceed MAX_QUICK_DECODE_BITS.\n  uint QuickBits;\n\n  // Translates compressed bits (up to QuickBits length)\n  // to bit length in quick mode.\n  byte QuickLen[1<<MAX_QUICK_DECODE_BITS];\n\n  // Translates compressed bits (up to QuickBits length)\n  // to position in alphabet in quick mode.\n  // 'ushort' saves some memory and even provides a little speed gain\n  // comparting to 'uint' here.\n  ushort QuickNum[1<<MAX_QUICK_DECODE_BITS];\n\n  // Translate the position in code list to position in alphabet.\n  // We do not allocate it dynamically to avoid performance overhead\n  // introduced by pointer, so we use the largest possible table size\n  // as array dimension. Real size of this array is defined in MaxNum.\n  // We use this array if compressed bit field is too lengthy\n  // for QuickLen based translation.\n  // 'ushort' saves some memory and even provides a little speed gain\n  // comparting to 'uint' here.\n  ushort DecodeNum[LARGEST_TABLE_SIZE];\n};\n\n\nstruct UnpackBlockHeader\n{\n  int BlockSize;\n  int BlockBitSize;\n  int BlockStart;\n  int HeaderSize;\n  bool LastBlockInFile;\n  bool TablePresent;\n};\n\n\nstruct UnpackBlockTables\n{\n  DecodeTable LD;  // Decode literals.\n  DecodeTable DD;  // Decode distances.\n  DecodeTable LDD; // Decode lower bits of distances.\n  DecodeTable RD;  // Decode repeating distances.\n  DecodeTable BD;  // Decode bit lengths in Huffman table.\n};\n\n\n#ifdef RAR_SMP\nenum UNP_DEC_TYPE {\n  UNPDT_LITERAL,UNPDT_MATCH,UNPDT_FULLREP,UNPDT_REP,UNPDT_FILTER\n};\n\nstruct UnpackDecodedItem\n{\n  UNP_DEC_TYPE Type;\n  ushort Length;\n  union\n  {\n    uint Distance;\n    byte Literal[4];\n  };\n};\n\n\nstruct UnpackThreadData\n{\n  Unpack *UnpackPtr;\n  BitInput Inp;\n  bool HeaderRead;\n  UnpackBlockHeader BlockHeader;\n  bool TableRead;\n  UnpackBlockTables BlockTables;\n  int DataSize;    // Data left in buffer. Can be less than block size.\n  bool DamagedData;\n  bool LargeBlock;\n  bool NoDataLeft; // 'true' if file is read completely.\n  bool Incomplete; // Not entire block was processed, need to read more data.\n\n  UnpackDecodedItem *Decoded;\n  uint DecodedSize;\n  uint DecodedAllocated;\n  uint ThreadNumber; // For debugging.\n\n  UnpackThreadData()\n  :Inp(false)\n  {\n    Decoded=NULL;\n  }\n  ~UnpackThreadData()\n  {\n    if (Decoded!=NULL)\n      free(Decoded);\n  }\n};\n#endif\n\n\nstruct UnpackFilter\n{\n  byte Type;\n  uint BlockStart;\n  uint BlockLength;\n  byte Channels;\n//  uint Width;\n//  byte PosR;\n  bool NextWindow;\n};\n\n\nstruct UnpackFilter30\n{\n  unsigned int BlockStart;\n  unsigned int BlockLength;\n  unsigned int ExecCount;\n  bool NextWindow;\n\n  // Position of parent filter in Filters array used as prototype for filter\n  // in PrgStack array. Not defined for filters in Filters array.\n  unsigned int ParentFilter;\n\n  VM_PreparedProgram Prg;\n};\n\n\nstruct AudioVariables // For RAR 2.0 archives only.\n{\n  int K1,K2,K3,K4,K5;\n  int D1,D2,D3,D4;\n  int LastDelta;\n  unsigned int Dif[11];\n  unsigned int ByteCount;\n  int LastChar;\n};\n\n\n// We can use the fragmented dictionary in case heap does not have the single\n// large enough memory block. It is slower than normal dictionary.\nclass FragmentedWindow\n{\n  private:\n    enum {MAX_MEM_BLOCKS=32};\n\n    void Reset();\n    byte *Mem[MAX_MEM_BLOCKS];\n    size_t MemSize[MAX_MEM_BLOCKS];\n  public:\n    FragmentedWindow();\n    ~FragmentedWindow();\n    void Init(size_t WinSize);\n    byte& operator [](size_t Item);\n    void CopyString(uint Length,uint Distance,size_t &UnpPtr,size_t MaxWinMask);\n    void CopyData(byte *Dest,size_t WinPos,size_t Size);\n    size_t GetBlockSize(size_t StartPos,size_t RequiredSize);\n};\n\n\nclass Unpack:PackDef\n{\n  private:\n\n    void Unpack5(bool Solid);\n    void Unpack5MT(bool Solid);\n    bool UnpReadBuf();\n    void UnpWriteBuf();\n    byte* ApplyFilter(byte *Data,uint DataSize,UnpackFilter *Flt);\n    void UnpWriteArea(size_t StartPtr,size_t EndPtr);\n    void UnpWriteData(byte *Data,size_t Size);\n    _forceinline uint SlotToLength(BitInput &Inp,uint Slot);\n    bool ReadBlockHeader(BitInput &Inp,UnpackBlockHeader &Header);\n    bool ReadTables(BitInput &Inp,UnpackBlockHeader &Header,UnpackBlockTables &Tables);\n    void MakeDecodeTables(byte *LengthTable,DecodeTable *Dec,uint Size);\n    _forceinline uint DecodeNumber(BitInput &Inp,DecodeTable *Dec);\n    void CopyString();\n    inline void InsertOldDist(unsigned int Distance);\n    void UnpInitData(bool Solid);\n    _forceinline void CopyString(uint Length,uint Distance);\n    uint ReadFilterData(BitInput &Inp);\n    bool ReadFilter(BitInput &Inp,UnpackFilter &Filter);\n    bool AddFilter(UnpackFilter &Filter);\n    bool AddFilter();\n    void InitFilters();\n\n    ComprDataIO *UnpIO;\n    BitInput Inp;\n\n#ifdef RAR_SMP\n    void InitMT();\n    bool UnpackLargeBlock(UnpackThreadData &D);\n    bool ProcessDecoded(UnpackThreadData &D);\n\n    ThreadPool *UnpThreadPool;\n    UnpackThreadData *UnpThreadData;\n    uint MaxUserThreads;\n    byte *ReadBufMT;\n#endif\n\n    Array<byte> FilterSrcMemory;\n    Array<byte> FilterDstMemory;\n\n    // Filters code, one entry per filter.\n    Array<UnpackFilter> Filters;\n\n    uint OldDist[4],OldDistPtr;\n    uint LastLength;\n\n    // LastDist is necessary only for RAR2 and older with circular OldDist\n    // array. In RAR3 last distance is always stored in OldDist[0].\n    uint LastDist;\n\n    size_t UnpPtr,WrPtr;\n    \n    // Top border of read packed data.\n    int ReadTop; \n\n    // Border to call UnpReadBuf. We use it instead of (ReadTop-C)\n    // for optimization reasons. Ensures that we have C bytes in buffer\n    // unless we are at the end of file.\n    int ReadBorder;\n\n    UnpackBlockHeader BlockHeader;\n    UnpackBlockTables BlockTables;\n\n    size_t WriteBorder;\n\n    byte *Window;\n\n    FragmentedWindow FragWindow;\n    bool Fragmented;\n\n\n    int64 DestUnpSize;\n\n    bool Suspended;\n    bool UnpAllBuf;\n    bool UnpSomeRead;\n    int64 WrittenFileSize;\n    bool FileExtracted;\n\n\n/***************************** Unpack v 1.5 *********************************/\n    void Unpack15(bool Solid);\n    void ShortLZ();\n    void LongLZ();\n    void HuffDecode();\n    void GetFlagsBuf();\n    void UnpInitData15(int Solid);\n    void InitHuff();\n    void CorrHuff(ushort *CharSet,byte *NumToPlace);\n    void CopyString15(uint Distance,uint Length);\n    uint DecodeNum(uint Num,uint StartPos,uint *DecTab,uint *PosTab);\n\n    ushort ChSet[256],ChSetA[256],ChSetB[256],ChSetC[256];\n    byte NToPl[256],NToPlB[256],NToPlC[256];\n    uint FlagBuf,AvrPlc,AvrPlcB,AvrLn1,AvrLn2,AvrLn3;\n    int Buf60,NumHuf,StMode,LCount,FlagsCnt;\n    uint Nhfb,Nlzb,MaxDist3;\n/***************************** Unpack v 1.5 *********************************/\n\n/***************************** Unpack v 2.0 *********************************/\n    void Unpack20(bool Solid);\n\n    DecodeTable MD[4]; // Decode multimedia data, up to 4 channels.\n\n    unsigned char UnpOldTable20[MC20*4];\n    int UnpAudioBlock,UnpChannels,UnpCurChannel,UnpChannelDelta;\n    void CopyString20(uint Length,uint Distance);\n    bool ReadTables20();\n    void UnpWriteBuf20();\n    void UnpInitData20(int Solid);\n    void ReadLastTables();\n    byte DecodeAudio(int Delta);\n    struct AudioVariables AudV[4];\n/***************************** Unpack v 2.0 *********************************/\n\n/***************************** Unpack v 3.0 *********************************/\n    enum BLOCK_TYPES {BLOCK_LZ,BLOCK_PPM};\n\n    void UnpInitData30(bool Solid);\n    void Unpack29(bool Solid);\n    void InitFilters30(bool Solid);\n    bool ReadEndOfBlock();\n    bool ReadVMCode();\n    bool ReadVMCodePPM();\n    bool AddVMCode(uint FirstByte,byte *Code,int CodeSize);\n    int SafePPMDecodeChar();\n    bool ReadTables30();\n    bool UnpReadBuf30();\n    void UnpWriteBuf30();\n    void ExecuteCode(VM_PreparedProgram *Prg);\n\n    int PrevLowDist,LowDistRepCount;\n\n    ModelPPM PPM;\n    int PPMEscChar;\n\n    byte UnpOldTable[HUFF_TABLE_SIZE30];\n    int UnpBlockType;\n\n    bool TablesRead;\n\n    // Virtual machine to execute filters code.\n    RarVM VM;\n  \n    // Buffer to read VM filters code. We moved it here from AddVMCode\n    // function to reduce time spent in BitInput constructor.\n    BitInput VMCodeInp;\n\n    // Filters code, one entry per filter.\n    Array<UnpackFilter30 *> Filters30;\n\n    // Filters stack, several entrances of same filter are possible.\n    Array<UnpackFilter30 *> PrgStack;\n\n    // Lengths of preceding data blocks, one length of one last block\n    // for every filter. Used to reduce the size required to write\n    // the data block length if lengths are repeating.\n    Array<int> OldFilterLengths;\n\n    int LastFilter;\n/***************************** Unpack v 3.0 *********************************/\n\n  public:\n    Unpack(ComprDataIO *DataIO);\n    ~Unpack();\n    void Init(size_t WinSize,bool Solid);\n    void DoUnpack(int Method,bool Solid);\n    bool IsFileExtracted() {return(FileExtracted);}\n    void SetDestSize(int64 DestSize) {DestUnpSize=DestSize;FileExtracted=false;}\n    void SetSuspended(bool Suspended) {Unpack::Suspended=Suspended;}\n\n#ifdef RAR_SMP\n    // More than 8 threads are unlikely to provide a noticeable gain\n    // for unpacking, but would use the additional memory.\n    void SetThreads(uint Threads) {MaxUserThreads=Min(Threads,8);}\n\n    void UnpackDecode(UnpackThreadData &D);\n#endif\n\n    size_t MaxWinSize;\n    size_t MaxWinMask;\n\n    uint GetChar()\n    {\n      if (Inp.InAddr>BitInput::MAX_SIZE-30)\n        UnpReadBuf();\n      return(Inp.InBuf[Inp.InAddr++]);\n    }\n};\n\n#endif\n","#ifndef _RAR_CONSIO_\n#define _RAR_CONSIO_\n\nvoid InitConsole();\nvoid InitConsoleOptions(MESSAGE_TYPE MsgStream,RAR_CHARSET RedirectCharset);\nvoid OutComment(const wchar *Comment,size_t Size);\n\n#ifndef SILENT\nbool GetConsolePassword(UIPASSWORD_TYPE Type,const wchar *FileName,SecPassword *Password);\n#endif\n\n#ifdef SILENT\n  inline void mprintf(const wchar *fmt,...) {}\n  inline void eprintf(const wchar *fmt,...) {}\n  inline void Alarm() {}\n  inline int Ask(const wchar *AskStr) {return 0;}\n  inline bool getwstr(wchar *str,size_t n) {return false;}\n#else\n  void mprintf(const wchar *fmt,...);\n  void eprintf(const wchar *fmt,...);\n  void Alarm();\n  int Ask(const wchar *AskStr);\n  bool getwstr(wchar *str,size_t n);\n#endif\n\n#endif\n","#include \"rar.hpp\"\n\nsize_t Archive::ReadHeader()\n{\n  // Once we failed to decrypt an encrypted block, there is no reason to\n  // attempt to do it further. We'll never be successful and only generate\n  // endless errors.\n  if (FailedHeaderDecryption)\n    return 0;\n\n  CurBlockPos=Tell();\n\n  size_t ReadSize;\n  switch(Format)\n  {\n#ifndef SFX_MODULE\n    case RARFMT14:\n      ReadSize=ReadHeader14();\n      break;\n#endif\n    case RARFMT15:\n      ReadSize=ReadHeader15();\n      break;\n    case RARFMT50:\n      ReadSize=ReadHeader50();\n      break;\n  }\n\n  if (ReadSize>0 && NextBlockPos<=CurBlockPos)\n  {\n    BrokenHeaderMsg();\n    return 0;\n  }\n  return ReadSize;\n}\n\n\nsize_t Archive::SearchBlock(HEADER_TYPE HeaderType)\n{\n  size_t Size,Count=0;\n  while ((Size=ReadHeader())!=0 &&\n         (HeaderType==HEAD_ENDARC || GetHeaderType()!=HEAD_ENDARC))\n  {\n    if ((++Count & 127)==0)\n      Wait();\n    if (GetHeaderType()==HeaderType)\n      return Size;\n    SeekToNext();\n  }\n  return 0;\n}\n\n\nsize_t Archive::SearchSubBlock(const wchar *Type)\n{\n  size_t Size,Count=0;\n  while ((Size=ReadHeader())!=0 && GetHeaderType()!=HEAD_ENDARC)\n  {\n    if ((++Count & 127)==0)\n      Wait();\n    if (GetHeaderType()==HEAD_SERVICE && SubHead.CmpName(Type))\n      return Size;\n    SeekToNext();\n  }\n  return 0;\n}\n\n\nsize_t Archive::SearchRR()\n{\n  // If locator extra field is available for recovery record, let's utilize it.\n  if (MainHead.Locator && MainHead.RROffset!=0)\n  {\n    uint64 CurPos=Tell();\n    Seek(MainHead.RROffset,SEEK_SET);\n    size_t Size=ReadHeader();\n    if (Size!=0 && !BrokenHeader && GetHeaderType()==HEAD_SERVICE && SubHead.CmpName(SUBHEAD_TYPE_RR))\n      return Size;\n    Seek(CurPos,SEEK_SET);\n  }\n  // Otherwise scan the entire archive to find the recovery record.\n  return SearchSubBlock(SUBHEAD_TYPE_RR);\n}\n\n\nvoid Archive::UnexpEndArcMsg()\n{\n  int64 ArcSize=FileLength();\n\n  // If block positions are equal to file size, this is not an error.\n  // It can happen when we reached the end of older RAR 1.5 archive,\n  // which did not have the end of archive block.\n  if (CurBlockPos!=ArcSize || NextBlockPos!=ArcSize)\n  {\n    uiMsg(UIERROR_UNEXPEOF,FileName);\n    ErrHandler.SetErrorCode(RARX_WARNING);\n  }\n}\n\n\nvoid Archive::BrokenHeaderMsg()\n{\n  uiMsg(UIERROR_HEADERBROKEN,FileName);\n  BrokenHeader=true;\n  ErrHandler.SetErrorCode(RARX_CRC);\n}\n\n\nvoid Archive::UnkEncVerMsg(const wchar *Name)\n{\n  uiMsg(UIERROR_UNKNOWNENCMETHOD,FileName,Name);\n  ErrHandler.SetErrorCode(RARX_WARNING);\n}\n\n\nsize_t Archive::ReadHeader15()\n{\n  RawRead Raw(this);\n\n  bool Decrypt=Encrypted && CurBlockPos>(int64)SFXSize+SIZEOF_MARKHEAD3;\n\n  if (Decrypt)\n  {\n#ifdef RAR_NOCRYPT // For rarext.dll and unrar_nocrypt.dll.\n    return 0;\n#else\n    RequestArcPassword();\n\n    byte Salt[SIZE_SALT30];\n    if (Read(Salt,SIZE_SALT30)!=SIZE_SALT30)\n    {\n      UnexpEndArcMsg();\n      return 0;\n    }\n    HeadersCrypt.SetCryptKeys(false,CRYPT_RAR30,&Cmd->Password,Salt,NULL,0,NULL,NULL);\n    Raw.SetCrypt(&HeadersCrypt);\n#endif\n  }\n\n  Raw.Read(SIZEOF_SHORTBLOCKHEAD);\n  if (Raw.Size()==0)\n  {\n    UnexpEndArcMsg();\n    return 0;\n  }\n\n  ShortBlock.HeadCRC=Raw.Get2();\n\n  ShortBlock.Reset();\n\n  uint HeaderType=Raw.Get1();\n  ShortBlock.Flags=Raw.Get2();\n  ShortBlock.SkipIfUnknown=(ShortBlock.Flags & SKIP_IF_UNKNOWN)!=0;\n  ShortBlock.HeadSize=Raw.Get2();\n\n  ShortBlock.HeaderType=(HEADER_TYPE)HeaderType;\n  if (ShortBlock.HeadSize<SIZEOF_SHORTBLOCKHEAD)\n  {\n    BrokenHeaderMsg();\n    return 0;\n  }\n\n  // For simpler further processing we map header types common\n  // for RAR 1.5 and 5.0 formats to RAR 5.0 values. It does not include\n  // header types specific for RAR 1.5 - 4.x only.\n  switch(ShortBlock.HeaderType)\n  {\n    case HEAD3_MAIN:    ShortBlock.HeaderType=HEAD_MAIN;     break;\n    case HEAD3_FILE:    ShortBlock.HeaderType=HEAD_FILE;     break;\n    case HEAD3_SERVICE: ShortBlock.HeaderType=HEAD_SERVICE;  break;\n    case HEAD3_ENDARC:  ShortBlock.HeaderType=HEAD_ENDARC;   break;\n  }\n  CurHeaderType=ShortBlock.HeaderType;\n\n  if (ShortBlock.HeaderType==HEAD3_CMT)\n  {\n    // Old style (up to RAR 2.9) comment header embedded into main\n    // or file header. We must not read the entire ShortBlock.HeadSize here\n    // to not break the comment processing logic later.\n    Raw.Read(SIZEOF_COMMHEAD-SIZEOF_SHORTBLOCKHEAD);\n  }\n  else\n    if (ShortBlock.HeaderType==HEAD_MAIN && (ShortBlock.Flags & MHD_COMMENT)!=0)\n    {\n      // Old style (up to RAR 2.9) main archive comment embedded into\n      // the main archive header found. While we can read the entire \n      // ShortBlock.HeadSize here and remove this part of \"if\", it would be\n      // waste of memory, because we'll read and process this comment data\n      // in other function anyway and we do not need them here now.\n      Raw.Read(SIZEOF_MAINHEAD3-SIZEOF_SHORTBLOCKHEAD);\n    }\n    else\n      Raw.Read(ShortBlock.HeadSize-SIZEOF_SHORTBLOCKHEAD);\n\n  NextBlockPos=CurBlockPos+FullHeaderSize(ShortBlock.HeadSize);\n\n  switch(ShortBlock.HeaderType)\n  {\n    case HEAD_MAIN:\n      MainHead.Reset();\n      *(BaseBlock *)&MainHead=ShortBlock;\n      MainHead.HighPosAV=Raw.Get2();\n      MainHead.PosAV=Raw.Get4();\n\n      Volume=(MainHead.Flags & MHD_VOLUME)!=0;\n      Solid=(MainHead.Flags & MHD_SOLID)!=0;\n      Locked=(MainHead.Flags & MHD_LOCK)!=0;\n      Protected=(MainHead.Flags & MHD_PROTECT)!=0;\n      Encrypted=(MainHead.Flags & MHD_PASSWORD)!=0;\n      Signed=MainHead.PosAV!=0 || MainHead.HighPosAV!=0;\n      MainHead.CommentInHeader=(MainHead.Flags & MHD_COMMENT)!=0;\n    \n      // Only for encrypted 3.0+ archives. 2.x archives did not have this\n      // flag, so for non-encrypted archives, we'll set it later based on\n      // file attributes.\n      FirstVolume=(MainHead.Flags & MHD_FIRSTVOLUME)!=0;\n\n      NewNumbering=(MainHead.Flags & MHD_NEWNUMBERING)!=0;\n      break;\n    case HEAD_FILE:\n    case HEAD_SERVICE:\n      {\n        bool FileBlock=ShortBlock.HeaderType==HEAD_FILE;\n        FileHeader *hd=FileBlock ? &FileHead:&SubHead;\n        hd->Reset();\n\n        *(BaseBlock *)hd=ShortBlock;\n\n        hd->SplitBefore=(hd->Flags & LHD_SPLIT_BEFORE)!=0;\n        hd->SplitAfter=(hd->Flags & LHD_SPLIT_AFTER)!=0;\n        hd->Encrypted=(hd->Flags & LHD_PASSWORD)!=0;\n        hd->SaltSet=(hd->Flags & LHD_SALT)!=0;\n        hd->Solid=FileBlock && (hd->Flags & LHD_SOLID)!=0;\n        hd->SubBlock=!FileBlock && (hd->Flags & LHD_SOLID)!=0;\n        hd->Dir=(hd->Flags & LHD_WINDOWMASK)==LHD_DIRECTORY;\n        hd->WinSize=hd->Dir ? 0:0x10000<<((hd->Flags & LHD_WINDOWMASK)>>5);\n        hd->CommentInHeader=(hd->Flags & LHD_COMMENT)!=0;\n        hd->Version=(hd->Flags & LHD_VERSION)!=0;\n        \n        hd->DataSize=Raw.Get4();\n        uint LowUnpSize=Raw.Get4();\n        hd->HostOS=Raw.Get1();\n\n        hd->FileHash.Type=HASH_CRC32;\n        hd->FileHash.CRC32=Raw.Get4();\n\n        uint FileTime=Raw.Get4();\n        hd->UnpVer=Raw.Get1();\n        hd->Method=Raw.Get1()-0x30;\n        size_t NameSize=Raw.Get2();\n        hd->FileAttr=Raw.Get4();\n\n        hd->CryptMethod=CRYPT_NONE;\n        if (hd->Encrypted)\n          switch(hd->UnpVer)\n          {\n            case 13: hd->CryptMethod=CRYPT_RAR13; break;\n            case 15: hd->CryptMethod=CRYPT_RAR15; break;\n            case 20: \n            case 26: hd->CryptMethod=CRYPT_RAR20; break;\n            default: hd->CryptMethod=CRYPT_RAR30; break;\n          }\n\n        hd->HSType=HSYS_UNKNOWN;\n        if (hd->HostOS==HOST_UNIX || hd->HostOS==HOST_BEOS)\n          hd->HSType=HSYS_UNIX;\n        else\n          if (hd->HostOS<HOST_MAX)\n            hd->HSType=HSYS_WINDOWS;\n\n        hd->RedirType=FSREDIR_NONE;\n\n        // RAR 4.x Unix symlink.\n        if (hd->HostOS==HOST_UNIX && (hd->FileAttr & 0xF000)==0xA000)\n        {\n          hd->RedirType=FSREDIR_UNIXSYMLINK;\n          *hd->RedirName=0;\n        }\n\n        hd->Inherited=!FileBlock && (hd->SubFlags & SUBHEAD_FLAGS_INHERITED)!=0;\n        \n        hd->LargeFile=(hd->Flags & LHD_LARGE)!=0;\n\n        uint HighPackSize,HighUnpSize;\n        if (hd->LargeFile)\n        {\n          HighPackSize=Raw.Get4();\n          HighUnpSize=Raw.Get4();\n          hd->UnknownUnpSize=(LowUnpSize==0xffffffff && HighUnpSize==0xffffffff);\n        }\n        else \n        {\n          HighPackSize=HighUnpSize=0;\n          // UnpSize equal to 0xffffffff without LHD_LARGE flag indicates\n          // that we do not know the unpacked file size and must unpack it\n          // until we find the end of file marker in compressed data.\n          hd->UnknownUnpSize=(LowUnpSize==0xffffffff);\n        }\n        hd->PackSize=INT32TO64(HighPackSize,hd->DataSize);\n        hd->UnpSize=INT32TO64(HighUnpSize,LowUnpSize);\n        if (hd->UnknownUnpSize)\n          hd->UnpSize=INT64NDF;\n\n        char FileName[NM*4];\n        size_t ReadNameSize=Min(NameSize,ASIZE(FileName)-1);\n        Raw.GetB((byte *)FileName,ReadNameSize);\n        FileName[ReadNameSize]=0;\n\n        if (FileBlock)\n        {\n          if ((hd->Flags & LHD_UNICODE)!=0)\n          {\n            EncodeFileName NameCoder;\n            size_t Length=strlen(FileName);\n            Length++;\n            NameCoder.Decode(FileName,(byte *)FileName+Length,\n                             NameSize-Length,hd->FileName,\n                             ASIZE(hd->FileName));\n          }\n          else\n            *hd->FileName=0;\n\n          if (*hd->FileName==0)\n            ArcCharToWide(FileName,hd->FileName,ASIZE(hd->FileName),ACTW_OEM);\n\n#ifndef SFX_MODULE\n          ConvertNameCase(hd->FileName);\n#endif\n          ConvertFileHeader(hd);\n        }\n        else\n        {\n          CharToWide(FileName,hd->FileName,ASIZE(hd->FileName));\n\n          // Calculate the size of optional data.\n          int DataSize=int(hd->HeadSize-NameSize-SIZEOF_FILEHEAD3);\n          if ((hd->Flags & LHD_SALT)!=0)\n            DataSize-=SIZE_SALT30;\n\n          if (DataSize>0)\n          {\n            // Here we read optional additional fields for subheaders.\n            // They are stored after the file name and before salt.\n            hd->SubData.Alloc(DataSize);\n            Raw.GetB(&hd->SubData[0],DataSize);\n            if (hd->CmpName(SUBHEAD_TYPE_RR))\n            {\n              byte *D=&hd->SubData[8];\n              RecoverySize=D[0]+((uint)D[1]<<8)+((uint)D[2]<<16)+((uint)D[3]<<24);\n              RecoverySize*=512; // Sectors to size.\n              int64 CurPos=Tell();\n              RecoveryPercent=ToPercent(RecoverySize,CurPos);\n              // Round fractional percent exceeding .5 to upper value.\n              if (ToPercent(RecoverySize+CurPos/200,CurPos)>RecoveryPercent)\n                RecoveryPercent++;\n            }\n          }\n\n          if (hd->CmpName(SUBHEAD_TYPE_CMT))\n            MainComment=true;\n        }\n        if ((hd->Flags & LHD_SALT)!=0)\n          Raw.GetB(hd->Salt,SIZE_SALT30);\n        hd->mtime.SetDos(FileTime);\n        if ((hd->Flags & LHD_EXTTIME)!=0)\n        {\n          ushort Flags=Raw.Get2();\n          RarTime *tbl[4];\n          tbl[0]=&FileHead.mtime;\n          tbl[1]=&FileHead.ctime;\n          tbl[2]=&FileHead.atime;\n          tbl[3]=NULL; // Archive time is not used now.\n          for (int I=0;I<4;I++)\n          {\n            RarTime *CurTime=tbl[I];\n            uint rmode=Flags>>(3-I)*4;\n            if ((rmode & 8)==0 || CurTime==NULL)\n              continue;\n            if (I!=0)\n            {\n              uint DosTime=Raw.Get4();\n              CurTime->SetDos(DosTime);\n            }\n            RarLocalTime rlt;\n            CurTime->GetLocal(&rlt);\n            if (rmode & 4)\n              rlt.Second++;\n            rlt.Reminder=0;\n            int count=rmode&3;\n            for (int J=0;J<count;J++)\n            {\n              byte CurByte=Raw.Get1();\n              rlt.Reminder|=(((uint)CurByte)<<((J+3-count)*8));\n            }\n            CurTime->SetLocal(&rlt);\n          }\n        }\n        NextBlockPos+=hd->PackSize;\n        bool CRCProcessedOnly=hd->CommentInHeader;\n        ushort HeaderCRC=Raw.GetCRC15(CRCProcessedOnly);\n        if (hd->HeadCRC!=HeaderCRC)\n        {\n          BrokenHeader=true;\n          ErrHandler.SetErrorCode(RARX_WARNING);\n\n          // If we have a broken encrypted header, we do not need to display\n          // the error message here, because it will be displayed for such\n          // headers later in this function. Also such headers are unlikely\n          // to have anything sensible in file name field, so it is useless\n          // to display the file name.\n          if (!Decrypt)\n            uiMsg(UIERROR_FHEADERBROKEN,Archive::FileName,hd->FileName);\n        }\n      }\n      break;\n    case HEAD_ENDARC:\n      *(BaseBlock *)&EndArcHead=ShortBlock;\n      EndArcHead.NextVolume=(EndArcHead.Flags & EARC_NEXT_VOLUME)!=0;\n      EndArcHead.DataCRC=(EndArcHead.Flags & EARC_DATACRC)!=0;\n      EndArcHead.RevSpace=(EndArcHead.Flags & EARC_REVSPACE)!=0;\n      EndArcHead.StoreVolNumber=(EndArcHead.Flags & EARC_VOLNUMBER)!=0;\n      if (EndArcHead.DataCRC)\n        EndArcHead.ArcDataCRC=Raw.Get4();\n      if (EndArcHead.StoreVolNumber)\n        VolNumber=EndArcHead.VolNumber=Raw.Get2();\n      break;\n#ifndef SFX_MODULE\n    case HEAD3_CMT:\n      *(BaseBlock *)&CommHead=ShortBlock;\n      CommHead.UnpSize=Raw.Get2();\n      CommHead.UnpVer=Raw.Get1();\n      CommHead.Method=Raw.Get1();\n      CommHead.CommCRC=Raw.Get2();\n      break;\n    case HEAD3_SIGN:\n      *(BaseBlock *)&SignHead=ShortBlock;\n      SignHead.CreationTime=Raw.Get4();\n      SignHead.ArcNameSize=Raw.Get2();\n      SignHead.UserNameSize=Raw.Get2();\n      break;\n    case HEAD3_AV:\n      *(BaseBlock *)&AVHead=ShortBlock;\n      AVHead.UnpVer=Raw.Get1();\n      AVHead.Method=Raw.Get1();\n      AVHead.AVVer=Raw.Get1();\n      AVHead.AVInfoCRC=Raw.Get4();\n      break;\n    case HEAD3_PROTECT:\n      *(BaseBlock *)&ProtectHead=ShortBlock;\n      ProtectHead.DataSize=Raw.Get4();\n      ProtectHead.Version=Raw.Get1();\n      ProtectHead.RecSectors=Raw.Get2();\n      ProtectHead.TotalBlocks=Raw.Get4();\n      Raw.GetB(ProtectHead.Mark,8);\n      NextBlockPos+=ProtectHead.DataSize;\n      RecoverySize=ProtectHead.RecSectors*512;\n      break;\n    case HEAD3_OLDSERVICE:\n      *(BaseBlock *)&SubBlockHead=ShortBlock;\n      SubBlockHead.DataSize=Raw.Get4();\n      NextBlockPos+=SubBlockHead.DataSize;\n      SubBlockHead.SubType=Raw.Get2();\n      SubBlockHead.Level=Raw.Get1();\n      switch(SubBlockHead.SubType)\n      {\n        case UO_HEAD:\n          *(SubBlockHeader *)&UOHead=SubBlockHead;\n          UOHead.OwnerNameSize=Raw.Get2();\n          UOHead.GroupNameSize=Raw.Get2();\n          if (UOHead.OwnerNameSize>=ASIZE(UOHead.OwnerName))\n            UOHead.OwnerNameSize=ASIZE(UOHead.OwnerName)-1;\n          if (UOHead.GroupNameSize>=ASIZE(UOHead.GroupName))\n            UOHead.GroupNameSize=ASIZE(UOHead.GroupName)-1;\n          Raw.GetB(UOHead.OwnerName,UOHead.OwnerNameSize);\n          Raw.GetB(UOHead.GroupName,UOHead.GroupNameSize);\n          UOHead.OwnerName[UOHead.OwnerNameSize]=0;\n          UOHead.GroupName[UOHead.GroupNameSize]=0;\n          break;\n        case MAC_HEAD:\n          *(SubBlockHeader *)&MACHead=SubBlockHead;\n          MACHead.fileType=Raw.Get4();\n          MACHead.fileCreator=Raw.Get4();\n          break;\n        case EA_HEAD:\n        case BEEA_HEAD:\n        case NTACL_HEAD:\n          *(SubBlockHeader *)&EAHead=SubBlockHead;\n          EAHead.UnpSize=Raw.Get4();\n          EAHead.UnpVer=Raw.Get1();\n          EAHead.Method=Raw.Get1();\n          EAHead.EACRC=Raw.Get4();\n          break;\n        case STREAM_HEAD:\n          *(SubBlockHeader *)&StreamHead=SubBlockHead;\n          StreamHead.UnpSize=Raw.Get4();\n          StreamHead.UnpVer=Raw.Get1();\n          StreamHead.Method=Raw.Get1();\n          StreamHead.StreamCRC=Raw.Get4();\n          StreamHead.StreamNameSize=Raw.Get2();\n          if (StreamHead.StreamNameSize>=ASIZE(StreamHead.StreamName))\n            StreamHead.StreamNameSize=ASIZE(StreamHead.StreamName)-1;\n          Raw.GetB(StreamHead.StreamName,StreamHead.StreamNameSize);\n          StreamHead.StreamName[StreamHead.StreamNameSize]=0;\n          break;\n      }\n      break;\n#endif\n    default:\n      if (ShortBlock.Flags & LONG_BLOCK)\n        NextBlockPos+=Raw.Get4();\n      break;\n  }\n  \n  ushort HeaderCRC=Raw.GetCRC15(false);\n\n  // Old AV header does not have header CRC properly set.\n  if (ShortBlock.HeadCRC!=HeaderCRC && ShortBlock.HeaderType!=HEAD3_SIGN &&\n      ShortBlock.HeaderType!=HEAD3_AV)\n  {\n    bool Recovered=false;\n    if (ShortBlock.HeaderType==HEAD_ENDARC && EndArcHead.RevSpace)\n    {\n      // Last 7 bytes of recovered volume can contain zeroes, because\n      // REV files store its own information (volume number, etc.) here.\n      SaveFilePos SavePos(*this);\n      int64 Length=Tell();\n      Seek(Length-7,SEEK_SET);\n      Recovered=true;\n      for (int J=0;J<7;J++)\n        if (GetByte()!=0)\n          Recovered=false;\n    }\n    if (!Recovered)\n    {\n      BrokenHeader=true;\n      ErrHandler.SetErrorCode(RARX_CRC);\n\n      if (Decrypt)\n      {\n        uiMsg(UIERROR_CHECKSUMENC,FileName,FileName);\n        FailedHeaderDecryption=true;\n        return 0;\n      }\n    }\n  }\n\n  if (NextBlockPos<=CurBlockPos)\n  {\n    BrokenHeaderMsg();\n    return 0;\n  }\n\n  return Raw.Size();\n}\n\n\nsize_t Archive::ReadHeader50()\n{\n  RawRead Raw(this);\n\n  bool Decrypt=Encrypted && CurBlockPos>(int64)SFXSize+SIZEOF_MARKHEAD5;\n\n  if (Decrypt)\n  {\n#if defined(SHELL_EXT) || defined(RAR_NOCRYPT)\n    return 0;\n#else\n    RequestArcPassword();\n\n    byte HeadersInitV[SIZE_INITV];\n    if (Read(HeadersInitV,SIZE_INITV)!=SIZE_INITV)\n    {\n      UnexpEndArcMsg();\n      return 0;\n    }\n\n    byte PswCheck[SIZE_PSWCHECK];\n    HeadersCrypt.SetCryptKeys(false,CRYPT_RAR50,&Cmd->Password,CryptHead.Salt,HeadersInitV,CryptHead.Lg2Count,NULL,PswCheck);\n    // Verify password validity.\n    if (CryptHead.UsePswCheck && memcmp(PswCheck,CryptHead.PswCheck,SIZE_PSWCHECK)!=0)\n    {\n      uiMsg(UIERROR_BADPSW,FileName);\n      FailedHeaderDecryption=true;\n      ErrHandler.SetErrorCode(RARX_BADPWD);\n      return 0;\n    }\n\n    Raw.SetCrypt(&HeadersCrypt);\n#endif\n  }\n\n  // Header size must not occupy more than 3 variable length integer bytes\n  // resulting in 2 MB maximum header size, so here we read 4 byte CRC32\n  // followed by 3 bytes or less of header size.\n  const size_t FirstReadSize=7; // Smallest possible block size.\n  if (Raw.Read(FirstReadSize)<FirstReadSize)\n  {\n    UnexpEndArcMsg();\n    return 0;\n  }\n\n  ShortBlock.Reset();\n  ShortBlock.HeadCRC=Raw.Get4();\n  uint SizeBytes=Raw.GetVSize(4);\n  uint64 BlockSize=Raw.GetV();\n\n  if (BlockSize==0 || SizeBytes==0)\n  {\n    BrokenHeaderMsg();\n    return 0;\n  }\n\n  int SizeToRead=int(BlockSize);\n  SizeToRead-=FirstReadSize-SizeBytes-4; // Adjust overread size bytes if any.\n  uint HeaderSize=4+SizeBytes+(uint)BlockSize;\n\n  if (SizeToRead<0 || HeaderSize<SIZEOF_SHORTBLOCKHEAD5)\n  {\n    BrokenHeaderMsg();\n    return 0;\n  }\n  \n  Raw.Read(SizeToRead);\n\n  if (Raw.Size()<HeaderSize)\n  {\n    UnexpEndArcMsg();\n    return 0;\n  }\n\n  uint HeaderCRC=Raw.GetCRC50();\n\n  ShortBlock.HeaderType=(HEADER_TYPE)Raw.GetV();\n  ShortBlock.Flags=(uint)Raw.GetV();\n  ShortBlock.SkipIfUnknown=(ShortBlock.Flags & HFL_SKIPIFUNKNOWN)!=0;\n  ShortBlock.HeadSize=HeaderSize;\n\n  CurHeaderType=ShortBlock.HeaderType;\n\n  bool BadCRC=(ShortBlock.HeadCRC!=HeaderCRC);\n  if (BadCRC)\n  {\n    BrokenHeaderMsg(); // Report, but attempt to process.\n\n    BrokenHeader=true;\n    ErrHandler.SetErrorCode(RARX_CRC);\n\n    if (Decrypt)\n    {\n      uiMsg(UIERROR_CHECKSUMENC,FileName,FileName);\n      FailedHeaderDecryption=true;\n      return 0;\n    }\n  }\n  \n  uint64 ExtraSize=0;\n  if ((ShortBlock.Flags & HFL_EXTRA)!=0)\n  {\n    ExtraSize=Raw.GetV();\n    if (ExtraSize>=ShortBlock.HeadSize)\n    {\n      BrokenHeaderMsg();\n      return 0;\n    }\n  }\n\n  uint64 DataSize=0;\n  if ((ShortBlock.Flags & HFL_DATA)!=0)\n    DataSize=Raw.GetV();\n\n  NextBlockPos=CurBlockPos+FullHeaderSize(ShortBlock.HeadSize)+DataSize;\n\n  switch(ShortBlock.HeaderType)\n  {\n    case HEAD_CRYPT:\n      {\n        *(BaseBlock *)&CryptHead=ShortBlock;\n        uint CryptVersion=(uint)Raw.GetV();\n        if (CryptVersion>CRYPT_VERSION)\n        {\n          UnkEncVerMsg(FileName);\n          return 0;\n        }\n        uint EncFlags=(uint)Raw.GetV();\n        CryptHead.UsePswCheck=(EncFlags & CHFL_CRYPT_PSWCHECK)!=0;\n        CryptHead.Lg2Count=Raw.Get1();\n        if (CryptHead.Lg2Count>CRYPT5_KDF_LG2_COUNT_MAX)\n        {\n          UnkEncVerMsg(FileName);\n          return 0;\n        }\n        Raw.GetB(CryptHead.Salt,SIZE_SALT50);\n        if (CryptHead.UsePswCheck)\n        {\n          Raw.GetB(CryptHead.PswCheck,SIZE_PSWCHECK);\n\n          byte csum[SIZE_PSWCHECK_CSUM];\n          Raw.GetB(csum,SIZE_PSWCHECK_CSUM);\n\n          sha256_context ctx;\n          sha256_init(&ctx);\n          sha256_process(&ctx, CryptHead.PswCheck, SIZE_PSWCHECK);\n\n          byte Digest[SHA256_DIGEST_SIZE];\n          sha256_done(&ctx, Digest);\n\n          CryptHead.UsePswCheck=memcmp(csum,Digest,SIZE_PSWCHECK_CSUM)==0;\n        }\n        Encrypted=true;\n      }\n      break;\n    case HEAD_MAIN:\n      {\n        MainHead.Reset();\n        *(BaseBlock *)&MainHead=ShortBlock;\n        uint ArcFlags=(uint)Raw.GetV();\n\n        Volume=(ArcFlags & MHFL_VOLUME)!=0;\n        Solid=(ArcFlags & MHFL_SOLID)!=0;\n        Locked=(ArcFlags & MHFL_LOCK)!=0;\n        Protected=(ArcFlags & MHFL_PROTECT)!=0;\n        Signed=false;\n        NewNumbering=true;\n\n        if ((ArcFlags & MHFL_VOLNUMBER)!=0)\n          VolNumber=(uint)Raw.GetV();\n        else\n          VolNumber=0;\n        FirstVolume=Volume && VolNumber==0;\n\n        if (ExtraSize!=0)\n          ProcessExtra50(&Raw,(size_t)ExtraSize,&MainHead);\n\n#ifdef USE_QOPEN\n        if (MainHead.Locator && MainHead.QOpenOffset>0 && Cmd->QOpenMode!=QOPEN_NONE)\n        {\n          // We seek to QO block in the end of archive when processing\n          // QOpen.Load, so we need to preserve current block positions\n          // to not break normal archive processing by calling function.\n          int64 SaveCurBlockPos=CurBlockPos,SaveNextBlockPos=NextBlockPos;\n          HEADER_TYPE SaveCurHeaderType=CurHeaderType;\n          \n          QOpen.Init(this,false);\n          QOpen.Load(MainHead.QOpenOffset);\n\n          CurBlockPos=SaveCurBlockPos;\n          NextBlockPos=SaveNextBlockPos;\n          CurHeaderType=SaveCurHeaderType;\n        }\n#endif\n      }\n      break;\n    case HEAD_FILE:\n    case HEAD_SERVICE:\n      {\n        FileHeader *hd=ShortBlock.HeaderType==HEAD_FILE ? &FileHead:&SubHead;\n        hd->Reset();\n        *(BaseBlock *)hd=ShortBlock;\n\n        bool FileBlock=ShortBlock.HeaderType==HEAD_FILE;\n\n        hd->LargeFile=true;\n\n        hd->PackSize=DataSize;\n        hd->FileFlags=(uint)Raw.GetV();\n        hd->UnpSize=Raw.GetV();\n        \n        hd->UnknownUnpSize=(hd->FileFlags & FHFL_UNPUNKNOWN)!=0;\n        if (hd->UnknownUnpSize)\n          hd->UnpSize=INT64NDF;\n\n        hd->MaxSize=Max(hd->PackSize,hd->UnpSize);\n        hd->FileAttr=(uint)Raw.GetV();\n        if ((hd->FileFlags & FHFL_UTIME)!=0)\n          hd->mtime=(time_t)Raw.Get4();\n\n        hd->FileHash.Type=HASH_NONE;\n        if ((hd->FileFlags & FHFL_CRC32)!=0)\n        {\n          hd->FileHash.Type=HASH_CRC32;\n          hd->FileHash.CRC32=Raw.Get4();\n        }\n\n        hd->RedirType=FSREDIR_NONE;\n\n        uint CompInfo=(uint)Raw.GetV();\n        hd->Method=(CompInfo>>7) & 7;\n\n        // \"+ 50\" to not mix with old RAR format algorithms. For example,\n        // we may need to use the compression algorithm 15 in the future,\n        // but it was already used in RAR 1.5 and Unpack needs to distinguish\n        // them.\n        hd->UnpVer=(CompInfo & 0x3f) + 50;\n\n        hd->HostOS=(byte)Raw.GetV();\n        size_t NameSize=(size_t)Raw.GetV();\n        hd->Inherited=(ShortBlock.Flags & HFL_INHERITED)!=0;\n\n        hd->HSType=HSYS_UNKNOWN;\n        if (hd->HostOS==HOST5_UNIX)\n          hd->HSType=HSYS_UNIX;\n        else\n          if (hd->HostOS==HOST5_WINDOWS)\n            hd->HSType=HSYS_WINDOWS;\n\n        hd->SplitBefore=(hd->Flags & HFL_SPLITBEFORE)!=0;\n        hd->SplitAfter=(hd->Flags & HFL_SPLITAFTER)!=0;\n        hd->SubBlock=(hd->Flags & HFL_CHILD)!=0;\n        hd->Solid=FileBlock && (CompInfo & FCI_SOLID)!=0;\n        hd->Dir=(hd->FileFlags & FHFL_DIRECTORY)!=0;\n        hd->WinSize=hd->Dir ? 0:size_t(0x20000)<<((CompInfo>>10)&0xf);\n\n        hd->CryptMethod=hd->Encrypted ? CRYPT_RAR50:CRYPT_NONE;\n\n        char FileName[NM*4];\n        size_t ReadNameSize=Min(NameSize,ASIZE(FileName)-1);\n        Raw.GetB((byte *)FileName,ReadNameSize);\n        FileName[ReadNameSize]=0;\n\n        UtfToWide(FileName,hd->FileName,ASIZE(hd->FileName));\n\n        // Should do it before converting names, because extra fields can\n        // affect name processing, like in case of NTFS streams.\n        if (ExtraSize!=0)\n          ProcessExtra50(&Raw,(size_t)ExtraSize,hd);\n\n        if (FileBlock)\n        {\n#ifndef SFX_MODULE\n          ConvertNameCase(hd->FileName);\n#endif\n          ConvertFileHeader(hd);\n        }\n\n        if (!FileBlock && hd->CmpName(SUBHEAD_TYPE_CMT))\n          MainComment=true;\n\n          \n        if (BadCRC) // Add the file name to broken header message displayed above.\n          uiMsg(UIERROR_FHEADERBROKEN,Archive::FileName,hd->FileName);\n      }\n      break;\n    case HEAD_ENDARC:\n      {\n        *(BaseBlock *)&EndArcHead=ShortBlock;\n        uint ArcFlags=(uint)Raw.GetV();\n        EndArcHead.NextVolume=(ArcFlags & EHFL_NEXTVOLUME)!=0;\n        EndArcHead.StoreVolNumber=false;\n        EndArcHead.DataCRC=false;\n        EndArcHead.RevSpace=false;\n      }\n      break;\n  }\n\n  if (NextBlockPos<=CurBlockPos)\n  {\n    BrokenHeaderMsg();\n    return 0;\n  }\n  return Raw.Size();\n}\n\n\n#if !defined(SHELL_EXT) && !defined(RAR_NOCRYPT)\nvoid Archive::RequestArcPassword()\n{\n  if (!Cmd->Password.IsSet())\n  {\n#ifdef RARDLL\n    if (Cmd->Callback!=NULL)\n    {\n      wchar PasswordW[MAXPASSWORD];\n      *PasswordW=0;\n      if (Cmd->Callback(UCM_NEEDPASSWORDW,Cmd->UserData,(LPARAM)PasswordW,ASIZE(PasswordW))==-1)\n        *PasswordW=0;\n      if (*PasswordW==0)\n      {\n        char PasswordA[MAXPASSWORD];\n        *PasswordA=0;\n        if (Cmd->Callback(UCM_NEEDPASSWORD,Cmd->UserData,(LPARAM)PasswordA,ASIZE(PasswordA))==-1)\n          *PasswordA=0;\n        GetWideName(PasswordA,NULL,PasswordW,ASIZE(PasswordW));\n        cleandata(PasswordA,sizeof(PasswordA));\n      }\n      Cmd->Password.Set(PasswordW);\n      cleandata(PasswordW,sizeof(PasswordW));\n    }\n    if (!Cmd->Password.IsSet())\n    {\n      Close();\n      Cmd->DllError=ERAR_MISSING_PASSWORD;\n      ErrHandler.Exit(RARX_USERBREAK);\n    }\n#else\n    if (!uiGetPassword(UIPASSWORD_ARCHIVE,FileName,&Cmd->Password) ||\n        !Cmd->Password.IsSet())\n    {\n      Close();\n      uiMsg(UIERROR_INCERRCOUNT);\n      ErrHandler.Exit(RARX_USERBREAK);\n    }\n#endif\n    Cmd->ManualPassword=true;\n  }\n}\n#endif\n\n\nvoid Archive::ProcessExtra50(RawRead *Raw,size_t ExtraSize,BaseBlock *bb)\n{\n  // Read extra data from the end of block skipping any fields before it.\n  size_t ExtraStart=Raw->Size()-ExtraSize;\n  if (ExtraStart<Raw->GetPos())\n    return;\n  Raw->SetPos(ExtraStart);\n  while (Raw->DataLeft()>=2)\n  {\n    int64 FieldSize=Raw->GetV();\n    if (FieldSize==0 || Raw->DataLeft()==0 || FieldSize>(int64)Raw->DataLeft())\n      break;\n    size_t NextPos=size_t(Raw->GetPos()+FieldSize);\n    uint64 FieldType=Raw->GetV();\n\n    FieldSize=int64(NextPos-Raw->GetPos()); // Field size without size and type fields.\n\n    if (bb->HeaderType==HEAD_MAIN)\n    {\n      MainHeader *hd=(MainHeader *)bb;\n      if (FieldType==MHEXTRA_LOCATOR)\n      {\n        hd->Locator=true;\n        uint Flags=(uint)Raw->GetV();\n        if ((Flags & MHEXTRA_LOCATOR_QLIST)!=0)\n        {\n          uint64 Offset=Raw->GetV();\n          if (Offset!=0) // 0 means that reserved space was not enough to write the offset.\n            hd->QOpenOffset=Offset+CurBlockPos;\n        }\n        if ((Flags & MHEXTRA_LOCATOR_RR)!=0)\n        {\n          uint64 Offset=Raw->GetV();\n          if (Offset!=0) // 0 means that reserved space was not enough to write the offset.\n            hd->RROffset=Offset+CurBlockPos;\n        }\n      }\n    }\n\n    if (bb->HeaderType==HEAD_FILE || bb->HeaderType==HEAD_SERVICE)\n    {\n      FileHeader *hd=(FileHeader *)bb;\n      switch(FieldType)\n      {\n        case FHEXTRA_CRYPT:\n          {\n            FileHeader *hd=(FileHeader *)bb;\n            uint EncVersion=(uint)Raw->GetV();\n            if (EncVersion > CRYPT_VERSION)\n              UnkEncVerMsg(hd->FileName);\n            else\n            {\n              uint Flags=(uint)Raw->GetV();\n              hd->UsePswCheck=(Flags & FHEXTRA_CRYPT_PSWCHECK)!=0;\n              hd->UseHashKey=(Flags & FHEXTRA_CRYPT_HASHMAC)!=0;\n              hd->Lg2Count=Raw->Get1();\n              if (hd->Lg2Count>CRYPT5_KDF_LG2_COUNT_MAX)\n                UnkEncVerMsg(hd->FileName);\n              Raw->GetB(hd->Salt,SIZE_SALT50);\n              Raw->GetB(hd->InitV,SIZE_INITV);\n              if (hd->UsePswCheck)\n              {\n                Raw->GetB(hd->PswCheck,SIZE_PSWCHECK);\n\n                // It is important to know if password check data is valid.\n                // If it is damaged and header CRC32 fails to detect it,\n                // archiver would refuse to decompress a possibly valid file.\n                // Since we want to be sure distinguishing a wrong password\n                // or corrupt file data, we use 64-bit password check data\n                // and to control its validity we use 32 bits of password\n                // check data SHA-256 additionally to 32-bit header CRC32.\n                byte csum[SIZE_PSWCHECK_CSUM];\n                Raw->GetB(csum,SIZE_PSWCHECK_CSUM);\n\n                sha256_context ctx;\n                sha256_init(&ctx);\n                sha256_process(&ctx, hd->PswCheck, SIZE_PSWCHECK);\n\n                byte Digest[SHA256_DIGEST_SIZE];\n                sha256_done(&ctx, Digest);\n\n                hd->UsePswCheck=memcmp(csum,Digest,SIZE_PSWCHECK_CSUM)==0;\n\n                // RAR 5.21 and earlier set PswCheck field in service records to 0\n                // even if UsePswCheck was present.\n                if (bb->HeaderType==HEAD_SERVICE && memcmp(hd->PswCheck,\"\\0\\0\\0\\0\\0\\0\\0\\0\",SIZE_PSWCHECK)==0)\n                  hd->UsePswCheck=0;\n              }\n              hd->SaltSet=true;\n              hd->CryptMethod=CRYPT_RAR50;\n              hd->Encrypted=true;\n            }\n          }\n          break;\n        case FHEXTRA_HASH:\n          {\n            FileHeader *hd=(FileHeader *)bb;\n            uint Type=(uint)Raw->GetV();\n            if (Type==FHEXTRA_HASH_BLAKE2)\n            {\n              hd->FileHash.Type=HASH_BLAKE2;\n              Raw->GetB(hd->FileHash.Digest,BLAKE2_DIGEST_SIZE);\n            }\n          }\n          break;\n        case FHEXTRA_HTIME:\n          if (FieldSize>=9)\n          {\n            byte Flags=(byte)Raw->GetV();\n            bool UnixTime=(Flags & FHEXTRA_HTIME_UNIXTIME)!=0;\n            if ((Flags & FHEXTRA_HTIME_MTIME)!=0)\n              if (UnixTime)\n                hd->mtime=(time_t)Raw->Get4();\n              else\n                hd->mtime.SetRaw(Raw->Get8());\n            if ((Flags & FHEXTRA_HTIME_CTIME)!=0)\n              if (UnixTime)\n                hd->ctime=(time_t)Raw->Get4();\n              else\n                hd->ctime.SetRaw(Raw->Get8());\n            if ((Flags & FHEXTRA_HTIME_ATIME)!=0)\n              if (UnixTime)\n                hd->atime=(time_t)Raw->Get4();\n              else\n                hd->atime.SetRaw(Raw->Get8());\n          }\n          break;\n        case FHEXTRA_VERSION:\n          if (FieldSize>=1)\n          {\n            Raw->GetV(); // Skip flags field.\n            uint Version=(uint)Raw->GetV();\n            if (Version!=0)\n            {\n              hd->Version=true;\n\n              wchar VerText[20];\n              swprintf(VerText,ASIZE(VerText),L\";%u\",Version);\n              wcsncatz(FileHead.FileName,VerText,ASIZE(FileHead.FileName));\n            }\n          }\n          break;\n        case FHEXTRA_REDIR:\n          {\n            hd->RedirType=(FILE_SYSTEM_REDIRECT)Raw->GetV();\n            uint Flags=(uint)Raw->GetV();\n            hd->DirTarget=(Flags & FHEXTRA_REDIR_DIR)!=0;\n            size_t NameSize=(size_t)Raw->GetV();\n\n            char UtfName[NM*4];\n            *UtfName=0;\n            if (NameSize<ASIZE(UtfName)-1)\n            {\n              Raw->GetB(UtfName,NameSize);\n              UtfName[NameSize]=0;\n            }\n#ifdef _WIN_ALL\n            UnixSlashToDos(UtfName,UtfName,ASIZE(UtfName));\n#endif\n            UtfToWide(UtfName,hd->RedirName,ASIZE(hd->RedirName));\n          }\n          break;\n        case FHEXTRA_UOWNER:\n          {\n            uint Flags=(uint)Raw->GetV();\n            hd->UnixOwnerNumeric=(Flags & FHEXTRA_UOWNER_NUMUID)!=0;\n            hd->UnixGroupNumeric=(Flags & FHEXTRA_UOWNER_NUMGID)!=0;\n            *hd->UnixOwnerName=*hd->UnixGroupName=0;\n            if ((Flags & FHEXTRA_UOWNER_UNAME)!=0)\n            {\n              size_t Length=(size_t)Raw->GetV();\n              Length=Min(Length,ASIZE(hd->UnixOwnerName)-1);\n              Raw->GetB(hd->UnixOwnerName,Length);\n              hd->UnixOwnerName[Length]=0;\n            }\n            if ((Flags & FHEXTRA_UOWNER_GNAME)!=0)\n            {\n              size_t Length=(size_t)Raw->GetV();\n              Length=Min(Length,ASIZE(hd->UnixGroupName)-1);\n              Raw->GetB(hd->UnixGroupName,Length);\n              hd->UnixGroupName[Length]=0;\n            }\n#ifdef _UNIX\n            if (hd->UnixOwnerNumeric)\n              hd->UnixOwnerID=(uid_t)Raw->GetV();\n            if (hd->UnixGroupNumeric)\n              hd->UnixGroupID=(gid_t)Raw->GetV();\n#else\n            // Need these fields in Windows too for 'list' command,\n            // but uid_t and gid_t are not defined.\n            if (hd->UnixOwnerNumeric)\n              hd->UnixOwnerID=(uint)Raw->GetV();\n            if (hd->UnixGroupNumeric)\n              hd->UnixGroupID=(uint)Raw->GetV();\n#endif\n            hd->UnixOwnerSet=true;\n          }\n          break;\n        case FHEXTRA_SUBDATA:\n          {\n            // RAR 5.21 and earlier set FHEXTRA_SUBDATA size to 1 less than\n            // required. It did not hurt extraction, because UnRAR 5.21\n            // and earlier ignored this field and set FieldSize as data left\n            // in entire extra area. But now we set the correct field size\n            // and set FieldSize based on actual extra record size,\n            // so we need to adjust it for those older archives here.\n            // FHEXTRA_SUBDATA in those archives always belongs to HEAD_SERVICE\n            // and always is last in extra area. So since its size is by 1\n            // less than needed, we always have 1 byte left in extra area,\n            // which fact we use here to detect such archives.\n            if (bb->HeaderType==HEAD_SERVICE && Raw->Size()-NextPos==1)\n              FieldSize++;\n\n            hd->SubData.Alloc((size_t)FieldSize);\n            Raw->GetB(hd->SubData.Addr(0),(size_t)FieldSize);\n          }\n          break;\n      }\n    }\n\n    Raw->SetPos(NextPos);\n  }\n}\n\n\n#ifndef SFX_MODULE\nsize_t Archive::ReadHeader14()\n{\n  RawRead Raw(this);\n  if (CurBlockPos<=(int64)SFXSize)\n  {\n    Raw.Read(SIZEOF_MAINHEAD14);\n    MainHead.Reset();\n    byte Mark[4];\n    Raw.GetB(Mark,4);\n    uint HeadSize=Raw.Get2();\n    byte Flags=Raw.Get1();\n    NextBlockPos=CurBlockPos+HeadSize;\n    CurHeaderType=HEAD_MAIN;\n\n    Volume=(Flags & MHD_VOLUME)!=0;\n    Solid=(Flags & MHD_SOLID)!=0;\n    Locked=(Flags & MHD_LOCK)!=0;\n    MainHead.CommentInHeader=(Flags & MHD_COMMENT)!=0;\n    MainHead.PackComment=(Flags & MHD_PACK_COMMENT)!=0;\n  }\n  else\n  {\n    Raw.Read(SIZEOF_FILEHEAD14);\n    FileHead.Reset();\n\n    FileHead.HeaderType=HEAD_FILE;\n    FileHead.DataSize=Raw.Get4();\n    FileHead.UnpSize=Raw.Get4();\n    FileHead.FileHash.Type=HASH_RAR14;\n    FileHead.FileHash.CRC32=Raw.Get2();\n    FileHead.HeadSize=Raw.Get2();\n    uint FileTime=Raw.Get4();\n    FileHead.FileAttr=Raw.Get1();\n    FileHead.Flags=Raw.Get1()|LONG_BLOCK;\n    FileHead.UnpVer=(Raw.Get1()==2) ? 13 : 10;\n    size_t NameSize=Raw.Get1();\n    FileHead.Method=Raw.Get1();\n\n    FileHead.SplitBefore=(FileHead.Flags & LHD_SPLIT_BEFORE)!=0;\n    FileHead.SplitAfter=(FileHead.Flags & LHD_SPLIT_AFTER)!=0;\n    FileHead.Encrypted=(FileHead.Flags & LHD_PASSWORD)!=0;\n    FileHead.CryptMethod=FileHead.Encrypted ? CRYPT_RAR13:CRYPT_NONE;\n\n    FileHead.PackSize=FileHead.DataSize;\n    FileHead.WinSize=0x10000;\n\n    FileHead.mtime.SetDos(FileTime);\n\n    Raw.Read(NameSize);\n\n    char FileName[NM];\n    Raw.GetB((byte *)FileName,Min(NameSize,ASIZE(FileName)));\n    FileName[NameSize]=0;\n    IntToExt(FileName,FileName,ASIZE(FileName));\n    CharToWide(FileName,FileHead.FileName,ASIZE(FileHead.FileName));\n    ConvertNameCase(FileHead.FileName);\n\n    if (Raw.Size()!=0)\n      NextBlockPos=CurBlockPos+FileHead.HeadSize+FileHead.PackSize;\n    CurHeaderType=HEAD_FILE;\n  }\n  return NextBlockPos>CurBlockPos ? Raw.Size() : 0;\n}\n#endif\n\n\n#ifndef SFX_MODULE\nvoid Archive::ConvertNameCase(wchar *Name)\n{\n  if (Cmd->ConvertNames==NAMES_UPPERCASE)\n    wcsupper(Name);\n  if (Cmd->ConvertNames==NAMES_LOWERCASE)\n    wcslower(Name);\n}\n#endif\n\n\nbool Archive::IsArcDir()\n{\n  return FileHead.Dir;\n}\n\n\nvoid Archive::ConvertAttributes()\n{\n#if defined(_WIN_ALL) || defined(_EMX)\n  if (FileHead.HSType!=HSYS_WINDOWS)\n    FileHead.FileAttr=FileHead.Dir ? 0x10 : 0x20;\n#endif\n#ifdef _UNIX\n  // umask defines which permission bits must not be set by default\n  // when creating a file or directory. The typical default value\n  // for the process umask is S_IWGRP | S_IWOTH (octal 022),\n  // resulting in 0644 mode for new files.\n  // Normally umask is applied automatically when creating a file,\n  // but we set attributes with chmod later, so we need to calculate\n  // resulting attributes here. We do it only for non-Unix archives.\n  // We restore native Unix attributes as is, because it can be backup.\n  static mode_t mask = (mode_t) -1;\n\n  if (mask == (mode_t) -1)\n  {\n    // umask call returns the current umask value. Argument (022) is not \n    // really important here.\n    mask = umask(022);\n\n    // Restore the original umask value, which was changed to 022 above.\n    umask(mask);\n  }\n\n  switch(FileHead.HSType)\n  {\n    case HSYS_WINDOWS:\n      {\n        // Mapping MSDOS, OS/2 and Windows file attributes to Unix.\n\n        if (FileHead.FileAttr & 0x10) // FILE_ATTRIBUTE_DIRECTORY\n        {\n          // For directories we use 0777 mask.\n          FileHead.FileAttr=0777 & ~mask;\n        }\n        else\n          if (FileHead.FileAttr & 1)  // FILE_ATTRIBUTE_READONLY\n          {\n            // For read only files we use 0444 mask with 'w' bits turned off.\n            FileHead.FileAttr=0444 & ~mask;\n          }\n          else\n          {\n            // umask does not set +x for regular files, so we use 0666\n            // instead of 0777 as for directories.\n            FileHead.FileAttr=0666 & ~mask;\n          }\n      }\n      break;\n    case HSYS_UNIX:\n      break;\n    default:\n      if (FileHead.Dir)\n        FileHead.FileAttr=0x41ff & ~mask;\n      else\n        FileHead.FileAttr=0x81b6 & ~mask;\n      break;\n  }\n#endif\n}\n\n\nvoid Archive::ConvertFileHeader(FileHeader *hd)\n{\n  if (Format==RARFMT15 && hd->UnpVer<20 && (hd->FileAttr & 0x10))\n    hd->Dir=true;\n  if (hd->HSType==HSYS_UNKNOWN)\n    if (hd->Dir)\n      hd->FileAttr=0x10;\n    else\n      hd->FileAttr=0x20;\n\n#ifdef _WIN_ALL\n  if (hd->HSType==HSYS_UNIX) // Convert Unix, OS X and Android decomposed chracters to Windows precomposed.\n    ConvertToPrecomposed(hd->FileName,ASIZE(hd->FileName));\n#endif\n\n  for (wchar *s=hd->FileName;*s!=0;s++)\n  {\n#ifdef _UNIX\n    // Backslash is the invalid character for Windows file headers,\n    // but it can present in Unix file names extracted in Unix.\n    if (*s=='\\\\' && Format==RARFMT50 && hd->HSType==HSYS_WINDOWS)\n      *s='_';\n#endif\n\n#if defined(_WIN_ALL) || defined(_EMX)\n    // RAR 5.0 archives do not use '\\' as path separator, so if we see it,\n    // it means that it is a part of Unix file name, which we cannot\n    // extract in Windows.\n    if (*s=='\\\\' && Format==RARFMT50)\n      *s='_';\n\n    // ':' in file names is allowed in Unix, but not in Windows.\n    // Even worse, file data will be written to NTFS stream on NTFS,\n    // so automatic name correction on file create error in extraction \n    // routine does not work. In Windows and DOS versions we better \n    // replace ':' now.\n    if (*s==':')\n      *s='_';\n#endif\n\n    // This code must be performed only after other path separator checks,\n    // because it produces backslashes illegal for some of checks above.\n    // Backslash is allowed in file names in Unix, but not in Windows.\n    // Still, RAR 4.x uses backslashes as path separator even in Unix.\n    // Forward slash is not allowed in both systems. In RAR 5.0 we use\n    // the forward slash as universal path separator.\n    if (*s=='/' || *s=='\\\\' && Format!=RARFMT50)\n      *s=CPATHDIVIDER;\n  }\n}\n\n\nint64 Archive::GetStartPos()\n{\n  int64 StartPos=SFXSize+MarkHead.HeadSize;\n  if (Format==RARFMT15)\n    StartPos+=MainHead.HeadSize;\n  else // RAR 5.0.\n    StartPos+=CryptHead.HeadSize+FullHeaderSize(MainHead.HeadSize);\n  return StartPos;\n}\n\n\n#ifndef SHELL_EXT\nbool Archive::ReadSubData(Array<byte> *UnpData,File *DestFile)\n{\n  if (BrokenHeader)\n  {\n    uiMsg(UIERROR_SUBHEADERBROKEN,FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return false;\n  }\n  if (SubHead.Method>5 || SubHead.UnpVer>(Format==RARFMT50 ? VER_UNPACK5:VER_UNPACK))\n  {\n    uiMsg(UIERROR_SUBHEADERUNKNOWN,FileName);\n    return false;\n  }\n\n  if (SubHead.PackSize==0 && !SubHead.SplitAfter)\n    return true;\n\n  SubDataIO.Init();\n  Unpack Unpack(&SubDataIO);\n  Unpack.Init(SubHead.WinSize,false);\n\n  if (DestFile==NULL)\n  {\n    if (SubHead.UnpSize>0x1000000)\n    {\n      // So huge allocation must never happen in valid archives.\n      uiMsg(UIERROR_SUBHEADERUNKNOWN,FileName);\n      return false;\n    }\n    if (UnpData==NULL)\n      SubDataIO.SetTestMode(true);\n    else\n    {\n      UnpData->Alloc((size_t)SubHead.UnpSize);\n      SubDataIO.SetUnpackToMemory(&(*UnpData)[0],(uint)SubHead.UnpSize);\n    }\n  }\n  if (SubHead.Encrypted)\n    if (Cmd->Password.IsSet())\n      SubDataIO.SetEncryption(false,SubHead.CryptMethod,&Cmd->Password,\n                SubHead.SaltSet ? SubHead.Salt:NULL,SubHead.InitV,\n                SubHead.Lg2Count,SubHead.HashKey,SubHead.PswCheck);\n    else\n      return false;\n  SubDataIO.UnpHash.Init(SubHead.FileHash.Type,1);\n  SubDataIO.SetPackedSizeToRead(SubHead.PackSize);\n  SubDataIO.EnableShowProgress(false);\n  SubDataIO.SetFiles(this,DestFile);\n  SubDataIO.UnpVolume=SubHead.SplitAfter;\n  SubDataIO.SetSubHeader(&SubHead,NULL);\n  Unpack.SetDestSize(SubHead.UnpSize);\n  if (SubHead.Method==0)\n    CmdExtract::UnstoreFile(SubDataIO,SubHead.UnpSize);\n  else\n    Unpack.DoUnpack(SubHead.UnpVer,false);\n\n  if (!SubDataIO.UnpHash.Cmp(&SubHead.FileHash,SubHead.UseHashKey ? SubHead.HashKey:NULL))\n  {\n    uiMsg(UIERROR_SUBHEADERDATABROKEN,FileName,SubHead.FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    if (UnpData!=NULL)\n      UnpData->Reset();\n    return false;\n  }\n  return true;\n}\n#endif\n","#include \"rar.hpp\"\n#define MBFUNCTIONS\n\n#if defined(_UNIX) && defined(MBFUNCTIONS)\n\nstatic bool WideToCharMap(const wchar *Src,char *Dest,size_t DestSize,bool &Success);\nstatic void CharToWideMap(const char *Src,wchar *Dest,size_t DestSize,bool &Success);\n\n// In Unix we map high ASCII characters which cannot be converted to Unicode\n// to 0xE000 - 0xE0FF private use Unicode area.\nstatic const uint MapAreaStart=0xE000;\n\n// Mapped string marker. Initially we used 0xFFFF for this purpose,\n// but it causes MSVC2008 swprintf to fail (it treats 0xFFFF as error marker).\n// While we could workaround it, it is safer to use another character.\nstatic const uint MappedStringMark=0xFFFE;\n\n#endif\n\nbool WideToChar(const wchar *Src,char *Dest,size_t DestSize)\n{\n  bool RetCode=true;\n  *Dest=0; // Set 'Dest' to zero just in case the conversion will fail.\n\n#ifdef _WIN_ALL\n  if (WideCharToMultiByte(CP_ACP,0,Src,-1,Dest,(int)DestSize,NULL,NULL)==0)\n    RetCode=false;\n\n// wcstombs is broken in Android NDK r9.\n#elif defined(_APPLE) || defined(_ANDROID)\n  WideToUtf(Src,Dest,DestSize);\n\n#elif defined(MBFUNCTIONS)\n  if (!WideToCharMap(Src,Dest,DestSize,RetCode))\n  {\n    mbstate_t ps; // Use thread safe external state based functions.\n    memset (&ps, 0, sizeof(ps));\n    const wchar *SrcParam=Src; // wcsrtombs can change the pointer.\n    size_t ResultingSize=wcsrtombs(Dest,&SrcParam,DestSize,&ps);\n    if (ResultingSize==(size_t)-1)\n      RetCode=false;\n    if (ResultingSize==0 && *Src!=0)\n      RetCode=false;\n  }\n#else\n  for (int I=0;I<DestSize;I++)\n  {\n    Dest[I]=(char)Src[I];\n    if (Src[I]==0)\n      break;\n  }\n#endif\n  if (DestSize>0)\n    Dest[DestSize-1]=0;\n  \n  // We tried to return the empty string if conversion is failed,\n  // but it does not work well. WideCharToMultiByte returns 'failed' code\n  // and partially converted string even if we wanted to convert only a part\n  // of string and passed DestSize smaller than required for fully converted\n  // string. Such call is the valid behavior in RAR code and we do not expect\n  // the empty string in this case.\n\n  return RetCode;\n}\n\n\nbool CharToWide(const char *Src,wchar *Dest,size_t DestSize)\n{\n  bool RetCode=true;\n  *Dest=0; // Set 'Dest' to zero just in case the conversion will fail.\n\n#ifdef _WIN_ALL\n  if (MultiByteToWideChar(CP_ACP,0,Src,-1,Dest,(int)DestSize)==0)\n    RetCode=false;\n\n// mbstowcs is broken in Android NDK r9.\n#elif defined(_APPLE) || defined(_ANDROID)\n  UtfToWide(Src,Dest,DestSize);\n\n#elif defined(MBFUNCTIONS)\n  mbstate_t ps;\n  memset (&ps, 0, sizeof(ps));\n  const char *SrcParam=Src; // mbsrtowcs can change the pointer.\n  size_t ResultingSize=mbsrtowcs(Dest,&SrcParam,DestSize,&ps);\n  if (ResultingSize==(size_t)-1)\n    RetCode=false;\n  if (ResultingSize==0 && *Src!=0)\n    RetCode=false;\n\n  if (RetCode==false && DestSize>1)\n    CharToWideMap(Src,Dest,DestSize,RetCode);\n#else\n  for (int I=0;I<DestSize;I++)\n  {\n    Dest[I]=(wchar_t)Src[I];\n    if (Src[I]==0)\n      break;\n  }\n#endif\n  if (DestSize>0)\n    Dest[DestSize-1]=0;\n\n  // We tried to return the empty string if conversion is failed,\n  // but it does not work well. MultiByteToWideChar returns 'failed' code\n  // even if we wanted to convert only a part of string and passed DestSize\n  // smaller than required for fully converted string. Such call is the valid\n  // behavior in RAR code and we do not expect the empty string in this case.\n\n  return RetCode;\n}\n\n\n#if defined(_UNIX) && defined(MBFUNCTIONS) && !defined(_ANDROID)\n// Convert and restore mapped inconvertible Unicode characters. \n// We use it for extended ASCII names in Unix.\nbool WideToCharMap(const wchar *Src,char *Dest,size_t DestSize,bool &Success)\n{\n  // String with inconvertible characters mapped to private use Unicode area\n  // must have the mark code somewhere.\n  if (wcschr(Src,(wchar)MappedStringMark)==NULL)\n    return false;\n\n  Success=true;\n  uint SrcPos=0,DestPos=0;\n  while (DestPos<DestSize-MB_CUR_MAX)\n  {\n    if (Src[SrcPos]==0)\n    {\n      Dest[DestPos]=0;\n      break;\n    }\n    if (uint(Src[SrcPos])==MappedStringMark)\n    {\n      SrcPos++;\n      continue;\n    }\n    // For security reasons do not retore low ASCII codes, so mapping cannot\n    // be used to hide control codes like path separators.\n    if (uint(Src[SrcPos])>=MapAreaStart+0x80 && uint(Src[SrcPos])<MapAreaStart+0x100)\n      Dest[DestPos++]=char(uint(Src[SrcPos++])-MapAreaStart);\n    else\n    {\n      mbstate_t ps;\n      memset(&ps,0,sizeof(ps));\n      if (wcrtomb(Dest+DestPos,Src[SrcPos],&ps)==-1)\n        Success=false;\n      SrcPos++;\n      memset(&ps,0,sizeof(ps));\n      int Length=mbrlen(Dest+DestPos,MB_CUR_MAX,&ps);\n      DestPos+=Max(Length,1);\n    }\n  }\n  return true;\n}\n#endif\n\n\n#if defined(_UNIX) && defined(MBFUNCTIONS) && !defined(_ANDROID)\n// Convert and map inconvertible Unicode characters. \n// We use it for extended ASCII names in Unix.\nvoid CharToWideMap(const char *Src,wchar *Dest,size_t DestSize,bool &Success)\n{\n  // Map inconvertible characters to private use Unicode area 0xE000.\n  // Mark such string by placing special non-character code before\n  // first inconvertible character.\n  Success=false;\n  bool MarkAdded=false;\n  uint SrcPos=0,DestPos=0;\n  while (DestPos<DestSize)\n  {\n    if (Src[SrcPos]==0)\n    {\n      Dest[DestPos]=0;\n      Success=true;\n      break;\n    }\n    mbstate_t ps;\n    memset(&ps,0,sizeof(ps));\n    if (mbrtowc(Dest+DestPos,Src+SrcPos,MB_CUR_MAX,&ps)==-1)\n    {\n      // For security reasons we do not want to map low ASCII characters,\n      // so we do not have additional .. and path separator codes.\n      if (byte(Src[SrcPos])>=0x80)\n      {\n        if (!MarkAdded)\n        {\n          Dest[DestPos++]=MappedStringMark;\n          MarkAdded=true;\n          if (DestPos>=DestSize)\n            break;\n        }\n        Dest[DestPos++]=byte(Src[SrcPos++])+MapAreaStart;\n      }\n      else\n        break;\n    }\n    else\n    {\n      memset(&ps,0,sizeof(ps));\n      int Length=mbrlen(Src+SrcPos,MB_CUR_MAX,&ps);\n      SrcPos+=Max(Length,1);\n      DestPos++;\n    }\n  }\n}\n#endif\n\n\n// SrcSize is in wide characters, not in bytes.\nbyte* WideToRaw(const wchar *Src,byte *Dest,size_t SrcSize)\n{\n  for (size_t I=0;I<SrcSize;I++,Src++)\n  {\n    Dest[I*2]=(byte)*Src;\n    Dest[I*2+1]=(byte)(*Src>>8);\n    if (*Src==0)\n      break;\n  }\n  return Dest;\n}\n\n\nwchar* RawToWide(const byte *Src,wchar *Dest,size_t DestSize)\n{\n  for (size_t I=0;I<DestSize;I++)\n    if ((Dest[I]=Src[I*2]+(Src[I*2+1]<<8))==0)\n      break;\n  return Dest;\n}\n\n\nvoid WideToUtf(const wchar *Src,char *Dest,size_t DestSize)\n{\n  long dsize=(long)DestSize;\n  dsize--;\n  while (*Src!=0 && --dsize>=0)\n  {\n    uint c=*(Src++);\n    if (c<0x80)\n      *(Dest++)=c;\n    else\n      if (c<0x800 && --dsize>=0)\n      {\n        *(Dest++)=(0xc0|(c>>6));\n        *(Dest++)=(0x80|(c&0x3f));\n      }\n      else\n      {\n        if (c>=0xd800 && c<=0xdbff && *Src>=0xdc00 && *Src<=0xdfff) // Surrogate pair.\n        {\n          c=((c-0xd800)<<10)+(*Src-0xdc00)+0x10000;\n          Src++;\n        }\n        if (c<0x10000 && (dsize-=2)>=0)\n        {\n          *(Dest++)=(0xe0|(c>>12));\n          *(Dest++)=(0x80|((c>>6)&0x3f));\n          *(Dest++)=(0x80|(c&0x3f));\n        }\n        else\n          if (c < 0x200000 && (dsize-=3)>=0)\n          {\n            *(Dest++)=(0xf0|(c>>18));\n            *(Dest++)=(0x80|((c>>12)&0x3f));\n            *(Dest++)=(0x80|((c>>6)&0x3f));\n            *(Dest++)=(0x80|(c&0x3f));\n          }\n      }\n  }\n  *Dest=0;\n}\n\n\nsize_t WideToUtfSize(const wchar *Src)\n{\n  size_t Size=0;\n  for (;*Src!=0;Src++)\n    if (*Src<0x80)\n      Size++;\n    else\n      if (*Src<0x800)\n        Size+=2;\n      else\n        if (*Src<0x10000)\n        {\n          if (Src[0]>=0xd800 && Src[0]<=0xdbff && Src[1]>=0xdc00 && Src[1]<=0xdfff)\n          {\n            Size+=4; // 4 output bytes for Unicode surrogate pair.\n            Src++;\n          }\n          else\n            Size+=3;\n        }\n        else\n          if (*Src<0x200000)\n            Size+=4;\n  return Size+1; // Include terminating zero.\n}\n\n\n// Dest can be NULL if we only need to check validity of Src.\nbool UtfToWide(const char *Src,wchar *Dest,size_t DestSize)\n{\n  bool Success=true;\n  long dsize=(long)DestSize;\n  dsize--;\n  while (*Src!=0)\n  {\n    uint c=byte(*(Src++)),d;\n    if (c<0x80)\n      d=c;\n    else\n      if ((c>>5)==6)\n      {\n        if ((*Src&0xc0)!=0x80)\n        {\n          Success=false;\n          break;\n        }\n        d=((c&0x1f)<<6)|(*Src&0x3f);\n        Src++;\n      }\n      else\n        if ((c>>4)==14)\n        {\n          if ((Src[0]&0xc0)!=0x80 || (Src[1]&0xc0)!=0x80)\n          {\n            Success=false;\n            break;\n          }\n          d=((c&0xf)<<12)|((Src[0]&0x3f)<<6)|(Src[1]&0x3f);\n          Src+=2;\n        }\n        else\n          if ((c>>3)==30)\n          {\n            if ((Src[0]&0xc0)!=0x80 || (Src[1]&0xc0)!=0x80 || (Src[2]&0xc0)!=0x80)\n            {\n              Success=false;\n              break;\n            }\n            d=((c&7)<<18)|((Src[0]&0x3f)<<12)|((Src[1]&0x3f)<<6)|(Src[2]&0x3f);\n            Src+=3;\n          }\n          else\n          {\n            Success=false;\n            break;\n          }\n    if (Dest!=NULL && --dsize<0)\n      break;\n    if (d>0xffff)\n    {\n      if (Dest!=NULL && --dsize<0)\n        break;\n      if (d>0x10ffff) // UTF-8 must end at 0x10ffff according to RFC 3629.\n      {\n        Success=false;\n        continue;\n      }\n      if (Dest!=NULL)\n        if (sizeof(*Dest)==2) // Use the surrogate pair.\n        {\n          *(Dest++)=((d-0x10000)>>10)+0xd800;\n          *(Dest++)=(d&0x3ff)+0xdc00;\n        }\n        else\n          *(Dest++)=d;\n    }\n    else\n      if (Dest!=NULL)\n        *(Dest++)=d;\n  }\n  if (Dest!=NULL)\n    *Dest=0;\n  return Success;\n}\n\n\nint wcsicomp(const wchar *s1,const wchar *s2)\n{\n#ifdef _WIN_ALL\n  return CompareString(LOCALE_USER_DEFAULT,NORM_IGNORECASE|SORT_STRINGSORT,s1,-1,s2,-1)-2;\n#else\n  while (true)\n  {\n    wchar u1 = towupper(*s1);\n    wchar u2 = towupper(*s2);\n    if (u1 != u2)\n      return u1 < u2 ? -1 : 1;\n    if (*s1==0)\n      break;\n    s1++;\n    s2++;\n  }\n  return 0;\n#endif\n}\n\n\nint wcsnicomp(const wchar *s1,const wchar *s2,size_t n)\n{\n#ifdef _WIN_ALL\n  // If we specify 'n' exceeding the actual string length, CompareString goes\n  // beyond the trailing zero and compares garbage. So we need to limit 'n'\n  // to real string length.\n  size_t l1=Min(wcslen(s1)+1,n);\n  size_t l2=Min(wcslen(s2)+1,n);\n  return CompareStringW(LOCALE_USER_DEFAULT,NORM_IGNORECASE|SORT_STRINGSORT,s1,(int)l1,s2,(int)l2)-2;\n#else\n  if (n==0)\n    return 0;\n  while (true)\n  {\n    wchar u1 = towupper(*s1);\n    wchar u2 = towupper(*s2);\n    if (u1 != u2)\n      return u1 < u2 ? -1 : 1;\n    if (*s1==0 || --n==0)\n      break;\n    s1++;\n    s2++;\n  }\n  return 0;\n#endif\n}\n\n\nconst wchar_t* wcscasestr(const wchar_t *str, const wchar_t *search)\n{\n  for (size_t i=0;str[i]!=0;i++)\n    for (size_t j=0;;j++)\n    {\n      if (search[j]==0)\n        return str+i;\n      if (tolowerw(str[i+j])!=tolowerw(search[j]))\n        break;\n    }\n  return NULL;\n}\n\n\n#ifndef SFX_MODULE\nwchar* wcslower(wchar *s)\n{\n#ifdef _WIN_ALL\n  CharLower(s);\n#else\n  for (wchar *c=s;*c!=0;c++)\n    *c=towlower(*c);\n#endif\n  return s;\n}\n#endif\n\n\n#ifndef SFX_MODULE\nwchar* wcsupper(wchar *s)\n{\n#ifdef _WIN_ALL\n  CharUpper(s);\n#else\n  for (wchar *c=s;*c!=0;c++)\n    *c=towupper(*c);\n#endif\n  return s;\n}\n#endif\n\n\n\n\nint toupperw(int ch)\n{\n#ifdef _WIN_ALL\n  // CharUpper is more reliable than towupper in Windows, which seems to be\n  // C locale dependent even in Unicode version. For example, towupper failed\n  // to convert lowercase Russian characters.\n  return (int)(INT_PTR)CharUpper((wchar *)(INT_PTR)ch);\n#else\n  return towupper(ch);\n#endif\n}\n\n\nint tolowerw(int ch)\n{\n#ifdef _WIN_ALL\n  // CharLower is more reliable than towlower in Windows.\n  // See comment for towupper above.\n  return (int)(INT_PTR)CharLower((wchar *)(INT_PTR)ch);\n#else\n  return towlower(ch);\n#endif\n}\n\n\nint atoiw(const wchar *s)\n{\n  return (int)atoilw(s);\n}\n\n\nint64 atoilw(const wchar *s)\n{\n  int sign=1;\n  if (*s=='-')\n  {\n    s++;\n    sign=-1;\n  }\n  int64 n=0;\n  while (*s>='0' && *s<='9')\n  {\n    n=n*10+(*s-'0');\n    s++;\n  }\n  return sign*n;\n}\n\n\n#ifdef DBCS_SUPPORTED\nSupportDBCS gdbcs;\n\nSupportDBCS::SupportDBCS()\n{\n  Init();\n}\n\n\nvoid SupportDBCS::Init()\n{\n  CPINFO CPInfo;\n  GetCPInfo(CP_ACP,&CPInfo);\n  DBCSMode=CPInfo.MaxCharSize > 1;\n  for (uint I=0;I<ASIZE(IsLeadByte);I++)\n    IsLeadByte[I]=IsDBCSLeadByte(I)!=0;\n}\n\n\nchar* SupportDBCS::charnext(const char *s)\n{\n  // Zero cannot be the trail byte. So if next byte after the lead byte\n  // is 0, the string is corrupt and we'll better return the pointer to 0,\n  // to break string processing loops.\n  return (char *)(IsLeadByte[(byte)*s] && s[1]!=0 ? s+2:s+1);\n}\n\n\nsize_t SupportDBCS::strlend(const char *s)\n{\n  size_t Length=0;\n  while (*s!=0)\n  {\n    if (IsLeadByte[(byte)*s])\n      s+=2;\n    else\n      s++;\n    Length++;\n  }\n  return(Length);\n}\n\n\nchar* SupportDBCS::strchrd(const char *s, int c)\n{\n  while (*s!=0)\n    if (IsLeadByte[(byte)*s])\n      s+=2;\n    else\n      if (*s==c)\n        return((char *)s);\n      else\n        s++;\n  return(NULL);\n}\n\n\nvoid SupportDBCS::copychrd(char *dest,const char *src)\n{\n  dest[0]=src[0];\n  if (IsLeadByte[(byte)src[0]])\n    dest[1]=src[1];\n}\n\n\nchar* SupportDBCS::strrchrd(const char *s, int c)\n{\n  const char *found=NULL;\n  while (*s!=0)\n    if (IsLeadByte[(byte)*s])\n      s+=2;\n    else\n    {\n      if (*s==c)\n        found=s;\n      s++;\n    }\n  return((char *)found);\n}\n#endif\n","#include \"rar.hpp\"\n\nstatic int SleepTime=0;\n\nvoid InitSystemOptions(int SleepTime)\n{\n  ::SleepTime=SleepTime;\n}\n\n\n#if !defined(SFX_MODULE) && !defined(SETUP)\nvoid SetPriority(int Priority)\n{\n#ifdef _WIN_ALL\n  uint PriorityClass;\n  int PriorityLevel;\n  if (Priority<1 || Priority>15)\n    return;\n\n  if (Priority==1)\n  {\n    PriorityClass=IDLE_PRIORITY_CLASS;\n    PriorityLevel=THREAD_PRIORITY_IDLE;\n\n//  Background mode for Vista, can be slow for many small files.\n//    if (WinNT()>=WNT_VISTA)\n//      SetPriorityClass(GetCurrentProcess(),PROCESS_MODE_BACKGROUND_BEGIN);\n  }\n  else\n    if (Priority<7)\n    {\n      PriorityClass=IDLE_PRIORITY_CLASS;\n      PriorityLevel=Priority-4;\n    }\n    else\n      if (Priority==7)\n      {\n        PriorityClass=BELOW_NORMAL_PRIORITY_CLASS;\n        PriorityLevel=THREAD_PRIORITY_ABOVE_NORMAL;\n      }\n      else\n        if (Priority<10)\n        {\n          PriorityClass=NORMAL_PRIORITY_CLASS;\n          PriorityLevel=Priority-7;\n        }\n        else\n          if (Priority==10)\n          {\n            PriorityClass=ABOVE_NORMAL_PRIORITY_CLASS;\n            PriorityLevel=THREAD_PRIORITY_NORMAL;\n          }\n          else\n          {\n            PriorityClass=HIGH_PRIORITY_CLASS;\n            PriorityLevel=Priority-13;\n          }\n  SetPriorityClass(GetCurrentProcess(),PriorityClass);\n  SetThreadPriority(GetCurrentThread(),PriorityLevel);\n\n#ifdef RAR_SMP\n  ThreadPool::SetPriority(PriorityLevel);\n#endif\n\n#endif\n}\n#endif\n\n\n// Monotonic clock. Like clock(), returns time passed in CLOCKS_PER_SEC items.\n// In Android 5+ and Unix usual clock() returns time spent by all threads\n// together, so we cannot use it to measure time intervals anymore.\nclock_t MonoClock()\n{\n#if defined(_ANDROID) && defined(_UNIX) && defined(CLOCK_MONOTONIC)\n  struct timespec CurTime;\n  clock_gettime(CLOCK_MONOTONIC, &CurTime);\n  int64 nsec = int64(CurTime.tv_sec)*1000000000 + CurTime.tv_nsec;\n  nsec /= 1000000000 / CLOCKS_PER_SEC;\n  return (clock_t)nsec;\n#else\n  return clock();\n#endif\n}\n\n\n\n#ifndef SETUP\nvoid Wait()\n{\n  if (ErrHandler.UserBreak)\n    ErrHandler.Exit(RARX_USERBREAK);\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n  if (SleepTime!=0)\n  {\n    static clock_t LastTime=MonoClock();\n    if (MonoClock()-LastTime>10*CLOCKS_PER_SEC/1000)\n    {\n      Sleep(SleepTime);\n      LastTime=MonoClock();\n    }\n  }\n#endif\n#ifdef _WIN_ALL\n  // Reset system sleep timer to prevent system going sleep.\n  SetThreadExecutionState(ES_SYSTEM_REQUIRED);\n#endif\n}\n#endif\n\n\n\n\n#if defined(_WIN_ALL) && !defined(SFX_MODULE) && !defined(SHELL_EXT) && !defined(SETUP)\nvoid Shutdown()\n{\n  HANDLE hToken;\n  TOKEN_PRIVILEGES tkp;\n  if (OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,&hToken))\n  {\n    LookupPrivilegeValue(NULL,SE_SHUTDOWN_NAME,&tkp.Privileges[0].Luid);\n    tkp.PrivilegeCount = 1;\n    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\n\n    AdjustTokenPrivileges(hToken,FALSE,&tkp,0,(PTOKEN_PRIVILEGES)NULL,0);\n  }\n  ExitWindowsEx(EWX_SHUTDOWN|EWX_FORCE|EWX_POWEROFF,SHTDN_REASON_FLAG_PLANNED);\n}\n#endif\n\n\n\n\n#ifdef _WIN_ALL\n// Load library from Windows System32 folder. Use this function to prevent\n// loading a malicious code from current folder or same folder as exe.\nHMODULE WINAPI LoadSysLibrary(const wchar *Name)\n{\n  wchar SysDir[NM];\n  if (GetSystemDirectory(SysDir,ASIZE(SysDir))==0)\n    return NULL;\n  MakeName(SysDir,Name,SysDir,ASIZE(SysDir));\n  return LoadLibrary(SysDir);\n}\n#endif\n\n\n#ifdef USE_SSE\nSSE_VERSION _SSE_Version=GetSSEVersion();\n\nSSE_VERSION GetSSEVersion()\n{\n  int CPUInfo[4];\n  __cpuid(CPUInfo, 1);\n  if ((CPUInfo[2] & 0x80000)!=0)\n    return SSE_SSE41;\n  if ((CPUInfo[2] & 0x200)!=0)\n    return SSE_SSSE3;\n  if ((CPUInfo[3] & 0x4000000)!=0)\n    return SSE_SSE2;\n  if ((CPUInfo[3] & 0x2000000)!=0)\n    return SSE_SSE;\n  return SSE_NONE;\n}\n#endif\n","extern uint CRCTab[256];\n\n#define  rol(x,n,xsize)  (((x)<<(n)) | ((x)>>(xsize-(n))))\n#define  ror(x,n,xsize)  (((x)>>(n)) | ((x)<<(xsize-(n))))\n\nvoid CryptData::SetKey13(const char *Password)\n{\n  Key13[0]=Key13[1]=Key13[2]=0;\n  for (size_t I=0;Password[I]!=0;I++)\n  {\n    byte P=Password[I];\n    Key13[0]+=P;\n    Key13[1]^=P;\n    Key13[2]+=P;\n    Key13[2]=(byte)rol(Key13[2],1,8);\n  }\n}\n\n\nvoid CryptData::SetKey15(const char *Password)\n{\n  InitCRC32(CRCTab);\n  uint PswCRC=CRC32(0xffffffff,Password,strlen(Password));\n  Key15[0]=PswCRC&0xffff;\n  Key15[1]=(PswCRC>>16)&0xffff;\n  Key15[2]=Key15[3]=0;\n  for (size_t I=0;Password[I]!=0;I++)\n  {\n    byte P=Password[I];\n    Key15[2]^=P^CRCTab[P];\n    Key15[3]+=P+(CRCTab[P]>>16);\n  }\n}\n\n\nvoid CryptData::SetAV15Encryption()\n{\n  InitCRC32(CRCTab);\n  Method=CRYPT_RAR15;\n  Key15[0]=0x4765;\n  Key15[1]=0x9021;\n  Key15[2]=0x7382;\n  Key15[3]=0x5215;\n}\n\n\nvoid CryptData::SetCmt13Encryption()\n{\n  Method=CRYPT_RAR13;\n  Key13[0]=0;\n  Key13[1]=7;\n  Key13[2]=77;\n}\n\n\nvoid CryptData::Decrypt13(byte *Data,size_t Count)\n{\n  while (Count--)\n  {\n    Key13[1]+=Key13[2];\n    Key13[0]+=Key13[1];\n    *Data-=Key13[0];\n    Data++;\n  }\n}\n\n\nvoid CryptData::Crypt15(byte *Data,size_t Count)\n{\n  while (Count--)\n  {\n    Key15[0]+=0x1234;\n    Key15[1]^=CRCTab[(Key15[0] & 0x1fe)>>1];\n    Key15[2]-=CRCTab[(Key15[0] & 0x1fe)>>1]>>16;\n    Key15[0]^=Key15[2];\n    Key15[3]=ror(Key15[3]&0xffff,1,16)^Key15[1];\n    Key15[3]=ror(Key15[3]&0xffff,1,16);\n    Key15[0]^=Key15[3];\n    *Data^=(byte)(Key15[0]>>8);\n    Data++;\n  }\n}\n","#define NROUNDS 32\n\n#define substLong(t) ( (uint)SubstTable20[(uint)t&255] | \\\n           ((uint)SubstTable20[(int)(t>> 8)&255]<< 8) | \\\n           ((uint)SubstTable20[(int)(t>>16)&255]<<16) | \\\n           ((uint)SubstTable20[(int)(t>>24)&255]<<24) )\n\n\nstatic byte InitSubstTable20[256]={\n  215, 19,149, 35, 73,197,192,205,249, 28, 16,119, 48,221,  2, 42,\n  232,  1,177,233, 14, 88,219, 25,223,195,244, 90, 87,239,153,137,\n  255,199,147, 70, 92, 66,246, 13,216, 40, 62, 29,217,230, 86,  6,\n   71, 24,171,196,101,113,218,123, 93, 91,163,178,202, 67, 44,235,\n  107,250, 75,234, 49,167,125,211, 83,114,157,144, 32,193,143, 36,\n  158,124,247,187, 89,214,141, 47,121,228, 61,130,213,194,174,251,\n   97,110, 54,229,115, 57,152, 94,105,243,212, 55,209,245, 63, 11,\n  164,200, 31,156, 81,176,227, 21, 76, 99,139,188,127, 17,248, 51,\n  207,120,189,210,  8,226, 41, 72,183,203,135,165,166, 60, 98,  7,\n  122, 38,155,170, 69,172,252,238, 39,134, 59,128,236, 27,240, 80,\n  131,  3, 85,206,145, 79,154,142,159,220,201,133, 74, 64, 20,129,\n  224,185,138,103,173,182, 43, 34,254, 82,198,151,231,180, 58, 10,\n  118, 26,102, 12, 50,132, 22,191,136,111,162,179, 45,  4,148,108,\n  161, 56, 78,126,242,222, 15,175,146, 23, 33,241,181,190, 77,225,\n    0, 46,169,186, 68, 95,237, 65, 53,208,253,168,  9, 18,100, 52,\n  116,184,160, 96,109, 37, 30,106,140,104,150,  5,204,117,112, 84\n};\n\n\nvoid CryptData::SetKey20(const char *Password)\n{\n  InitCRC32(CRCTab);\n\n  char Psw[MAXPASSWORD];\n  strncpyz(Psw,Password,ASIZE(Psw)); // We'll need to modify it below.\n  size_t PswLength=strlen(Psw);\n\n  Key20[0]=0xD3A3B879L;\n  Key20[1]=0x3F6D12F7L;\n  Key20[2]=0x7515A235L;\n  Key20[3]=0xA4E7F123L;\n\n  memcpy(SubstTable20,InitSubstTable20,sizeof(SubstTable20));\n  for (int J=0;J<256;J++)\n    for (size_t I=0;I<PswLength;I+=2)\n    {\n      uint N1=(byte)CRCTab [ (byte(Password[I])   - J) &0xff];\n      uint N2=(byte)CRCTab [ (byte(Password[I+1]) + J) &0xff];\n      for (int K=1;N1!=N2;N1=(N1+1)&0xff,K++)\n        Swap20(&SubstTable20[N1],&SubstTable20[(N1+I+K)&0xff]);\n    }\n  \n  // Incomplete last block of password must be zero padded.\n  if ((PswLength & CRYPT_BLOCK_MASK)!=0)\n    for (size_t I=PswLength;I<=(PswLength|CRYPT_BLOCK_MASK);I++)\n       Psw[I]=0;\n\n  for (size_t I=0;I<PswLength;I+=CRYPT_BLOCK_SIZE)\n    EncryptBlock20((byte *)Psw+I);\n}\n\n\nvoid CryptData::EncryptBlock20(byte *Buf)\n{\n  uint A,B,C,D,T,TA,TB;\n#if defined(BIG_ENDIAN) || !defined(PRESENT_INT32) || !defined(ALLOW_MISALIGNED)\n  A=((uint)Buf[0]|((uint)Buf[1]<<8)|((uint)Buf[2]<<16)|((uint)Buf[3]<<24))^Key20[0];\n  B=((uint)Buf[4]|((uint)Buf[5]<<8)|((uint)Buf[6]<<16)|((uint)Buf[7]<<24))^Key20[1];\n  C=((uint)Buf[8]|((uint)Buf[9]<<8)|((uint)Buf[10]<<16)|((uint)Buf[11]<<24))^Key20[2];\n  D=((uint)Buf[12]|((uint)Buf[13]<<8)|((uint)Buf[14]<<16)|((uint)Buf[15]<<24))^Key20[3];\n#else\n  uint32 *BufPtr=(uint32 *)Buf;\n  A=BufPtr[0]^Key20[0];\n  B=BufPtr[1]^Key20[1];\n  C=BufPtr[2]^Key20[2];\n  D=BufPtr[3]^Key20[3];\n#endif\n  for(int I=0;I<NROUNDS;I++)\n  {\n    T=((C+rol(D,11,32))^Key20[I&3]);\n    TA=A^substLong(T);\n    T=((D^rol(C,17,32))+Key20[I&3]);\n    TB=B^substLong(T);\n    A=C;\n    B=D;\n    C=TA;\n    D=TB;\n  }\n#if defined(BIG_ENDIAN) || !defined(PRESENT_INT32) || !defined(ALLOW_MISALIGNED)\n  C^=Key20[0];\n  Buf[0]=(byte)C;\n  Buf[1]=(byte)(C>>8);\n  Buf[2]=(byte)(C>>16);\n  Buf[3]=(byte)(C>>24);\n  D^=Key20[1];\n  Buf[4]=(byte)D;\n  Buf[5]=(byte)(D>>8);\n  Buf[6]=(byte)(D>>16);\n  Buf[7]=(byte)(D>>24);\n  A^=Key20[2];\n  Buf[8]=(byte)A;\n  Buf[9]=(byte)(A>>8);\n  Buf[10]=(byte)(A>>16);\n  Buf[11]=(byte)(A>>24);\n  B^=Key20[3];\n  Buf[12]=(byte)B;\n  Buf[13]=(byte)(B>>8);\n  Buf[14]=(byte)(B>>16);\n  Buf[15]=(byte)(B>>24);\n#else\n  BufPtr[0]=C^Key20[0];\n  BufPtr[1]=D^Key20[1];\n  BufPtr[2]=A^Key20[2];\n  BufPtr[3]=B^Key20[3];\n#endif\n  UpdKeys20(Buf);\n}\n\n\nvoid CryptData::DecryptBlock20(byte *Buf)\n{\n  byte InBuf[16];\n  uint A,B,C,D,T,TA,TB;\n#if defined(BIG_ENDIAN) || !defined(PRESENT_INT32) || !defined(ALLOW_MISALIGNED)\n  A=((uint)Buf[0]|((uint)Buf[1]<<8)|((uint)Buf[2]<<16)|((uint)Buf[3]<<24))^Key20[0];\n  B=((uint)Buf[4]|((uint)Buf[5]<<8)|((uint)Buf[6]<<16)|((uint)Buf[7]<<24))^Key20[1];\n  C=((uint)Buf[8]|((uint)Buf[9]<<8)|((uint)Buf[10]<<16)|((uint)Buf[11]<<24))^Key20[2];\n  D=((uint)Buf[12]|((uint)Buf[13]<<8)|((uint)Buf[14]<<16)|((uint)Buf[15]<<24))^Key20[3];\n#else\n  uint32 *BufPtr=(uint32 *)Buf;\n  A=BufPtr[0]^Key20[0];\n  B=BufPtr[1]^Key20[1];\n  C=BufPtr[2]^Key20[2];\n  D=BufPtr[3]^Key20[3];\n#endif\n  memcpy(InBuf,Buf,sizeof(InBuf));\n  for(int I=NROUNDS-1;I>=0;I--)\n  {\n    T=((C+rol(D,11,32))^Key20[I&3]);\n    TA=A^substLong(T);\n    T=((D^rol(C,17,32))+Key20[I&3]);\n    TB=B^substLong(T);\n    A=C;\n    B=D;\n    C=TA;\n    D=TB;\n  }\n#if defined(BIG_ENDIAN) || !defined(PRESENT_INT32) || !defined(ALLOW_MISALIGNED)\n  C^=Key20[0];\n  Buf[0]=(byte)C;\n  Buf[1]=(byte)(C>>8);\n  Buf[2]=(byte)(C>>16);\n  Buf[3]=(byte)(C>>24);\n  D^=Key20[1];\n  Buf[4]=(byte)D;\n  Buf[5]=(byte)(D>>8);\n  Buf[6]=(byte)(D>>16);\n  Buf[7]=(byte)(D>>24);\n  A^=Key20[2];\n  Buf[8]=(byte)A;\n  Buf[9]=(byte)(A>>8);\n  Buf[10]=(byte)(A>>16);\n  Buf[11]=(byte)(A>>24);\n  B^=Key20[3];\n  Buf[12]=(byte)B;\n  Buf[13]=(byte)(B>>8);\n  Buf[14]=(byte)(B>>16);\n  Buf[15]=(byte)(B>>24);\n#else\n  BufPtr[0]=C^Key20[0];\n  BufPtr[1]=D^Key20[1];\n  BufPtr[2]=A^Key20[2];\n  BufPtr[3]=B^Key20[3];\n#endif\n  UpdKeys20(InBuf);\n}\n\n\nvoid CryptData::UpdKeys20(byte *Buf)\n{\n  for (int I=0;I<16;I+=4)\n  {\n    Key20[0]^=CRCTab[Buf[I]];\n    Key20[1]^=CRCTab[Buf[I+1]];\n    Key20[2]^=CRCTab[Buf[I+2]];\n    Key20[3]^=CRCTab[Buf[I+3]];\n  }\n}\n\n\nvoid CryptData::Swap20(byte *Ch1,byte *Ch2)\n{\n  byte Ch=*Ch1;\n  *Ch1=*Ch2;\n  *Ch2=Ch;\n}\n","void CryptData::SetKey30(bool Encrypt,SecPassword *Password,const wchar *PwdW,const byte *Salt)\n{\n  byte AESKey[16],AESInit[16];\n\n  bool Cached=false;\n  for (uint I=0;I<ASIZE(KDF3Cache);I++)\n    if (KDF3Cache[I].Pwd==*Password &&\n        (Salt==NULL && !KDF3Cache[I].SaltPresent || Salt!=NULL &&\n        KDF3Cache[I].SaltPresent && memcmp(KDF3Cache[I].Salt,Salt,SIZE_SALT30)==0))\n    {\n      memcpy(AESKey,KDF3Cache[I].Key,sizeof(AESKey));\n      memcpy(AESInit,KDF3Cache[I].Init,sizeof(AESInit));\n      Cached=true;\n      break;\n    }\n\n  if (!Cached)\n  {\n    byte RawPsw[2*MAXPASSWORD+SIZE_SALT30];\n    WideToRaw(PwdW,RawPsw,ASIZE(RawPsw));\n    size_t RawLength=2*wcslen(PwdW);\n    if (Salt!=NULL)\n    {\n      memcpy(RawPsw+RawLength,Salt,SIZE_SALT30);\n      RawLength+=SIZE_SALT30;\n    }\n    sha1_context c;\n    sha1_init(&c);\n\n    const int HashRounds=0x40000;\n    for (int I=0;I<HashRounds;I++)\n    {\n      sha1_process( &c, RawPsw, RawLength, false);\n      byte PswNum[3];\n      PswNum[0]=(byte)I;\n      PswNum[1]=(byte)(I>>8);\n      PswNum[2]=(byte)(I>>16);\n      sha1_process( &c, PswNum, 3, false);\n      if (I%(HashRounds/16)==0)\n      {\n        sha1_context tempc=c;\n        uint32 digest[5];\n        sha1_done( &tempc, digest, false);\n        AESInit[I/(HashRounds/16)]=(byte)digest[4];\n      }\n    }\n    uint32 digest[5];\n    sha1_done( &c, digest, false);\n    for (int I=0;I<4;I++)\n      for (int J=0;J<4;J++)\n        AESKey[I*4+J]=(byte)(digest[I]>>(J*8));\n\n    KDF3Cache[KDF3CachePos].Pwd=*Password;\n    if ((KDF3Cache[KDF3CachePos].SaltPresent=(Salt!=NULL))==true)\n      memcpy(KDF3Cache[KDF3CachePos].Salt,Salt,SIZE_SALT30);\n    memcpy(KDF3Cache[KDF3CachePos].Key,AESKey,sizeof(AESKey));\n    memcpy(KDF3Cache[KDF3CachePos].Init,AESInit,sizeof(AESInit));\n    KDF3CachePos=(KDF3CachePos+1)%ASIZE(KDF3Cache);\n\n    cleandata(RawPsw,sizeof(RawPsw));\n  }\n  rin.Init(Encrypt, AESKey, 128, AESInit);\n  cleandata(AESKey,sizeof(AESKey));\n  cleandata(AESInit,sizeof(AESInit));\n}\n\n","void hmac_sha256(const byte *Key,size_t KeyLength,const byte *Data,\n                 size_t DataLength,byte *ResDigest)\n{\n  const size_t Sha256BlockSize=64; // As defined in RFC 4868.\n\n  byte KeyHash[SHA256_DIGEST_SIZE];\n  if (KeyLength > Sha256BlockSize) // Convert longer keys to key hash.\n  {\n    sha256_context KCtx;\n    sha256_init(&KCtx);\n    sha256_process(&KCtx, Key, KeyLength);\n    sha256_done(&KCtx, KeyHash);\n\n    Key = KeyHash;\n    KeyLength = SHA256_DIGEST_SIZE;\n  }\n\n  byte KeyBuf[Sha256BlockSize]; // Store the padded key here.\n  for (size_t I = 0; I < KeyLength; I++) // Use 0x36 padding for inner digest.\n    KeyBuf[I] = Key[I] ^ 0x36;\n  for (size_t I = KeyLength; I < Sha256BlockSize; I++)\n    KeyBuf[I] = 0x36;\n\n  sha256_context ICtx;\n  sha256_init(&ICtx);\n  sha256_process(&ICtx, KeyBuf, Sha256BlockSize); // Hash padded key.\n  sha256_process(&ICtx, Data, DataLength); // Hash data.\n\n  byte IDig[SHA256_DIGEST_SIZE]; // Internal digest for padded key and data.\n  sha256_done(&ICtx, IDig);\n\n  sha256_context RCtx;\n  sha256_init(&RCtx);\n\n  for (size_t I = 0; I < KeyLength; I++) // Use 0x5c for outer key padding.\n    KeyBuf[I] = Key[I] ^ 0x5c;\n  for (size_t I = KeyLength; I < Sha256BlockSize; I++)\n    KeyBuf[I] = 0x5c;\n\n  sha256_process(&RCtx, KeyBuf, Sha256BlockSize); // Hash padded key.\n  sha256_process(&RCtx, IDig, SHA256_DIGEST_SIZE); // Hash internal digest.\n\n  sha256_done(&RCtx, ResDigest);\n}\n\n\n// PBKDF2 for 32 byte key length. We generate the key for specified number\n// of iteration count also as two supplementary values (key for checksums\n// and password verification) for iterations+16 and iterations+32.\nvoid pbkdf2(const byte *Pwd, size_t PwdLength, \n            const byte *Salt, size_t SaltLength,\n            byte *Key, byte *V1, byte *V2, uint Count)\n{\n  const size_t MaxSalt=64;\n  byte SaltData[MaxSalt+4];\n\tmemcpy(SaltData, Salt, Min(SaltLength,MaxSalt));\n\n\tSaltData[SaltLength + 0] = 0; // Salt concatenated to 1.\n\tSaltData[SaltLength + 1] = 0;\n\tSaltData[SaltLength + 2] = 0;\n\tSaltData[SaltLength + 3] = 1;\n\n  // First iteration: HMAC of password, salt and block index (1).\n  byte U1[SHA256_DIGEST_SIZE];\n\thmac_sha256(Pwd, PwdLength, SaltData, SaltLength + 4, U1);\n  byte Fn[SHA256_DIGEST_SIZE]; // Current function value.\n\tmemcpy(Fn, U1, sizeof(Fn)); // Function at first iteration.\n\n  uint  CurCount[] = { Count-1, 16, 16 };\n  byte *CurValue[] = { Key    , V1, V2 };\n  \n  byte U2[SHA256_DIGEST_SIZE];\n  for (uint I = 0; I < 3; I++) // For output key and 2 supplementary values.\n  {\n  \tfor (uint J = 0; J < CurCount[I]; J++) \n    {\n      hmac_sha256(Pwd, PwdLength, U1, sizeof(U1), U2); // U2 = PRF (P, U1).\n  \t\tmemcpy(U1, U2, sizeof(U1));\n  \t\tfor (uint K = 0; K < sizeof(Fn); K++) // Function ^= U.\n  \t\t\tFn[K] ^= U1[K];\n  \t}\n  \tmemcpy(CurValue[I], Fn, SHA256_DIGEST_SIZE);\n  }\n\n\tcleandata(SaltData, sizeof(SaltData));\n  cleandata(Fn, sizeof(Fn));\n\tcleandata(U1, sizeof(U1));\n\tcleandata(U2, sizeof(U2));\n}\n\n\nvoid CryptData::SetKey50(bool Encrypt,SecPassword *Password,const wchar *PwdW,\n     const byte *Salt,const byte *InitV,uint Lg2Cnt,byte *HashKey,\n     byte *PswCheck)\n{\n  if (Lg2Cnt>CRYPT5_KDF_LG2_COUNT_MAX)\n    return;\n\n  byte Key[32],PswCheckValue[SHA256_DIGEST_SIZE],HashKeyValue[SHA256_DIGEST_SIZE];\n  bool Found=false;\n  for (uint I=0;I<ASIZE(KDF5Cache);I++)\n  {\n    KDF5CacheItem *Item=KDF5Cache+I;\n    if (Item->Lg2Count==Lg2Cnt && Item->Pwd==*Password &&\n        memcmp(Item->Salt,Salt,SIZE_SALT50)==0)\n    {\n      SecHideData(Item->Key,sizeof(Item->Key),false,false);\n      memcpy(Key,Item->Key,sizeof(Key));\n      SecHideData(Item->Key,sizeof(Item->Key),true,false);\n\n      memcpy(PswCheckValue,Item->PswCheckValue,sizeof(PswCheckValue));\n      memcpy(HashKeyValue,Item->HashKeyValue,sizeof(HashKeyValue));\n      Found=true;\n      break;\n    }\n  }\n\n  if (!Found)\n  {\n    char PwdUtf[MAXPASSWORD*4];\n    WideToUtf(PwdW,PwdUtf,ASIZE(PwdUtf));\n    \n    pbkdf2((byte *)PwdUtf,strlen(PwdUtf),Salt,SIZE_SALT50,Key,HashKeyValue,PswCheckValue,(1<<Lg2Cnt));\n    cleandata(PwdUtf,sizeof(PwdUtf));\n\n    KDF5CacheItem *Item=KDF5Cache+(KDF5CachePos++ % ASIZE(KDF5Cache));\n    Item->Lg2Count=Lg2Cnt;\n    Item->Pwd=*Password;\n    memcpy(Item->Salt,Salt,SIZE_SALT50);\n    memcpy(Item->Key,Key,sizeof(Key));\n    memcpy(Item->PswCheckValue,PswCheckValue,sizeof(PswCheckValue));\n    memcpy(Item->HashKeyValue,HashKeyValue,sizeof(HashKeyValue));\n    SecHideData(Item->Key,sizeof(Key),true,false);\n  }\n  if (HashKey!=NULL)\n    memcpy(HashKey,HashKeyValue,SHA256_DIGEST_SIZE);\n  if (PswCheck!=NULL)\n  {\n    memset(PswCheck,0,SIZE_PSWCHECK);\n    for (uint I=0;I<SHA256_DIGEST_SIZE;I++)\n      PswCheck[I%SIZE_PSWCHECK]^=PswCheckValue[I];\n    cleandata(PswCheckValue,sizeof(PswCheckValue));\n  }\n\n  // NULL initialization vector is possible if we only need the password\n  // check value for archive encryption header.\n  if (InitV!=NULL)\n    rin.Init(Encrypt, Key, 256, InitV);\n\n  cleandata(Key,sizeof(Key));\n}\n\n\nvoid ConvertHashToMAC(HashValue *Value,byte *Key)\n{\n  if (Value->Type==HASH_CRC32)\n  {\n    byte RawCRC[4];\n    RawPut4(Value->CRC32,RawCRC);\n    byte Digest[SHA256_DIGEST_SIZE];\n    hmac_sha256(Key,SHA256_DIGEST_SIZE,RawCRC,sizeof(RawCRC),Digest);\n    Value->CRC32=0;\n    for (uint I=0;I<ASIZE(Digest);I++)\n      Value->CRC32^=Digest[I] << ((I & 3) * 8);\n  }\n  if (Value->Type==HASH_BLAKE2)\n  {\n    byte Digest[BLAKE2_DIGEST_SIZE];\n    hmac_sha256(Key,BLAKE2_DIGEST_SIZE,Value->Digest,sizeof(Value->Digest),Digest);\n    memcpy(Value->Digest,Digest,sizeof(Value->Digest));\n  }\n}\n\n\n#if 0\nstatic void TestPBKDF2();\nstruct TestKDF {TestKDF() {TestPBKDF2();exit(0);}} GlobalTestKDF;\n\nvoid TestPBKDF2() // Test PBKDF2 HMAC-SHA256\n{\n  byte Key[32],V1[32],V2[32];\n\n  pbkdf2((byte *)\"password\", 8, (byte *)\"salt\", 4, Key, V1, V2, 1);\n  byte Res1[32]={0x12, 0x0f, 0xb6, 0xcf, 0xfc, 0xf8, 0xb3, 0x2c, 0x43, 0xe7, 0x22, 0x52, 0x56, 0xc4, 0xf8, 0x37, 0xa8, 0x65, 0x48, 0xc9, 0x2c, 0xcc, 0x35, 0x48, 0x08, 0x05, 0x98, 0x7c, 0xb7, 0x0b, 0xe1, 0x7b };\n  mprintf(L\"\\nPBKDF2 test1: %s\", memcmp(Key,Res1,32)==0 ? L\"OK\":L\"Failed\");\n\n  pbkdf2((byte *)\"password\", 8, (byte *)\"salt\", 4, Key, V1, V2, 4096);\n  byte Res2[32]={0xc5, 0xe4, 0x78, 0xd5, 0x92, 0x88, 0xc8, 0x41, 0xaa, 0x53, 0x0d, 0xb6, 0x84, 0x5c, 0x4c, 0x8d, 0x96, 0x28, 0x93, 0xa0, 0x01, 0xce, 0x4e, 0x11, 0xa4, 0x96, 0x38, 0x73, 0xaa, 0x98, 0x13, 0x4a };\n  mprintf(L\"\\nPBKDF2 test2: %s\", memcmp(Key,Res2,32)==0 ? L\"OK\":L\"Failed\");\n\n  pbkdf2((byte *)\"just some long string pretending to be a password\", 49, (byte *)\"salt, salt, salt, a lot of salt\", 31, Key, V1, V2, 65536);\n  byte Res3[32]={0x08, 0x0f, 0xa3, 0x1d, 0x42, 0x2d, 0xb0, 0x47, 0x83, 0x9b, 0xce, 0x3a, 0x3b, 0xce, 0x49, 0x51, 0xe2, 0x62, 0xb9, 0xff, 0x76, 0x2f, 0x57, 0xe9, 0xc4, 0x71, 0x96, 0xce, 0x4b, 0x6b, 0x6e, 0xbf};\n  mprintf(L\"\\nPBKDF2 test3: %s\", memcmp(Key,Res3,32)==0 ? L\"OK\":L\"Failed\");\n}\n#endif\n","#include \"rar.hpp\"\n\n#ifndef SFX_MODULE\n#include \"crypt1.cpp\"\n#include \"crypt2.cpp\"\n#endif\n#include \"crypt3.cpp\"\n#include \"crypt5.cpp\"\n\n\nCryptData::CryptData()\n{\n  Method=CRYPT_NONE;\n  memset(KDF3Cache,0,sizeof(KDF3Cache));\n  memset(KDF5Cache,0,sizeof(KDF5Cache));\n  KDF3CachePos=0;\n  KDF5CachePos=0;\n  memset(CRCTab,0,sizeof(CRCTab));\n}\n\n\nCryptData::~CryptData()\n{\n  cleandata(KDF3Cache,sizeof(KDF3Cache));\n  cleandata(KDF5Cache,sizeof(KDF5Cache));\n}\n\n\n\n\nvoid CryptData::DecryptBlock(byte *Buf,size_t Size)\n{\n  switch(Method)\n  {\n#ifndef SFX_MODULE\n    case CRYPT_RAR13:\n      Decrypt13(Buf,Size);\n      break;\n    case CRYPT_RAR15:\n      Crypt15(Buf,Size);\n      break;\n    case CRYPT_RAR20:\n      for (size_t I=0;I<Size;I+=CRYPT_BLOCK_SIZE)\n        DecryptBlock20(Buf+I);\n      break;\n#endif\n    case CRYPT_RAR30:\n    case CRYPT_RAR50:\n      rin.blockDecrypt(Buf,Size,Buf);\n      break;\n  }\n}\n\n\nbool CryptData::SetCryptKeys(bool Encrypt,CRYPT_METHOD Method,\n     SecPassword *Password,const byte *Salt,\n     const byte *InitV,uint Lg2Cnt,byte *HashKey,byte *PswCheck)\n{\n  if (!Password->IsSet() || Method==CRYPT_NONE)\n    return false;\n\n  CryptData::Method=Method;\n\n  wchar PwdW[MAXPASSWORD];\n  Password->Get(PwdW,ASIZE(PwdW));\n  char PwdA[MAXPASSWORD];\n  WideToChar(PwdW,PwdA,ASIZE(PwdA));\n\n  switch(Method)\n  {\n#ifndef SFX_MODULE\n    case CRYPT_RAR13:\n      SetKey13(PwdA);\n      break;\n    case CRYPT_RAR15:\n      SetKey15(PwdA);\n      break;\n    case CRYPT_RAR20:\n      SetKey20(PwdA);\n      break;\n#endif\n    case CRYPT_RAR30:\n      SetKey30(Encrypt,Password,PwdW,Salt);\n      break;\n    case CRYPT_RAR50:\n      SetKey50(Encrypt,Password,PwdW,Salt,InitV,Lg2Cnt,HashKey,PswCheck);\n      break;\n  }\n  cleandata(PwdA,sizeof(PwdA));\n  cleandata(PwdW,sizeof(PwdW));\n  return true;\n}\n\n\n\n\n// Fill buffer with random data.\nvoid GetRnd(byte *RndBuf,size_t BufSize)\n{\n  bool Success=false;\n#if defined(_WIN_ALL)\n  HCRYPTPROV hProvider = 0;\n\tif (CryptAcquireContext(&hProvider, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT))\n  {\n\t  Success=CryptGenRandom(hProvider, (DWORD)BufSize, RndBuf) == TRUE;\n\t  CryptReleaseContext(hProvider, 0);\n  }\n#elif defined(_UNIX)\n  FILE *rndf = fopen(\"/dev/urandom\", \"r\");\n  if (rndf!=NULL)\n  {\n    Success=fread(RndBuf, BufSize, 1, rndf) == BufSize;\n    fclose(rndf);\n  }\n#endif\n  // We use this code only as the last resort if code above failed.\n  if (!Success)\n  {\n    static uint Count=0;\n    RarTime CurTime;\n    CurTime.SetCurrentTime();\n    uint64 Random=CurTime.GetRaw()+clock();\n    for (size_t I=0;I<BufSize;I++)\n    {\n      byte RndByte = byte (Random >> ( (I & 7) * 8 ));\n      RndBuf[I]=byte( (RndByte ^ I) + Count++);\n    }\n  }\n}\n","#ifndef _RAR_CRYPT_\n#define _RAR_CRYPT_\n\n\nenum CRYPT_METHOD {\n  CRYPT_NONE,CRYPT_RAR13,CRYPT_RAR15,CRYPT_RAR20,CRYPT_RAR30,CRYPT_RAR50\n};\n\n#define SIZE_SALT50              16\n#define SIZE_SALT30               8\n#define SIZE_INITV               16\n#define SIZE_PSWCHECK             8\n#define SIZE_PSWCHECK_CSUM        4\n\n#define CRYPT_BLOCK_SIZE         16\n#define CRYPT_BLOCK_MASK         (CRYPT_BLOCK_SIZE-1) // 0xf\n\n#define CRYPT5_KDF_LG2_COUNT     15 // LOG2 of PDKDF2 iteration count.\n#define CRYPT5_KDF_LG2_COUNT_MAX 24 // LOG2 of maximum accepted iteration count.\n#define CRYPT_VERSION             0 // Supported encryption version.\n\n\nclass CryptData\n{\n  struct KDF5CacheItem\n  {\n    SecPassword Pwd;\n    byte Salt[SIZE_SALT50];\n    byte Key[32];\n    uint Lg2Count; // Log2 of PBKDF2 repetition count.\n    byte PswCheckValue[SHA256_DIGEST_SIZE];\n    byte HashKeyValue[SHA256_DIGEST_SIZE];\n  };\n\n  struct KDF3CacheItem\n  {\n    SecPassword Pwd;\n    byte Salt[SIZE_SALT30];\n    byte Key[16];\n    byte Init[16];\n    bool SaltPresent;\n  };\n\n\n  private:\n    void SetKey13(const char *Password);\n    void Decrypt13(byte *Data,size_t Count);\n\n    void SetKey15(const char *Password);\n    void Crypt15(byte *Data,size_t Count);\n\n    void SetKey20(const char *Password);\n    void Swap20(byte *Ch1,byte *Ch2);\n    void UpdKeys20(byte *Buf);\n    void EncryptBlock20(byte *Buf);\n    void DecryptBlock20(byte *Buf);\n\n    void SetKey30(bool Encrypt,SecPassword *Password,const wchar *PwdW,const byte *Salt);\n    void SetKey50(bool Encrypt,SecPassword *Password,const wchar *PwdW,const byte *Salt,const byte *InitV,uint Lg2Cnt,byte *HashKey,byte *PswCheck);\n\n    KDF3CacheItem KDF3Cache[4];\n    uint KDF3CachePos;\n    \n    KDF5CacheItem KDF5Cache[4];\n    uint KDF5CachePos;\n\n    CRYPT_METHOD Method;\n\n    Rijndael rin;\n\n    uint CRCTab[256]; // For RAR 1.5 and RAR 2.0 encryption.\n    \n    byte SubstTable20[256];\n    uint Key20[4];\n\n    byte Key13[3];\n    ushort Key15[4];\n  public:\n    CryptData();\n    ~CryptData();\n    bool SetCryptKeys(bool Encrypt,CRYPT_METHOD Method,SecPassword *Password,\n         const byte *Salt,const byte *InitV,uint Lg2Cnt,\n         byte *HashKey,byte *PswCheck);\n    void SetAV15Encryption();\n    void SetCmt13Encryption();\n    void EncryptBlock(byte *Buf,size_t Size);\n    void DecryptBlock(byte *Buf,size_t Size);\n    static void SetSalt(byte *Salt,size_t SaltSize);\n};\n\nvoid GetRnd(byte *RndBuf,size_t BufSize);\n\nvoid hmac_sha256(const byte *Key,size_t KeyLength,const byte *Data,\n                 size_t DataLength,byte *ResDigest);\nvoid pbkdf2(const byte *pass, size_t pass_len, const byte *salt,\n            size_t salt_len,byte *key, byte *Value1, byte *Value2,\n            uint rounds);\n\nvoid ConvertHashToMAC(HashValue *Value,byte *Key);\n\n#endif\n","// This CRC function is based on Intel Slicing-by-8 algorithm.\n//\n// Original Intel Slicing-by-8 code is available here:\n//\n//    http://sourceforge.net/projects/slicing-by-8/\n//\n// Original Intel Slicing-by-8 code is licensed as:\n//    \n//    Copyright (c) 2004-2006 Intel Corporation - All Rights Reserved\n//    \n//    This software program is licensed subject to the BSD License, \n//    available at http://www.opensource.org/licenses/bsd-license.html\n\n\n#include \"rar.hpp\"\n\nstatic uint crc_tables[8][256]; // Tables for Slicing-by-8.\n\n\n// Build the classic CRC32 lookup table.\n// We also provide this function to legacy RAR and ZIP decryption code.\nvoid InitCRC32(uint *CRCTab)\n{\n  if (CRCTab[1]!=0)\n    return;\n  for (uint I=0;I<256;I++)\n  {\n    uint C=I;\n    for (uint J=0;J<8;J++)\n      C=(C & 1) ? (C>>1)^0xEDB88320 : (C>>1);\n    CRCTab[I]=C;\n  }\n}\n\n\nstatic void InitTables()\n{\n  InitCRC32(crc_tables[0]);\n\n  for (uint I=0;I<256;I++) // Build additional lookup tables.\n  {\n    uint C=crc_tables[0][I];\n    for (uint J=1;J<8;J++)\n    {\n      C=crc_tables[0][(byte)C]^(C>>8);\n      crc_tables[J][I]=C;\n    }\n  }\n}\n\n\nstruct CallInitCRC {CallInitCRC() {InitTables();}} static CallInit32;\n\nuint CRC32(uint StartCRC,const void *Addr,size_t Size)\n{\n  byte *Data=(byte *)Addr;\n\n  // Align Data to 8 for better performance.\n  for (;Size>0 && ((size_t)Data & 7);Size--,Data++)\n    StartCRC=crc_tables[0][(byte)(StartCRC^Data[0])]^(StartCRC>>8);\n\n  for (;Size>=8;Size-=8,Data+=8)\n  {\n#ifdef BIG_ENDIAN\n    StartCRC ^= Data[0]|(Data[1] << 8)|(Data[2] << 16)|(Data[3] << 24);\n    uint NextData = Data[4]|(Data[5] << 8)|(Data[6] << 16)|(Data[7] << 24);\n#else\n    StartCRC ^= *(uint32 *) Data;\n    uint NextData = *(uint32 *) (Data +4);\n#endif\n    StartCRC = crc_tables[7][(byte) StartCRC       ] ^\n               crc_tables[6][(byte)(StartCRC >> 8) ] ^\n               crc_tables[5][(byte)(StartCRC >> 16)] ^\n               crc_tables[4][(byte)(StartCRC >> 24)] ^\n               crc_tables[3][(byte) NextData       ] ^\n               crc_tables[2][(byte)(NextData >>8 ) ] ^\n               crc_tables[1][(byte)(NextData >> 16)] ^\n               crc_tables[0][(byte)(NextData >> 24)];\n  }\n\n  for (;Size>0;Size--,Data++) // Process left data.\n    StartCRC=crc_tables[0][(byte)(StartCRC^Data[0])]^(StartCRC>>8);\n\n  return StartCRC;\n}\n\n\n#ifndef SFX_MODULE\n// For RAR 1.4 archives in case somebody still has them.\nushort Checksum14(ushort StartCRC,const void *Addr,size_t Size)\n{\n  byte *Data=(byte *)Addr;\n  for (size_t I=0;I<Size;I++)\n  {\n    StartCRC=(StartCRC+Data[I])&0xffff;\n    StartCRC=((StartCRC<<1)|(StartCRC>>15))&0xffff;\n  }\n  return StartCRC;\n}\n#endif\n\n\n","#include \"rar.hpp\"\n\nRawRead::RawRead()\n{\n  RawRead::SrcFile=NULL;\n  Reset();\n}\n\n\nRawRead::RawRead(File *SrcFile)\n{\n  RawRead::SrcFile=SrcFile;\n  Reset();\n}\n\n\nvoid RawRead::Reset()\n{\n  Data.SoftReset();\n  ReadPos=0;\n  DataSize=0;\n#ifndef SHELL_EXT\n  Crypt=NULL;\n#endif\n}\n\n\nsize_t RawRead::Read(size_t Size)\n{\n  size_t ReadSize=0;\n#if !defined(SHELL_EXT) && !defined(RAR_NOCRYPT)\n  if (Crypt!=NULL)\n  {\n    // Full size of buffer with already read data including data read \n    // for encryption block alignment.\n    size_t FullSize=Data.Size();\n\n    // Data read for alignment and not processed yet.\n    size_t DataLeft=FullSize-DataSize;\n\n    if (Size>DataLeft) // Need to read more than we already have.\n    {\n      size_t SizeToRead=Size-DataLeft;\n      size_t AlignedReadSize=SizeToRead+((~SizeToRead+1) & CRYPT_BLOCK_MASK);\n      Data.Add(AlignedReadSize);\n      ReadSize=SrcFile->Read(&Data[FullSize],AlignedReadSize);\n      Crypt->DecryptBlock(&Data[FullSize],AlignedReadSize);\n      DataSize+=ReadSize==0 ? 0:Size;\n    }\n    else // Use buffered data, no real read.\n    {\n      ReadSize=Size;\n      DataSize+=Size;\n    }\n  }\n  else\n#endif\n    if (Size!=0)\n    {\n      Data.Add(Size);\n      ReadSize=SrcFile->Read(&Data[DataSize],Size);\n      DataSize+=ReadSize;\n    }\n  return ReadSize;\n}\n\n\nvoid RawRead::Read(byte *SrcData,size_t Size)\n{\n  if (Size!=0)\n  {\n    Data.Add(Size);\n    memcpy(&Data[DataSize],SrcData,Size);\n    DataSize+=Size;\n  }\n}\n\n\nbyte RawRead::Get1()\n{\n  return ReadPos<DataSize ? Data[ReadPos++]:0;\n}\n\n\nushort RawRead::Get2()\n{\n  if (ReadPos+1<DataSize)\n  {\n    ushort Result=Data[ReadPos]+(Data[ReadPos+1]<<8);\n    ReadPos+=2;\n    return Result;\n  }\n  return 0;\n}\n\n\nuint RawRead::Get4()\n{\n  if (ReadPos+3<DataSize)\n  {\n    uint Result=Data[ReadPos]+(Data[ReadPos+1]<<8)+(Data[ReadPos+2]<<16)+\n                (Data[ReadPos+3]<<24);\n    ReadPos+=4;\n    return Result;\n  }\n  return 0;\n}\n\n\nuint64 RawRead::Get8()\n{\n  uint Low=Get4(),High=Get4();\n  return INT32TO64(High,Low);\n}\n\n\nuint64 RawRead::GetV()\n{\n  uint64 Result=0;\n  for (uint Shift=0;ReadPos<DataSize;Shift+=7)\n  {\n    byte CurByte=Data[ReadPos++];\n    Result+=uint64(CurByte & 0x7f)<<Shift;\n    if ((CurByte & 0x80)==0)\n      return Result; // Decoded successfully.\n  }\n  return 0; // Out of buffer border.\n}\n\n\n// Return a number of bytes in current variable length integer.\nuint RawRead::GetVSize(size_t Pos)\n{\n  for (size_t CurPos=Pos;CurPos<DataSize;CurPos++)\n    if ((Data[CurPos] & 0x80)==0)\n      return int(CurPos-Pos+1);\n  return 0; // Buffer overflow.\n}\n\n\nsize_t RawRead::GetB(void *Field,size_t Size)\n{\n  byte *F=(byte *)Field;\n  size_t CopySize=Min(DataSize-ReadPos,Size);\n  if (CopySize>0)\n    memcpy(F,&Data[ReadPos],CopySize);\n  if (Size>CopySize)\n    memset(F+CopySize,0,Size-CopySize);\n  ReadPos+=CopySize;\n  return CopySize;\n}\n\n\nvoid RawRead::GetW(wchar *Field,size_t Size)\n{\n  if (ReadPos+2*Size-1<DataSize)\n  {\n    RawToWide(&Data[ReadPos],Field,Size);\n    ReadPos+=sizeof(wchar)*Size;\n  }\n  else\n    memset(Field,0,sizeof(wchar)*Size);\n}\n\n\nuint RawRead::GetCRC15(bool ProcessedOnly) // RAR 1.5 block CRC.\n{\n  if (DataSize<=2)\n    return 0;\n  uint HeaderCRC=CRC32(0xffffffff,&Data[2],(ProcessedOnly ? ReadPos:DataSize)-2);\n  return ~HeaderCRC & 0xffff;\n}\n\n\nuint RawRead::GetCRC50() // RAR 5.0 block CRC.\n{\n  if (DataSize<=4)\n    return 0xffffffff;\n  return CRC32(0xffffffff,&Data[4],DataSize-4) ^ 0xffffffff;\n}\n\n\n// Read vint from arbitrary byte array.\nuint64 RawGetV(const byte *Data,uint &ReadPos,uint DataSize,bool &Overflow)\n{\n  Overflow=false;\n  uint64 Result=0;\n  for (uint Shift=0;ReadPos<DataSize;Shift+=7)\n  {\n    byte CurByte=Data[ReadPos++];\n    Result+=uint64(CurByte & 0x7f)<<Shift;\n    if ((CurByte & 0x80)==0)\n      return Result; // Decoded successfully.\n  }\n  Overflow=true;\n  return 0; // Out of buffer border.\n}\n","#include \"rar.hpp\"\n\nEncodeFileName::EncodeFileName()\n{\n  Flags=0;\n  FlagBits=0;\n  FlagsPos=0;\n  DestSize=0;\n}\n\n\n\n\nvoid EncodeFileName::Decode(char *Name,byte *EncName,size_t EncSize,wchar *NameW,\n                            size_t MaxDecSize)\n{\n  size_t EncPos=0,DecPos=0;\n  byte HighByte=EncName[EncPos++];\n  while (EncPos<EncSize && DecPos<MaxDecSize)\n  {\n    if (FlagBits==0)\n    {\n      Flags=EncName[EncPos++];\n      FlagBits=8;\n    }\n    switch(Flags>>6)\n    {\n      case 0:\n        NameW[DecPos++]=EncName[EncPos++];\n        break;\n      case 1:\n        NameW[DecPos++]=EncName[EncPos++]+(HighByte<<8);\n        break;\n      case 2:\n        NameW[DecPos++]=EncName[EncPos]+(EncName[EncPos+1]<<8);\n        EncPos+=2;\n        break;\n      case 3:\n        {\n          int Length=EncName[EncPos++];\n          if (Length & 0x80)\n          {\n            byte Correction=EncName[EncPos++];\n            for (Length=(Length&0x7f)+2;Length>0 && DecPos<MaxDecSize;Length--,DecPos++)\n              NameW[DecPos]=((Name[DecPos]+Correction)&0xff)+(HighByte<<8);\n          }\n          else\n            for (Length+=2;Length>0 && DecPos<MaxDecSize;Length--,DecPos++)\n              NameW[DecPos]=Name[DecPos];\n        }\n        break;\n    }\n    Flags<<=2;\n    FlagBits-=2;\n  }\n  NameW[DecPos<MaxDecSize ? DecPos:MaxDecSize-1]=0;\n}\n","#include \"rar.hpp\"\n\nstatic bool match(const wchar *pattern,const wchar *string,bool ForceCase);\nstatic int mwcsicompc(const wchar *Str1,const wchar *Str2,bool ForceCase);\nstatic int mwcsnicompc(const wchar *Str1,const wchar *Str2,size_t N,bool ForceCase);\n\ninline uint touppercw(uint ch,bool ForceCase)\n{\n  if (ForceCase)\n    return ch;\n#if defined(_UNIX)\n  return ch;\n#else\n  return toupperw(ch);\n#endif\n}\n\n\nbool CmpName(const wchar *Wildcard,const wchar *Name,int CmpMode)\n{\n  bool ForceCase=(CmpMode&MATCH_FORCECASESENSITIVE)!=0;\n\n  CmpMode&=MATCH_MODEMASK;\n\n  if (CmpMode!=MATCH_NAMES)\n  {\n    size_t WildLength=wcslen(Wildcard);\n    if (CmpMode!=MATCH_EXACT && CmpMode!=MATCH_EXACTPATH &&\n        mwcsnicompc(Wildcard,Name,WildLength,ForceCase)==0)\n    {\n      // For all modes except MATCH_NAMES, MATCH_EXACT and MATCH_EXACTPATH\n      // \"path1\" mask must match \"path1\\path2\\filename.ext\" and \"path1\" names.\n      wchar NextCh=Name[WildLength];\n      if (NextCh==L'\\\\' || NextCh==L'/' || NextCh==0)\n        return(true);\n    }\n\n    // Nothing more to compare for MATCH_SUBPATHONLY.\n    if (CmpMode==MATCH_SUBPATHONLY)\n      return(false);\n\n    wchar Path1[NM],Path2[NM];\n    GetFilePath(Wildcard,Path1,ASIZE(Path1));\n    GetFilePath(Name,Path2,ASIZE(Path2));\n\n    if ((CmpMode==MATCH_EXACT || CmpMode==MATCH_EXACTPATH) &&\n        mwcsicompc(Path1,Path2,ForceCase)!=0)\n      return(false);\n    if (CmpMode==MATCH_SUBPATH || CmpMode==MATCH_WILDSUBPATH)\n      if (IsWildcard(Path1))\n        return(match(Wildcard,Name,ForceCase));\n      else\n        if (CmpMode==MATCH_SUBPATH || IsWildcard(Wildcard))\n        {\n          if (*Path1 && mwcsnicompc(Path1,Path2,wcslen(Path1),ForceCase)!=0)\n            return(false);\n        }\n        else\n          if (mwcsicompc(Path1,Path2,ForceCase)!=0)\n            return(false);\n  }\n  wchar *Name1=PointToName(Wildcard);\n  wchar *Name2=PointToName(Name);\n\n  // Always return false for RAR temporary files to exclude them\n  // from archiving operations.\n  if (mwcsnicompc(L\"__rar_\",Name2,6,false)==0)\n    return(false);\n\n  if (CmpMode==MATCH_EXACT)\n    return(mwcsicompc(Name1,Name2,ForceCase)==0);\n\n  return(match(Name1,Name2,ForceCase));\n}\n\n\nbool match(const wchar *pattern,const wchar *string,bool ForceCase)\n{\n  for (;; ++string)\n  {\n    wchar stringc=touppercw(*string,ForceCase);\n    wchar patternc=touppercw(*pattern++,ForceCase);\n    switch (patternc)\n    {\n      case 0:\n        return(stringc==0);\n      case '?':\n        if (stringc == 0)\n          return(false);\n        break;\n      case '*':\n        if (*pattern==0)\n          return(true);\n        if (*pattern=='.')\n        {\n          if (pattern[1]=='*' && pattern[2]==0)\n            return(true);\n          const wchar *dot=wcschr(string,'.');\n          if (pattern[1]==0)\n            return (dot==NULL || dot[1]==0);\n          if (dot!=NULL)\n          {\n            string=dot;\n            if (wcspbrk(pattern,L\"*?\")==NULL && wcschr(string+1,'.')==NULL)\n              return(mwcsicompc(pattern+1,string+1,ForceCase)==0);\n          }\n        }\n\n        while (*string)\n          if (match(pattern,string++,ForceCase))\n            return(true);\n        return(false);\n      default:\n        if (patternc != stringc)\n        {\n          // Allow \"name.\" mask match \"name\" and \"name.\\\" match \"name\\\".\n          if (patternc=='.' && (stringc==0 || stringc=='\\\\' || stringc=='.'))\n            return(match(pattern,string,ForceCase));\n          else\n            return(false);\n        }\n        break;\n    }\n  }\n}\n\n\nint mwcsicompc(const wchar *Str1,const wchar *Str2,bool ForceCase)\n{\n  if (ForceCase)\n    return(wcscmp(Str1,Str2));\n  return(wcsicompc(Str1,Str2));\n}\n\n\nint mwcsnicompc(const wchar *Str1,const wchar *Str2,size_t N,bool ForceCase)\n{\n  if (ForceCase)\n    return(wcsncmp(Str1,Str2,N));\n#if defined(_UNIX)\n  return(wcsncmp(Str1,Str2,N));\n#else\n  return(wcsnicomp(Str1,Str2,N));\n#endif\n}\n","#include \"rar.hpp\"\n\n#ifdef _WIN_ALL\nRarTime& RarTime::operator =(FILETIME &ft)\n{\n  _ULARGE_INTEGER ul = {ft.dwLowDateTime, ft.dwHighDateTime};\n  itime=ul.QuadPart;\n  return *this;\n}\n\n\nvoid RarTime::GetWin32(FILETIME *ft)\n{\n  _ULARGE_INTEGER ul;\n  ul.QuadPart=itime;\n  ft->dwLowDateTime=ul.LowPart;\n  ft->dwHighDateTime=ul.HighPart;\n}\n#endif\n\n\nRarTime& RarTime::operator =(time_t ut)\n{\n  uint64 ushift=INT32TO64(0x19DB1DE,0xD53E8000); // 116444736000000000.\n  itime=uint64(ut)*10000000+ushift;\n  return *this;\n}\n\n\ntime_t RarTime::GetUnix()\n{\n  uint64 ushift=INT32TO64(0x19DB1DE,0xD53E8000); // 116444736000000000.\n  time_t ut=(itime-ushift)/10000000;\n  return ut;\n}\n\n\nvoid RarTime::GetLocal(RarLocalTime *lt)\n{\n#ifdef _WIN_ALL\n  FILETIME ft;\n  GetWin32(&ft);\n  FILETIME lft;\n\n  if (WinNT() < WNT_VISTA)\n  {\n    // SystemTimeToTzSpecificLocalTime based code produces 1 hour error on XP.\n    FileTimeToLocalFileTime(&ft,&lft);\n  }\n  else\n  {\n    // We use these functions instead of FileTimeToLocalFileTime according to\n    // MSDN recommendation: \"To account for daylight saving time\n    // when converting a file time to a local time ...\"\n    SYSTEMTIME st1,st2;\n    FileTimeToSystemTime(&ft,&st1);\n    SystemTimeToTzSpecificLocalTime(NULL,&st1,&st2);\n    SystemTimeToFileTime(&st2,&lft);\n\n    // Correct precision loss (low 4 decimal digits) in FileTimeToSystemTime.\n    FILETIME rft;\n    SystemTimeToFileTime(&st1,&rft);\n    int64 Corrected=INT32TO64(ft.dwHighDateTime,ft.dwLowDateTime)-\n                    INT32TO64(rft.dwHighDateTime,rft.dwLowDateTime)+\n                    INT32TO64(lft.dwHighDateTime,lft.dwLowDateTime);\n    lft.dwLowDateTime=(DWORD)Corrected;\n    lft.dwHighDateTime=(DWORD)(Corrected>>32);\n  }\n\n  SYSTEMTIME st;\n  FileTimeToSystemTime(&lft,&st);\n  lt->Year=st.wYear;\n  lt->Month=st.wMonth;\n  lt->Day=st.wDay;\n  lt->Hour=st.wHour;\n  lt->Minute=st.wMinute;\n  lt->Second=st.wSecond;\n  lt->wDay=st.wDayOfWeek;\n  lt->yDay=lt->Day-1;\n\n  static int mdays[12]={31,28,31,30,31,30,31,31,30,31,30,31};\n  for (uint I=1;I<lt->Month && I<=ASIZE(mdays);I++)\n    lt->yDay+=mdays[I-1];\n\n  if (lt->Month>2 && IsLeapYear(lt->Year))\n    lt->yDay++;\n\n  st.wMilliseconds=0;\n  FILETIME zft;\n  SystemTimeToFileTime(&st,&zft);\n\n  // Calculate the time reminder, which is the part of time smaller\n  // than 1 second, represented in 100-nanosecond intervals.\n  lt->Reminder=INT32TO64(lft.dwHighDateTime,lft.dwLowDateTime)-\n               INT32TO64(zft.dwHighDateTime,zft.dwLowDateTime);\n#else\n  time_t ut=GetUnix();\n  struct tm *t;\n  t=localtime(&ut);\n\n  lt->Year=t->tm_year+1900;\n  lt->Month=t->tm_mon+1;\n  lt->Day=t->tm_mday;\n  lt->Hour=t->tm_hour;\n  lt->Minute=t->tm_min;\n  lt->Second=t->tm_sec;\n  lt->Reminder=itime % 10000000;\n  lt->wDay=t->tm_wday;\n  lt->yDay=t->tm_yday;\n#endif\n}\n\n\nvoid RarTime::SetLocal(RarLocalTime *lt)\n{\n#ifdef _WIN_ALL\n  SYSTEMTIME st;\n  st.wYear=lt->Year;\n  st.wMonth=lt->Month;\n  st.wDay=lt->Day;\n  st.wHour=lt->Hour;\n  st.wMinute=lt->Minute;\n  st.wSecond=lt->Second;\n  st.wMilliseconds=0;\n  st.wDayOfWeek=0;\n  FILETIME lft;\n  if (SystemTimeToFileTime(&st,&lft))\n  {\n    lft.dwLowDateTime+=lt->Reminder;\n    if (lft.dwLowDateTime<lt->Reminder)\n      lft.dwHighDateTime++;\n\n    FILETIME ft;\n\n    if (WinNT() < WNT_VISTA)\n    {\n      // TzSpecificLocalTimeToSystemTime based code produces 1 hour error on XP.\n      LocalFileTimeToFileTime(&lft,&ft);\n    }\n    else\n    {\n      // Reverse procedure which we do in GetLocal.\n      SYSTEMTIME st1,st2;\n      FileTimeToSystemTime(&lft,&st2); // st2 might be unequal to st, because we added lt->Reminder to lft.\n      TzSpecificLocalTimeToSystemTime(NULL,&st2,&st1);\n      SystemTimeToFileTime(&st1,&ft);\n\n      // Correct precision loss (low 4 decimal digits) in FileTimeToSystemTime.\n      FILETIME rft;\n      SystemTimeToFileTime(&st2,&rft);\n      int64 Corrected=INT32TO64(lft.dwHighDateTime,lft.dwLowDateTime)-\n                      INT32TO64(rft.dwHighDateTime,rft.dwLowDateTime)+\n                      INT32TO64(ft.dwHighDateTime,ft.dwLowDateTime);\n      ft.dwLowDateTime=(DWORD)Corrected;\n      ft.dwHighDateTime=(DWORD)(Corrected>>32);\n    }\n\n    *this=ft;\n  }\n  else\n    Reset();\n#else\n  struct tm t;\n\n  t.tm_sec=lt->Second;\n  t.tm_min=lt->Minute;\n  t.tm_hour=lt->Hour;\n  t.tm_mday=lt->Day;\n  t.tm_mon=lt->Month-1;\n  t.tm_year=lt->Year-1900;\n  t.tm_isdst=-1;\n  *this=mktime(&t);\n  itime+=lt->Reminder;\n#endif\n}\n\n\nvoid RarTime::SetUTC(RarLocalTime *lt) // Input is in UTC format.\n{\n#ifdef _WIN_ALL\n  SYSTEMTIME st;\n  st.wYear=lt->Year;\n  st.wMonth=lt->Month;\n  st.wDay=lt->Day;\n  st.wHour=lt->Hour;\n  st.wMinute=lt->Minute;\n  st.wSecond=lt->Second;\n  st.wMilliseconds=0;\n  st.wDayOfWeek=0;\n  FILETIME ft;\n  if (SystemTimeToFileTime(&st,&ft))\n    *this=ft;\n  else\n    Reset();\n#else\n  struct tm t;\n\n  t.tm_sec=lt->Second;\n  t.tm_min=lt->Minute;\n  t.tm_hour=lt->Hour;\n  t.tm_mday=lt->Day;\n  t.tm_mon=lt->Month-1;\n  t.tm_year=lt->Year-1900;\n  t.tm_isdst=-1;\n\n  /* get the local time for Jan 2, 1900 00:00 UTC */\n  time_t zero = 24*60*60L;\n  struct tm *timeptr = localtime( &zero );\n  int gmtime_hours = timeptr->tm_hour;\n\n  /* if the local time is the \"day before\" the UTC, subtract 24 hours\n    from the hours to get the UTC offset */\n  if( timeptr->tm_mday < 2 )\n    gmtime_hours -= 24;\n  \n  *this=mktime(&t)+gmtime_hours*3600;\n  itime+=lt->Reminder;\n\n#endif\n}\n\n\n// Return the stored time as 64-bit number of 100-nanosecond intervals since \n// 01.01.1601. Actually we do not care since which date this time starts from\n// as long as this date is the same for GetRaw and SetRaw. We use the value\n// returned by GetRaw() for time comparisons, for relative operations\n// like SetRaw(GetRaw()-C) and for compact time storage when necessary.\nuint64 RarTime::GetRaw()\n{\n  return itime;\n}\n\n\nvoid RarTime::SetRaw(uint64 RawTime)\n{\n  itime=RawTime;\n}\n\n\nuint RarTime::GetDos()\n{\n  RarLocalTime lt;\n  GetLocal(&lt);\n  uint DosTime=(lt.Second/2)|(lt.Minute<<5)|(lt.Hour<<11)|\n               (lt.Day<<16)|(lt.Month<<21)|((lt.Year-1980)<<25);\n  return DosTime;\n}\n\n\nvoid RarTime::SetDos(uint DosTime)\n{\n  RarLocalTime lt;\n  lt.Second=(DosTime & 0x1f)*2;\n  lt.Minute=(DosTime>>5) & 0x3f;\n  lt.Hour=(DosTime>>11) & 0x1f;\n  lt.Day=(DosTime>>16) & 0x1f;\n  lt.Month=(DosTime>>21) & 0x0f;\n  lt.Year=(DosTime>>25)+1980;\n  lt.Reminder=0;\n  SetLocal(&lt);\n}\n\n\n#if !defined(GUI) || !defined(SFX_MODULE)\nvoid RarTime::GetText(wchar *DateStr,size_t MaxSize,bool FullMS)\n{\n  if (IsSet())\n  {\n    RarLocalTime lt;\n    GetLocal(&lt);\n    if (FullMS)\n      swprintf(DateStr,MaxSize,L\"%u-%02u-%02u %02u:%02u:%02u,%03u\",lt.Year,lt.Month,lt.Day,lt.Hour,lt.Minute,lt.Second,lt.Reminder/10000);\n    else\n      swprintf(DateStr,MaxSize,L\"%u-%02u-%02u %02u:%02u\",lt.Year,lt.Month,lt.Day,lt.Hour,lt.Minute);\n  }\n  else\n  {\n    // We use escape before '?' to avoid weird C trigraph characters.\n    wcscpy(DateStr,L\"\\?\\?\\?\\?-\\?\\?-\\?\\? \\?\\?:\\?\\?\");\n  }\n}\n#endif\n\n\n#ifndef SFX_MODULE\nvoid RarTime::SetIsoText(const wchar *TimeText)\n{\n  int Field[6];\n  memset(Field,0,sizeof(Field));\n  for (uint DigitCount=0;*TimeText!=0;TimeText++)\n    if (IsDigit(*TimeText))\n    {\n      int FieldPos=DigitCount<4 ? 0:(DigitCount-4)/2+1;\n      if (FieldPos<ASIZE(Field))\n        Field[FieldPos]=Field[FieldPos]*10+*TimeText-'0';\n      DigitCount++;\n    }\n  RarLocalTime lt;\n  lt.Second=Field[5];\n  lt.Minute=Field[4];\n  lt.Hour=Field[3];\n  lt.Day=Field[2]==0 ? 1:Field[2];\n  lt.Month=Field[1]==0 ? 1:Field[1];\n  lt.Year=Field[0];\n  lt.Reminder=0;\n  SetLocal(&lt);\n}\n#endif\n\n\n#ifndef SFX_MODULE\nvoid RarTime::SetAgeText(const wchar *TimeText)\n{\n  uint Seconds=0,Value=0;\n  for (int I=0;TimeText[I]!=0;I++)\n  {\n    int Ch=TimeText[I];\n    if (IsDigit(Ch))\n      Value=Value*10+Ch-'0';\n    else\n    {\n      switch(etoupper(Ch))\n      {\n        case 'D':\n          Seconds+=Value*24*3600;\n          break;\n        case 'H':\n          Seconds+=Value*3600;\n          break;\n        case 'M':\n          Seconds+=Value*60;\n          break;\n        case 'S':\n          Seconds+=Value;\n          break;\n      }\n      Value=0;\n    }\n  }\n  SetCurrentTime();\n  SetRaw(itime-uint64(Seconds)*10000000);\n}\n#endif\n\n\nvoid RarTime::SetCurrentTime()\n{\n#ifdef _WIN_ALL\n  FILETIME ft;\n  SYSTEMTIME st;\n  GetSystemTime(&st);\n  SystemTimeToFileTime(&st,&ft);\n  *this=ft;\n#else\n  time_t st;\n  time(&st);\n  *this=st;\n#endif\n}\n\n\n#ifndef SFX_MODULE\nconst wchar *GetMonthName(int Month)\n{\n  return uiGetMonthName(Month);\n}\n#endif\n\n\nbool IsLeapYear(int Year)\n{\n  return (Year&3)==0 && (Year%100!=0 || Year%400==0);\n}\n","#include \"rar.hpp\"\n\nComprDataIO::ComprDataIO()\n{\n#ifndef RAR_NOCRYPT\n  Crypt=new CryptData;\n  Decrypt=new CryptData;\n#endif\n\n  Init();\n}\n\n\nvoid ComprDataIO::Init()\n{\n  UnpackFromMemory=false;\n  UnpackToMemory=false;\n  UnpPackedSize=0;\n  ShowProgress=true;\n  TestMode=false;\n  SkipUnpCRC=false;\n  PackVolume=false;\n  UnpVolume=false;\n  NextVolumeMissing=false;\n  SrcFile=NULL;\n  DestFile=NULL;\n  UnpWrSize=0;\n  Command=NULL;\n  Encryption=false;\n  Decryption=false;\n  CurPackRead=CurPackWrite=CurUnpRead=CurUnpWrite=0;\n  LastPercent=-1;\n  SubHead=NULL;\n  SubHeadPos=NULL;\n  CurrentCommand=0;\n  ProcessedArcSize=TotalArcSize=0;\n}\n\n\nComprDataIO::~ComprDataIO()\n{\n#ifndef RAR_NOCRYPT\n  delete Crypt;\n  delete Decrypt;\n#endif\n}\n\n\n\n\nint ComprDataIO::UnpRead(byte *Addr,size_t Count)\n{\n#ifndef RAR_NOCRYPT\n  // In case of encryption we need to align read size to encryption \n  // block size. We can do it by simple masking, because unpack read code\n  // always reads more than CRYPT_BLOCK_SIZE, so we do not risk to make it 0.\n  if (Decryption)\n    Count &= ~CRYPT_BLOCK_MASK;\n#endif\n  \n  int ReadSize=0,TotalRead=0;\n  byte *ReadAddr;\n  ReadAddr=Addr;\n  while (Count > 0)\n  {\n    Archive *SrcArc=(Archive *)SrcFile;\n\n    if (UnpackFromMemory)\n    {\n      memcpy(Addr,UnpackFromMemoryAddr,UnpackFromMemorySize);\n      ReadSize=(int)UnpackFromMemorySize;\n      UnpackFromMemorySize=0;\n    }\n    else\n    {\n      size_t SizeToRead=((int64)Count>UnpPackedSize) ? (size_t)UnpPackedSize:Count;\n      if (SizeToRead > 0)\n      {\n        if (UnpVolume && Decryption && (int64)Count>UnpPackedSize)\n        {\n          // We need aligned blocks for decryption and we want \"Keep broken\n          // files\" to work efficiently with missing encrypted volumes.\n          // So for last data block in volume we adjust the size to read to\n          // next equal or smaller block producing aligned total block size.\n          // So we'll ask for next volume only when processing few unaligned\n          // bytes left in the end, when most of data is already extracted.\n          size_t NewTotalRead = TotalRead + SizeToRead;\n          size_t Adjust = NewTotalRead - (NewTotalRead  & ~CRYPT_BLOCK_MASK);\n          size_t NewSizeToRead = SizeToRead - Adjust;\n          if ((int)NewSizeToRead > 0)\n            SizeToRead = NewSizeToRead;\n        }\n\n        if (!SrcFile->IsOpened())\n          return -1;\n        ReadSize=SrcFile->Read(ReadAddr,SizeToRead);\n        FileHeader *hd=SubHead!=NULL ? SubHead:&SrcArc->FileHead;\n        if (hd->SplitAfter)\n          PackedDataHash.Update(ReadAddr,ReadSize);\n      }\n    }\n    CurUnpRead+=ReadSize;\n    TotalRead+=ReadSize;\n#ifndef NOVOLUME\n    // These variable are not used in NOVOLUME mode, so it is better\n    // to exclude commands below to avoid compiler warnings.\n    ReadAddr+=ReadSize;\n    Count-=ReadSize;\n#endif\n    UnpPackedSize-=ReadSize;\n\n    // Do not ask for next volume if we read something from current volume.\n    // If next volume is missing, we need to process all data from current\n    // volume before aborting. It helps to recover all possible data\n    // in \"Keep broken files\" mode. But if we process encrypted data,\n    // we ask for next volume also if we have non-aligned encryption block.\n    // Since we adjust data size for decryption earlier above,\n    // it does not hurt \"Keep broken files\" mode efficiency.\n    if (UnpVolume && UnpPackedSize == 0 && \n        (ReadSize==0 || Decryption && (TotalRead & CRYPT_BLOCK_MASK) != 0) )\n    {\n#ifndef NOVOLUME\n      if (!MergeArchive(*SrcArc,this,true,CurrentCommand))\n#endif\n      {\n        NextVolumeMissing=true;\n        return -1;\n      }\n    }\n    else\n      break;\n  }\n  Archive *SrcArc=(Archive *)SrcFile;\n  if (SrcArc!=NULL)\n    ShowUnpRead(SrcArc->CurBlockPos+CurUnpRead,UnpArcSize);\n  if (ReadSize!=-1)\n  {\n    ReadSize=TotalRead;\n#ifndef RAR_NOCRYPT\n    if (Decryption)\n      Decrypt->DecryptBlock(Addr,ReadSize);\n#endif\n  }\n  Wait();\n  return ReadSize;\n}\n\n\n#if defined(RARDLL) && defined(_MSC_VER) && !defined(_WIN_64)\n// Disable the run time stack check for unrar.dll, so we can manipulate\n// with ProcessDataProc call type below. Run time check would intercept\n// a wrong ESP before we restore it.\n#pragma runtime_checks( \"s\", off )\n#endif\n\nvoid ComprDataIO::UnpWrite(byte *Addr,size_t Count)\n{\n\n#ifdef RARDLL\n  RAROptions *Cmd=((Archive *)SrcFile)->GetRAROptions();\n  if (Cmd->DllOpMode!=RAR_SKIP)\n  {\n    if (Cmd->Callback!=NULL &&\n        Cmd->Callback(UCM_PROCESSDATA,Cmd->UserData,(LPARAM)Addr,Count)==-1)\n      ErrHandler.Exit(RARX_USERBREAK);\n    if (Cmd->ProcessDataProc!=NULL)\n    {\n      // Here we preserve ESP value. It is necessary for those developers,\n      // who still define ProcessDataProc callback as \"C\" type function,\n      // even though in year 2001 we announced in unrar.dll whatsnew.txt\n      // that it will be PASCAL type (for compatibility with Visual Basic).\n#if defined(_MSC_VER)\n#ifndef _WIN_64\n      __asm mov ebx,esp\n#endif\n#elif defined(_WIN_ALL) && defined(__BORLANDC__)\n      _EBX=_ESP;\n#endif\n      int RetCode=Cmd->ProcessDataProc(Addr,(int)Count);\n\n      // Restore ESP after ProcessDataProc with wrongly defined calling\n      // convention broken it.\n#if defined(_MSC_VER)\n#ifndef _WIN_64\n      __asm mov esp,ebx\n#endif\n#elif defined(_WIN_ALL) && defined(__BORLANDC__)\n      _ESP=_EBX;\n#endif\n      if (RetCode==0)\n        ErrHandler.Exit(RARX_USERBREAK);\n    }\n  }\n#endif // RARDLL\n\n  UnpWrAddr=Addr;\n  UnpWrSize=Count;\n  if (UnpackToMemory)\n  {\n    if (Count <= UnpackToMemorySize)\n    {\n      memcpy(UnpackToMemoryAddr,Addr,Count);\n      UnpackToMemoryAddr+=Count;\n      UnpackToMemorySize-=Count;\n    }\n  }\n  else\n    if (!TestMode)\n      DestFile->Write(Addr,Count);\n  CurUnpWrite+=Count;\n  if (!SkipUnpCRC)\n    UnpHash.Update(Addr,Count);\n  ShowUnpWrite();\n  Wait();\n}\n\n#if defined(RARDLL) && defined(_MSC_VER) && !defined(_WIN_64)\n// Restore the run time stack check for unrar.dll.\n#pragma runtime_checks( \"s\", restore )\n#endif\n\n\n\n\n\n\nvoid ComprDataIO::ShowUnpRead(int64 ArcPos,int64 ArcSize)\n{\n  if (ShowProgress && SrcFile!=NULL)\n  {\n    if (TotalArcSize!=0)\n    {\n      // important when processing several archives or multivolume archive\n      ArcSize=TotalArcSize;\n      ArcPos+=ProcessedArcSize;\n    }\n\n    Archive *SrcArc=(Archive *)SrcFile;\n    RAROptions *Cmd=SrcArc->GetRAROptions();\n\n    int CurPercent=ToPercent(ArcPos,ArcSize);\n    if (!Cmd->DisablePercentage && CurPercent!=LastPercent)\n    {\n      uiExtractProgress(CurUnpWrite,SrcArc->FileHead.UnpSize,ArcPos,ArcSize);\n      LastPercent=CurPercent;\n    }\n  }\n}\n\n\nvoid ComprDataIO::ShowUnpWrite()\n{\n}\n\n\n\n\n\n\n\n\n\n\nvoid ComprDataIO::SetFiles(File *SrcFile,File *DestFile)\n{\n  if (SrcFile!=NULL)\n    ComprDataIO::SrcFile=SrcFile;\n  if (DestFile!=NULL)\n    ComprDataIO::DestFile=DestFile;\n  LastPercent=-1;\n}\n\n\nvoid ComprDataIO::GetUnpackedData(byte **Data,size_t *Size)\n{\n  *Data=UnpWrAddr;\n  *Size=UnpWrSize;\n}\n\n\nvoid ComprDataIO::SetEncryption(bool Encrypt,CRYPT_METHOD Method,\n     SecPassword *Password,const byte *Salt,const byte *InitV,\n     uint Lg2Cnt,byte *HashKey,byte *PswCheck)\n{\n#ifndef RAR_NOCRYPT\n  if (Encrypt)\n    Encryption=Crypt->SetCryptKeys(true,Method,Password,Salt,InitV,Lg2Cnt,HashKey,PswCheck);\n  else\n    Decryption=Decrypt->SetCryptKeys(false,Method,Password,Salt,InitV,Lg2Cnt,HashKey,PswCheck);\n#endif\n}\n\n\n#if !defined(SFX_MODULE) && !defined(RAR_NOCRYPT)\nvoid ComprDataIO::SetAV15Encryption()\n{\n  Decryption=true;\n  Decrypt->SetAV15Encryption();\n}\n#endif\n\n\n#if !defined(SFX_MODULE) && !defined(RAR_NOCRYPT)\nvoid ComprDataIO::SetCmt13Encryption()\n{\n  Decryption=true;\n  Decrypt->SetCmt13Encryption();\n}\n#endif\n\n\n\n\nvoid ComprDataIO::SetUnpackToMemory(byte *Addr,uint Size)\n{\n  UnpackToMemory=true;\n  UnpackToMemoryAddr=Addr;\n  UnpackToMemorySize=Size;\n}\n","#include \"rar.hpp\"\n\nRAROptions::RAROptions()\n{\n  Init();\n}\n\n\nRAROptions::~RAROptions()\n{\n  // It is important for security reasons, so we do not have the unnecessary\n  // password data left in memory.\n  memset(this,0,sizeof(RAROptions));\n}\n\n\nvoid RAROptions::Init()\n{\n  memset(this,0,sizeof(RAROptions));\n  WinSize=0x2000000;\n  Overwrite=OVERWRITE_DEFAULT;\n  Method=3;\n  MsgStream=MSG_STDOUT;\n  ConvertNames=NAMES_ORIGINALCASE;\n  xmtime=EXTTIME_HIGH3;\n  FileSizeLess=INT64NDF;\n  FileSizeMore=INT64NDF;\n  HashType=HASH_CRC32;\n#ifdef RAR_SMP\n  Threads=GetNumberOfThreads();\n#endif\n#ifdef USE_QOPEN\n  // changed from AUTO to NONE by klesun\n  // this is probably possible to pass from js somehow without changing the cpp code, but I dunno how\n  // changing this to NONE is necessary to skip integrity validation that\n  // jumps over all RAR file and fails with READ_ERROR if file is incomplete\n  QOpenMode=QOPEN_NONE;\n#endif\n}\n","#include \"rar.hpp\"\n\nErrorHandler::ErrorHandler()\n{\n  Clean();\n}\n\n\nvoid ErrorHandler::Clean()\n{\n  ExitCode=RARX_SUCCESS;\n  ErrCount=0;\n  EnableBreak=true;\n  Silent=false;\n  UserBreak=false;\n  MainExit=false;\n  DisableShutdown=false;\n}\n\n\nvoid ErrorHandler::MemoryError()\n{\n  MemoryErrorMsg();\n  Exit(RARX_MEMORY);\n}\n\n\nvoid ErrorHandler::OpenError(const wchar *FileName)\n{\n#ifndef SILENT\n  OpenErrorMsg(FileName);\n  Exit(RARX_OPEN);\n#endif\n}\n\n\nvoid ErrorHandler::CloseError(const wchar *FileName)\n{\n  if (!UserBreak)\n  {\n    uiMsg(UIERROR_FILECLOSE,FileName);\n    SysErrMsg();\n  }\n#if !defined(SILENT) || defined(RARDLL)\n  Exit(RARX_FATAL);\n#endif\n}\n\n\nvoid ErrorHandler::ReadError(const wchar *FileName)\n{\n#ifndef SILENT\n  ReadErrorMsg(FileName);\n#endif\n#if !defined(SILENT) || defined(RARDLL)\n  Exit(RARX_FATAL);\n#endif\n}\n\n\nbool ErrorHandler::AskRepeatRead(const wchar *FileName)\n{\n#if !defined(SILENT) && !defined(SFX_MODULE)\n  if (!Silent)\n  {\n    SysErrMsg();\n    bool Repeat=uiAskRepeatRead(FileName);\n    if (!Repeat) // Disable shutdown if user pressed Cancel in error dialog.\n      DisableShutdown=true;\n    return Repeat;\n  }\n#endif\n  return false;\n}\n\n\nvoid ErrorHandler::WriteError(const wchar *ArcName,const wchar *FileName)\n{\n#ifndef SILENT\n  WriteErrorMsg(ArcName,FileName);\n#endif\n#if !defined(SILENT) || defined(RARDLL)\n  Exit(RARX_WRITE);\n#endif\n}\n\n\n#ifdef _WIN_ALL\nvoid ErrorHandler::WriteErrorFAT(const wchar *FileName)\n{\n  SysErrMsg();\n  uiMsg(UIERROR_NTFSREQUIRED,FileName);\n#if !defined(SILENT) && !defined(SFX_MODULE) || defined(RARDLL)\n  Exit(RARX_WRITE);\n#endif\n}\n#endif\n\n\nbool ErrorHandler::AskRepeatWrite(const wchar *FileName,bool DiskFull)\n{\n#ifndef SILENT\n  if (!Silent)\n  {\n#ifndef _ANDROID\n    // We do not display \"repeat write\" prompt in Android, so we do not\n    // need the matching system error message.\n    SysErrMsg();\n#endif\n    bool Repeat=uiAskRepeatWrite(FileName,DiskFull);\n    if (!Repeat) // Disable shutdown if user pressed Cancel in error dialog.\n      DisableShutdown=true;\n    return Repeat;\n  }\n#endif\n  return false;\n}\n\n\nvoid ErrorHandler::SeekError(const wchar *FileName)\n{\n  if (!UserBreak)\n  {\n    uiMsg(UIERROR_FILESEEK,FileName);\n    SysErrMsg();\n  }\n#if !defined(SILENT) || defined(RARDLL)\n  Exit(RARX_FATAL);\n#endif\n}\n\n\nvoid ErrorHandler::GeneralErrMsg(const wchar *fmt,...)\n{\n  va_list arglist;\n  va_start(arglist,fmt);\n  wchar Msg[1024];\n#ifdef _ANDROID\n  // vswprintf does not work in Android NDK. Conversion below should be ok\n  // as long as we do not pass Unicode strings in arguments.\n  char fmtA[NM],MsgA[ASIZE(Msg)];\n  WideToChar(fmt,fmtA,ASIZE(fmtA));\n  vsnprintf(MsgA,ASIZE(MsgA),fmtA,arglist);\n  CharToWide(MsgA,Msg,ASIZE(Msg));\n#else\n  vswprintf(Msg,ASIZE(Msg),fmt,arglist);\n#endif\n  uiMsg(UIERROR_GENERALERRMSG,Msg);\n  SysErrMsg();\n  va_end(arglist);\n}\n\n\nvoid ErrorHandler::MemoryErrorMsg()\n{\n  uiMsg(UIERROR_MEMORY);\n  SetErrorCode(RARX_MEMORY);\n}\n\n\nvoid ErrorHandler::OpenErrorMsg(const wchar *FileName)\n{\n  OpenErrorMsg(NULL,FileName);\n}\n\n\nvoid ErrorHandler::OpenErrorMsg(const wchar *ArcName,const wchar *FileName)\n{\n  uiMsg(UIERROR_FILEOPEN,ArcName,FileName);\n  SysErrMsg();\n  SetErrorCode(RARX_OPEN);\n}\n\n\nvoid ErrorHandler::CreateErrorMsg(const wchar *FileName)\n{\n  CreateErrorMsg(NULL,FileName);\n}\n\n\nvoid ErrorHandler::CreateErrorMsg(const wchar *ArcName,const wchar *FileName)\n{\n  uiMsg(UIERROR_FILECREATE,ArcName,FileName);\n  SysErrMsg();\n  SetErrorCode(RARX_CREATE);\n}\n\n\nvoid ErrorHandler::ReadErrorMsg(const wchar *FileName)\n{\n  ReadErrorMsg(NULL,FileName);\n}\n\n\nvoid ErrorHandler::ReadErrorMsg(const wchar *ArcName,const wchar *FileName)\n{\n  uiMsg(UIERROR_FILEREAD,ArcName,FileName);\n  SysErrMsg();\n  SetErrorCode(RARX_FATAL);\n}\n\n\nvoid ErrorHandler::WriteErrorMsg(const wchar *ArcName,const wchar *FileName)\n{\n  uiMsg(UIERROR_FILEWRITE,ArcName,FileName);\n  SysErrMsg();\n  SetErrorCode(RARX_WRITE);\n}\n\n\nvoid ErrorHandler::ArcBrokenMsg(const wchar *ArcName)\n{\n  uiMsg(UIERROR_ARCBROKEN,ArcName);\n  SetErrorCode(RARX_CRC);\n}\n\n\nvoid ErrorHandler::ChecksumFailedMsg(const wchar *ArcName,const wchar *FileName)\n{\n  uiMsg(UIERROR_CHECKSUM,ArcName,FileName);\n  SetErrorCode(RARX_CRC);\n}\n\n\nvoid ErrorHandler::UnknownMethodMsg(const wchar *ArcName,const wchar *FileName)\n{\n  uiMsg(UIERROR_UNKNOWNMETHOD,ArcName,FileName);\n  ErrHandler.SetErrorCode(RARX_FATAL);\n}\n\n\nvoid ErrorHandler::Exit(RAR_EXIT ExitCode)\n{\n#ifndef GUI\n  uiAlarm(UIALARM_ERROR);\n#endif\n  Throw(ExitCode);\n}\n\n\nvoid ErrorHandler::SetErrorCode(RAR_EXIT Code)\n{\n  switch(Code)\n  {\n    case RARX_WARNING:\n    case RARX_USERBREAK:\n      if (ExitCode==RARX_SUCCESS)\n        ExitCode=Code;\n      break;\n    case RARX_CRC:\n      if (ExitCode!=RARX_BADPWD)\n        ExitCode=Code;\n      break;\n    case RARX_FATAL:\n      if (ExitCode==RARX_SUCCESS || ExitCode==RARX_WARNING)\n        ExitCode=RARX_FATAL;\n      break;\n    default:\n      ExitCode=Code;\n      break;\n  }\n  ErrCount++;\n}\n\n\n#ifndef GUI\n#ifdef _WIN_ALL\nBOOL __stdcall ProcessSignal(DWORD SigType)\n#else\n#if defined(__sun)\nextern \"C\"\n#endif\nvoid _stdfunction ProcessSignal(int SigType)\n#endif\n{\n#ifdef _WIN_ALL\n  // When a console application is run as a service, this allows the service\n  // to continue running after the user logs off. \n  if (SigType==CTRL_LOGOFF_EVENT)\n    return TRUE;\n#endif\n\n  ErrHandler.UserBreak=true;\n  mprintf(St(MBreak));\n\n#ifdef _WIN_ALL\n  // Let the main thread to handle 'throw' and destroy file objects.\n  for (uint I=0;!ErrHandler.MainExit && I<50;I++)\n    Sleep(100);\n#if defined(USE_RC) && !defined(SFX_MODULE) && !defined(RARDLL)\n  ExtRes.UnloadDLL();\n#endif\n  exit(RARX_USERBREAK);\n#endif\n\n#ifdef _UNIX\n  static uint BreakCount=0;\n  // User continues to press Ctrl+C, exit immediately without cleanup.\n  if (++BreakCount>1)\n    exit(RARX_USERBREAK);\n  // Otherwise return from signal handler and let Wait() function to close\n  // files and quit. We cannot use the same approach as in Windows,\n  // because Unix signal handler can block execution of our main code.\n#endif\n\n#if defined(_WIN_ALL) && !defined(_MSC_VER)\n  // never reached, just to avoid a compiler warning\n  return TRUE;\n#endif\n}\n#endif\n\n\nvoid ErrorHandler::SetSignalHandlers(bool Enable)\n{\n  EnableBreak=Enable;\n#ifndef GUI\n#ifdef _WIN_ALL\n  SetConsoleCtrlHandler(Enable ? ProcessSignal:NULL,TRUE);\n#else\n  signal(SIGINT,Enable ? ProcessSignal:SIG_IGN);\n  signal(SIGTERM,Enable ? ProcessSignal:SIG_IGN);\n#endif\n#endif\n}\n\n\nvoid ErrorHandler::Throw(RAR_EXIT Code)\n{\n  if (Code==RARX_USERBREAK && !EnableBreak)\n    return;\n#if !defined(GUI) && !defined(SILENT)\n  // Do not write \"aborted\" when just displaying online help.\n  if (Code!=RARX_SUCCESS && Code!=RARX_USERERROR)\n    mprintf(L\"\\n%s\\n\",St(MProgAborted));\n#endif\n  SetErrorCode(Code);\n  throw Code;\n}\n\n\nvoid ErrorHandler::SysErrMsg()\n{\n#if !defined(SFX_MODULE) && !defined(SILENT)\n#ifdef _WIN_ALL\n  wchar *lpMsgBuf=NULL;\n  int ErrType=GetLastError();\n  if (ErrType!=0 && FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM,\n              NULL,ErrType,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n              (LPTSTR)&lpMsgBuf,0,NULL))\n  {\n    wchar *CurMsg=lpMsgBuf;\n    while (CurMsg!=NULL)\n    {\n      while (*CurMsg=='\\r' || *CurMsg=='\\n')\n        CurMsg++;\n      if (*CurMsg==0)\n        break;\n      wchar *EndMsg=wcschr(CurMsg,'\\r');\n      if (EndMsg==NULL)\n        EndMsg=wcschr(CurMsg,'\\n');\n      if (EndMsg!=NULL)\n      {\n        *EndMsg=0;\n        EndMsg++;\n      }\n      uiMsg(UIERROR_SYSERRMSG,CurMsg);\n      CurMsg=EndMsg;\n    }\n  }\n  LocalFree( lpMsgBuf );\n#endif\n\n#if defined(_UNIX) || defined(_EMX)\n  if (errno!=0)\n  {\n#ifdef _ANDROID\n    // Android NDK sets errno to confusing \"not a typewriter\" ENOTTY code\n    // after write error reported by write().\n    if (errno == ENOTTY)\n      return;\n#endif\n    char *err=strerror(errno);\n    if (err!=NULL)\n    {\n      wchar Msg[1024];\n      CharToWide(err,Msg,ASIZE(Msg));\n      uiMsg(UIERROR_SYSERRMSG,Msg);\n    }\n  }\n#endif\n\n#endif\n}\n\n\nint ErrorHandler::GetSystemErrorCode()\n{\n#ifdef _WIN_ALL\n  return GetLastError();\n#else\n  return errno;\n#endif\n}\n\n\nvoid ErrorHandler::SetSystemErrorCode(int Code)\n{\n#ifdef _WIN_ALL\n  SetLastError(Code);\n#else\n  errno=Code;\n#endif\n}\n","#include \"rar.hpp\"\n\n#include \"rarvmtbl.cpp\"\n\nRarVM::RarVM()\n:BitInput(true)\n{\n  Mem=NULL;\n}\n\n\nRarVM::~RarVM()\n{\n  delete[] Mem;\n}\n\n\nvoid RarVM::Init()\n{\n  if (Mem==NULL)\n    Mem=new byte[VM_MEMSIZE+4];\n}\n\n/*********************************************************************\n IS_VM_MEM macro checks if address belongs to VM memory pool (Mem).\n Only Mem data are always low endian regardless of machine architecture,\n so we need to convert them to native format when reading or writing.\n VM registers have endianness of host machine.\n**********************************************************************/\n#define IS_VM_MEM(a) (((byte*)a)>=Mem && ((byte*)a)<Mem+VM_MEMSIZE)\n\ninline uint RarVM::GetValue(bool ByteMode,uint *Addr)\n{\n  if (ByteMode)\n  {\n#ifdef BIG_ENDIAN\n    if (IS_VM_MEM(Addr))\n      return(*(byte *)Addr);\n    else\n      return(*Addr & 0xff);\n#else\n    return(*(byte *)Addr);\n#endif\n  }\n  else\n  {\n#if defined(BIG_ENDIAN) || !defined(ALLOW_MISALIGNED)\n    if (IS_VM_MEM(Addr))\n    {\n      byte *B=(byte *)Addr;\n      return GET_UINT32((uint)B[0]|((uint)B[1]<<8)|((uint)B[2]<<16)|((uint)B[3]<<24));\n    }\n    else\n      return GET_UINT32(*Addr);\n#else\n    return GET_UINT32(*Addr);\n#endif\n  }\n}\n\n#if defined(BIG_ENDIAN) || !defined(ALLOW_MISALIGNED)\n  #define GET_VALUE(ByteMode,Addr) GetValue(ByteMode,(uint *)Addr)\n#else\n  #define GET_VALUE(ByteMode,Addr) ((ByteMode) ? (*(byte *)(Addr)):GET_UINT32(*(uint *)(Addr)))\n#endif\n\n\ninline void RarVM::SetValue(bool ByteMode,uint *Addr,uint Value)\n{\n  if (ByteMode)\n  {\n#ifdef BIG_ENDIAN\n    if (IS_VM_MEM(Addr))\n      *(byte *)Addr=Value;\n    else\n      *Addr=(*Addr & ~0xff)|(Value & 0xff);\n#else\n    *(byte *)Addr=Value;\n#endif\n  }\n  else\n  {\n#if defined(BIG_ENDIAN) || !defined(ALLOW_MISALIGNED) || !defined(PRESENT_INT32)\n    if (IS_VM_MEM(Addr))\n    {\n      ((byte *)Addr)[0]=(byte)Value;\n      ((byte *)Addr)[1]=(byte)(Value>>8);\n      ((byte *)Addr)[2]=(byte)(Value>>16);\n      ((byte *)Addr)[3]=(byte)(Value>>24);\n    }\n    else\n      *(uint *)Addr=Value;\n#else\n    *(uint32 *)Addr=Value;\n#endif\n  }\n}\n\n#if defined(BIG_ENDIAN) || !defined(ALLOW_MISALIGNED) || !defined(PRESENT_INT32)\n  #define SET_VALUE(ByteMode,Addr,Value) SetValue(ByteMode,(uint *)Addr,Value)\n#else\n  #define SET_VALUE(ByteMode,Addr,Value) ((ByteMode) ? (*(byte *)(Addr)=((byte)(Value))):(*(uint32 *)(Addr)=((uint32)(Value))))\n#endif\n\n\nvoid RarVM::SetLowEndianValue(uint *Addr,uint Value)\n{\n#if defined(BIG_ENDIAN) || !defined(ALLOW_MISALIGNED) || !defined(PRESENT_INT32)\n  ((byte *)Addr)[0]=(byte)Value;\n  ((byte *)Addr)[1]=(byte)(Value>>8);\n  ((byte *)Addr)[2]=(byte)(Value>>16);\n  ((byte *)Addr)[3]=(byte)(Value>>24);\n#else\n  *(uint32 *)Addr=Value;\n#endif\n}\n\n\ninline uint* RarVM::GetOperand(VM_PreparedOperand *CmdOp)\n{\n  if (CmdOp->Type==VM_OPREGMEM)\n    return((uint *)&Mem[(*CmdOp->Addr+CmdOp->Base)&VM_MEMMASK]);\n  else\n    return(CmdOp->Addr);\n}\n\n\nvoid RarVM::Execute(VM_PreparedProgram *Prg)\n{\n  memcpy(R,Prg->InitR,sizeof(Prg->InitR));\n  size_t GlobalSize=Min(Prg->GlobalData.Size(),VM_GLOBALMEMSIZE);\n  if (GlobalSize)\n    memcpy(Mem+VM_GLOBALMEMADDR,&Prg->GlobalData[0],GlobalSize);\n  size_t StaticSize=Min(Prg->StaticData.Size(),VM_GLOBALMEMSIZE-GlobalSize);\n  if (StaticSize)\n    memcpy(Mem+VM_GLOBALMEMADDR+GlobalSize,&Prg->StaticData[0],StaticSize);\n\n  R[7]=VM_MEMSIZE;\n  Flags=0;\n\n  VM_PreparedCommand *PreparedCode=Prg->AltCmd ? Prg->AltCmd:&Prg->Cmd[0];\n  if (Prg->CmdCount>0 && !ExecuteCode(PreparedCode,Prg->CmdCount))\n  {\n    // Invalid VM program. Let's replace it with 'return' command.\n    PreparedCode[0].OpCode=VM_RET;\n  }\n  uint NewBlockPos=GET_VALUE(false,&Mem[VM_GLOBALMEMADDR+0x20])&VM_MEMMASK;\n  uint NewBlockSize=GET_VALUE(false,&Mem[VM_GLOBALMEMADDR+0x1c])&VM_MEMMASK;\n  if (NewBlockPos+NewBlockSize>=VM_MEMSIZE)\n    NewBlockPos=NewBlockSize=0;\n  Prg->FilteredData=Mem+NewBlockPos;\n  Prg->FilteredDataSize=NewBlockSize;\n\n  Prg->GlobalData.Reset();\n\n  uint DataSize=Min(GET_VALUE(false,(uint*)&Mem[VM_GLOBALMEMADDR+0x30]),VM_GLOBALMEMSIZE-VM_FIXEDGLOBALSIZE);\n  if (DataSize!=0)\n  {\n    Prg->GlobalData.Add(DataSize+VM_FIXEDGLOBALSIZE);\n    memcpy(&Prg->GlobalData[0],&Mem[VM_GLOBALMEMADDR],DataSize+VM_FIXEDGLOBALSIZE);\n  }\n}\n\n\n/*\nNote:\n  Due to performance considerations RAR VM may set VM_FS, VM_FC, VM_FZ\n  incorrectly for byte operands. These flags are always valid only\n  for 32-bit operands. Check implementation of concrete VM command\n  to see if it sets flags right.\n*/\n\n#define SET_IP(IP)                      \\\n  if ((IP)>=CodeSize)                   \\\n    return(true);                       \\\n  if (--MaxOpCount<=0)                  \\\n    return(false);                      \\\n  Cmd=PreparedCode+(IP);\n\nbool RarVM::ExecuteCode(VM_PreparedCommand *PreparedCode,uint CodeSize)\n{\n  int MaxOpCount=25000000;\n  VM_PreparedCommand *Cmd=PreparedCode;\n  while (1)\n  {\n#ifndef NORARVM\n    // Get addresses to quickly access operands.\n    uint *Op1=GetOperand(&Cmd->Op1);\n    uint *Op2=GetOperand(&Cmd->Op2);\n#endif\n    switch(Cmd->OpCode)\n    {\n#ifndef NORARVM\n      case VM_MOV:\n        SET_VALUE(Cmd->ByteMode,Op1,GET_VALUE(Cmd->ByteMode,Op2));\n        break;\n#ifdef VM_OPTIMIZE\n      case VM_MOVB:\n        SET_VALUE(true,Op1,GET_VALUE(true,Op2));\n        break;\n      case VM_MOVD:\n        SET_VALUE(false,Op1,GET_VALUE(false,Op2));\n        break;\n#endif\n      case VM_CMP:\n        {\n          uint Value1=GET_VALUE(Cmd->ByteMode,Op1);\n          uint Result=GET_UINT32(Value1-GET_VALUE(Cmd->ByteMode,Op2));\n          Flags=Result==0 ? VM_FZ:(Result>Value1)|(Result&VM_FS);\n        }\n        break;\n#ifdef VM_OPTIMIZE\n      case VM_CMPB:\n        {\n          uint Value1=GET_VALUE(true,Op1);\n          uint Result=GET_UINT32(Value1-GET_VALUE(true,Op2));\n          Flags=Result==0 ? VM_FZ:(Result>Value1)|(Result&VM_FS);\n        }\n        break;\n      case VM_CMPD:\n        {\n          uint Value1=GET_VALUE(false,Op1);\n          uint Result=GET_UINT32(Value1-GET_VALUE(false,Op2));\n          Flags=Result==0 ? VM_FZ:(Result>Value1)|(Result&VM_FS);\n        }\n        break;\n#endif\n      case VM_ADD:\n        {\n          uint Value1=GET_VALUE(Cmd->ByteMode,Op1);\n          uint Result=GET_UINT32(Value1+GET_VALUE(Cmd->ByteMode,Op2));\n          if (Cmd->ByteMode)\n          {\n            Result&=0xff;\n            Flags=(Result<Value1)|(Result==0 ? VM_FZ:((Result&0x80) ? VM_FS:0));\n          }\n          else\n            Flags=(Result<Value1)|(Result==0 ? VM_FZ:(Result&VM_FS));\n          SET_VALUE(Cmd->ByteMode,Op1,Result);\n        }\n        break;\n#ifdef VM_OPTIMIZE\n      case VM_ADDB:\n        SET_VALUE(true,Op1,GET_VALUE(true,Op1)+GET_VALUE(true,Op2));\n        break;\n      case VM_ADDD:\n        SET_VALUE(false,Op1,GET_VALUE(false,Op1)+GET_VALUE(false,Op2));\n        break;\n#endif\n      case VM_SUB:\n        {\n          uint Value1=GET_VALUE(Cmd->ByteMode,Op1);\n          uint Result=GET_UINT32(Value1-GET_VALUE(Cmd->ByteMode,Op2));\n          Flags=Result==0 ? VM_FZ:(Result>Value1)|(Result&VM_FS);\n          SET_VALUE(Cmd->ByteMode,Op1,Result);\n        }\n        break;\n#ifdef VM_OPTIMIZE\n      case VM_SUBB:\n        SET_VALUE(true,Op1,GET_VALUE(true,Op1)-GET_VALUE(true,Op2));\n        break;\n      case VM_SUBD:\n        SET_VALUE(false,Op1,GET_VALUE(false,Op1)-GET_VALUE(false,Op2));\n        break;\n#endif\n      case VM_JZ:\n        if ((Flags & VM_FZ)!=0)\n        {\n          SET_IP(GET_VALUE(false,Op1));\n          continue;\n        }\n        break;\n      case VM_JNZ:\n        if ((Flags & VM_FZ)==0)\n        {\n          SET_IP(GET_VALUE(false,Op1));\n          continue;\n        }\n        break;\n      case VM_INC:\n        {\n          uint Result=GET_UINT32(GET_VALUE(Cmd->ByteMode,Op1)+1);\n          if (Cmd->ByteMode)\n            Result&=0xff;\n          SET_VALUE(Cmd->ByteMode,Op1,Result);\n          Flags=Result==0 ? VM_FZ:Result&VM_FS;\n        }\n        break;\n#ifdef VM_OPTIMIZE\n      case VM_INCB:\n        SET_VALUE(true,Op1,GET_VALUE(true,Op1)+1);\n        break;\n      case VM_INCD:\n        SET_VALUE(false,Op1,GET_VALUE(false,Op1)+1);\n        break;\n#endif\n      case VM_DEC:\n        {\n          uint Result=GET_UINT32(GET_VALUE(Cmd->ByteMode,Op1)-1);\n          SET_VALUE(Cmd->ByteMode,Op1,Result);\n          Flags=Result==0 ? VM_FZ:Result&VM_FS;\n        }\n        break;\n#ifdef VM_OPTIMIZE\n      case VM_DECB:\n        SET_VALUE(true,Op1,GET_VALUE(true,Op1)-1);\n        break;\n      case VM_DECD:\n        SET_VALUE(false,Op1,GET_VALUE(false,Op1)-1);\n        break;\n#endif\n      case VM_JMP:\n        SET_IP(GET_VALUE(false,Op1));\n        continue;\n      case VM_XOR:\n        {\n          uint Result=GET_UINT32(GET_VALUE(Cmd->ByteMode,Op1)^GET_VALUE(Cmd->ByteMode,Op2));\n          Flags=Result==0 ? VM_FZ:Result&VM_FS;\n          SET_VALUE(Cmd->ByteMode,Op1,Result);\n        }\n        break;\n      case VM_AND:\n        {\n          uint Result=GET_UINT32(GET_VALUE(Cmd->ByteMode,Op1)&GET_VALUE(Cmd->ByteMode,Op2));\n          Flags=Result==0 ? VM_FZ:Result&VM_FS;\n          SET_VALUE(Cmd->ByteMode,Op1,Result);\n        }\n        break;\n      case VM_OR:\n        {\n          uint Result=GET_UINT32(GET_VALUE(Cmd->ByteMode,Op1)|GET_VALUE(Cmd->ByteMode,Op2));\n          Flags=Result==0 ? VM_FZ:Result&VM_FS;\n          SET_VALUE(Cmd->ByteMode,Op1,Result);\n        }\n        break;\n      case VM_TEST:\n        {\n          uint Result=GET_UINT32(GET_VALUE(Cmd->ByteMode,Op1)&GET_VALUE(Cmd->ByteMode,Op2));\n          Flags=Result==0 ? VM_FZ:Result&VM_FS;\n        }\n        break;\n      case VM_JS:\n        if ((Flags & VM_FS)!=0)\n        {\n          SET_IP(GET_VALUE(false,Op1));\n          continue;\n        }\n        break;\n      case VM_JNS:\n        if ((Flags & VM_FS)==0)\n        {\n          SET_IP(GET_VALUE(false,Op1));\n          continue;\n        }\n        break;\n      case VM_JB:\n        if ((Flags & VM_FC)!=0)\n        {\n          SET_IP(GET_VALUE(false,Op1));\n          continue;\n        }\n        break;\n      case VM_JBE:\n        if ((Flags & (VM_FC|VM_FZ))!=0)\n        {\n          SET_IP(GET_VALUE(false,Op1));\n          continue;\n        }\n        break;\n      case VM_JA:\n        if ((Flags & (VM_FC|VM_FZ))==0)\n        {\n          SET_IP(GET_VALUE(false,Op1));\n          continue;\n        }\n        break;\n      case VM_JAE:\n        if ((Flags & VM_FC)==0)\n        {\n          SET_IP(GET_VALUE(false,Op1));\n          continue;\n        }\n        break;\n      case VM_PUSH:\n        R[7]-=4;\n        SET_VALUE(false,(uint *)&Mem[R[7]&VM_MEMMASK],GET_VALUE(false,Op1));\n        break;\n      case VM_POP:\n        SET_VALUE(false,Op1,GET_VALUE(false,(uint *)&Mem[R[7] & VM_MEMMASK]));\n        R[7]+=4;\n        break;\n      case VM_CALL:\n        R[7]-=4;\n        SET_VALUE(false,(uint *)&Mem[R[7]&VM_MEMMASK],Cmd-PreparedCode+1);\n        SET_IP(GET_VALUE(false,Op1));\n        continue;\n      case VM_NOT:\n        SET_VALUE(Cmd->ByteMode,Op1,~GET_VALUE(Cmd->ByteMode,Op1));\n        break;\n      case VM_SHL:\n        {\n          uint Value1=GET_VALUE(Cmd->ByteMode,Op1);\n          uint Value2=GET_VALUE(Cmd->ByteMode,Op2);\n          uint Result=GET_UINT32(Value1<<Value2);\n          Flags=(Result==0 ? VM_FZ:(Result&VM_FS))|((Value1<<(Value2-1))&0x80000000 ? VM_FC:0);\n          SET_VALUE(Cmd->ByteMode,Op1,Result);\n        }\n        break;\n      case VM_SHR:\n        {\n          uint Value1=GET_VALUE(Cmd->ByteMode,Op1);\n          uint Value2=GET_VALUE(Cmd->ByteMode,Op2);\n          uint Result=GET_UINT32(Value1>>Value2);\n          Flags=(Result==0 ? VM_FZ:(Result&VM_FS))|((Value1>>(Value2-1))&VM_FC);\n          SET_VALUE(Cmd->ByteMode,Op1,Result);\n        }\n        break;\n      case VM_SAR:\n        {\n          uint Value1=GET_VALUE(Cmd->ByteMode,Op1);\n          uint Value2=GET_VALUE(Cmd->ByteMode,Op2);\n          uint Result=GET_UINT32(((int)Value1)>>Value2);\n          Flags=(Result==0 ? VM_FZ:(Result&VM_FS))|((Value1>>(Value2-1))&VM_FC);\n          SET_VALUE(Cmd->ByteMode,Op1,Result);\n        }\n        break;\n      case VM_NEG:\n        {\n          // We use \"0-value\" expression to suppress \"unary minus to unsigned\"\n          // compiler warning.\n          uint Result=GET_UINT32(0-GET_VALUE(Cmd->ByteMode,Op1));\n          Flags=Result==0 ? VM_FZ:VM_FC|(Result&VM_FS);\n          SET_VALUE(Cmd->ByteMode,Op1,Result);\n        }\n        break;\n#ifdef VM_OPTIMIZE\n      case VM_NEGB:\n        SET_VALUE(true,Op1,0-GET_VALUE(true,Op1));\n        break;\n      case VM_NEGD:\n        SET_VALUE(false,Op1,0-GET_VALUE(false,Op1));\n        break;\n#endif\n      case VM_PUSHA:\n        {\n          const int RegCount=sizeof(R)/sizeof(R[0]);\n          for (int I=0,SP=R[7]-4;I<RegCount;I++,SP-=4)\n            SET_VALUE(false,(uint *)&Mem[SP & VM_MEMMASK],R[I]);\n          R[7]-=RegCount*4;\n        }\n        break;\n      case VM_POPA:\n        {\n          const int RegCount=sizeof(R)/sizeof(R[0]);\n          for (uint I=0,SP=R[7];I<RegCount;I++,SP+=4)\n            R[7-I]=GET_VALUE(false,(uint *)&Mem[SP & VM_MEMMASK]);\n        }\n        break;\n      case VM_PUSHF:\n        R[7]-=4;\n        SET_VALUE(false,(uint *)&Mem[R[7]&VM_MEMMASK],Flags);\n        break;\n      case VM_POPF:\n        Flags=GET_VALUE(false,(uint *)&Mem[R[7] & VM_MEMMASK]);\n        R[7]+=4;\n        break;\n      case VM_MOVZX:\n        SET_VALUE(false,Op1,GET_VALUE(true,Op2));\n        break;\n      case VM_MOVSX:\n        SET_VALUE(false,Op1,(signed char)GET_VALUE(true,Op2));\n        break;\n      case VM_XCHG:\n        {\n          uint Value1=GET_VALUE(Cmd->ByteMode,Op1);\n          SET_VALUE(Cmd->ByteMode,Op1,GET_VALUE(Cmd->ByteMode,Op2));\n          SET_VALUE(Cmd->ByteMode,Op2,Value1);\n        }\n        break;\n      case VM_MUL:\n        {\n          uint Result=GET_VALUE(Cmd->ByteMode,Op1)*GET_VALUE(Cmd->ByteMode,Op2);\n          SET_VALUE(Cmd->ByteMode,Op1,Result);\n        }\n        break;\n      case VM_DIV:\n        {\n          uint Divider=GET_VALUE(Cmd->ByteMode,Op2);\n          if (Divider!=0)\n          {\n            uint Result=GET_VALUE(Cmd->ByteMode,Op1)/Divider;\n            SET_VALUE(Cmd->ByteMode,Op1,Result);\n          }\n        }\n        break;\n      case VM_ADC:\n        {\n          uint Value1=GET_VALUE(Cmd->ByteMode,Op1);\n          uint FC=(Flags&VM_FC);\n          uint Result=GET_UINT32(Value1+GET_VALUE(Cmd->ByteMode,Op2)+FC);\n          if (Cmd->ByteMode)\n            Result&=0xff;\n          Flags=(Result<Value1 || Result==Value1 && FC)|(Result==0 ? VM_FZ:(Result&VM_FS));\n          SET_VALUE(Cmd->ByteMode,Op1,Result);\n        }\n        break;\n      case VM_SBB:\n        {\n          uint Value1=GET_VALUE(Cmd->ByteMode,Op1);\n          uint FC=(Flags&VM_FC);\n          uint Result=GET_UINT32(Value1-GET_VALUE(Cmd->ByteMode,Op2)-FC);\n          if (Cmd->ByteMode)\n            Result&=0xff;\n          Flags=(Result>Value1 || Result==Value1 && FC)|(Result==0 ? VM_FZ:(Result&VM_FS));\n          SET_VALUE(Cmd->ByteMode,Op1,Result);\n        }\n        break;\n#endif  // for #ifndef NORARVM\n      case VM_RET:\n        if (R[7]>=VM_MEMSIZE)\n          return(true);\n        SET_IP(GET_VALUE(false,(uint *)&Mem[R[7] & VM_MEMMASK]));\n        R[7]+=4;\n        continue;\n#ifdef VM_STANDARDFILTERS\n      case VM_STANDARD:\n        ExecuteStandardFilter((VM_StandardFilters)Cmd->Op1.Data);\n        return true;\n#endif\n      case VM_PRINT:\n        break;\n    }\n    Cmd++;\n    --MaxOpCount;\n  }\n}\n\n\n\n\nvoid RarVM::Prepare(byte *Code,uint CodeSize,VM_PreparedProgram *Prg)\n{\n  InitBitInput();\n  memcpy(InBuf,Code,Min(CodeSize,BitInput::MAX_SIZE));\n\n  // Calculate the single byte XOR checksum to check validity of VM code.\n  byte XorSum=0;\n  for (uint I=1;I<CodeSize;I++)\n    XorSum^=Code[I];\n\n  faddbits(8);\n\n  Prg->CmdCount=0;\n  if (XorSum==Code[0]) // VM code is valid if equal.\n  {\n#ifdef VM_STANDARDFILTERS\n    VM_StandardFilters FilterType=IsStandardFilter(Code,CodeSize);\n    if (FilterType!=VMSF_NONE)\n    {\n      // VM code is found among standard filters.\n      Prg->Cmd.Add(1);\n      VM_PreparedCommand *CurCmd=&Prg->Cmd[Prg->CmdCount++];\n      CurCmd->OpCode=VM_STANDARD;\n      CurCmd->Op1.Data=FilterType;\n      CurCmd->Op1.Addr=&CurCmd->Op1.Data;\n      CurCmd->Op2.Addr=&CurCmd->Op2.Data;\n      CurCmd->Op1.Type=CurCmd->Op2.Type=VM_OPNONE;\n      CodeSize=0;\n      return;\n    }\n#endif  \n#ifndef NORARVM\n    uint DataFlag=fgetbits();\n    faddbits(1);\n\n    // Read static data contained in DB operators. This data cannot be\n    // changed, it is a part of VM code, not a filter parameter.\n\n    if (DataFlag&0x8000)\n    {\n      uint DataSize=ReadData(*this)+1;\n      for (uint I=0;(uint)InAddr<CodeSize && I<DataSize;I++)\n      {\n        Prg->StaticData.Add(1);\n        Prg->StaticData[I]=fgetbits()>>8;\n        faddbits(8);\n      }\n    }\n\n    while ((uint)InAddr<CodeSize)\n    {\n      Prg->Cmd.Add(1);\n      VM_PreparedCommand *CurCmd=&Prg->Cmd[Prg->CmdCount];\n      uint Data=fgetbits();\n      if ((Data&0x8000)==0)\n      {\n        CurCmd->OpCode=(VM_Commands)(Data>>12);\n        faddbits(4);\n      }\n      else\n      {\n        CurCmd->OpCode=(VM_Commands)((Data>>10)-24);\n        faddbits(6);\n      }\n      if (VM_CmdFlags[CurCmd->OpCode] & VMCF_BYTEMODE)\n      {\n        CurCmd->ByteMode=(fgetbits()>>15)!=0;\n        faddbits(1);\n      }\n      else\n        CurCmd->ByteMode=0;\n      CurCmd->Op1.Type=CurCmd->Op2.Type=VM_OPNONE;\n      int OpNum=(VM_CmdFlags[CurCmd->OpCode] & VMCF_OPMASK);\n      CurCmd->Op1.Addr=CurCmd->Op2.Addr=NULL;\n      if (OpNum>0)\n      {\n        DecodeArg(CurCmd->Op1,CurCmd->ByteMode); // reading the first operand\n        if (OpNum==2)\n          DecodeArg(CurCmd->Op2,CurCmd->ByteMode); // reading the second operand\n        else\n        {\n          if (CurCmd->Op1.Type==VM_OPINT && (VM_CmdFlags[CurCmd->OpCode]&(VMCF_JUMP|VMCF_PROC)))\n          {\n            // Calculating jump distance.\n            int Distance=CurCmd->Op1.Data;\n            if (Distance>=256)\n              Distance-=256;\n            else\n            {\n              if (Distance>=136)\n                Distance-=264;\n              else\n                if (Distance>=16)\n                  Distance-=8;\n                else\n                  if (Distance>=8)\n                    Distance-=16;\n              Distance+=Prg->CmdCount;\n            }\n            CurCmd->Op1.Data=Distance;\n          }\n        }\n      }\n      Prg->CmdCount++;\n    }\n#endif\n  }\n\n  // Adding RET command at the end of program.\n  Prg->Cmd.Add(1);\n  VM_PreparedCommand *CurCmd=&Prg->Cmd[Prg->CmdCount++];\n  CurCmd->OpCode=VM_RET;\n  CurCmd->Op1.Addr=&CurCmd->Op1.Data;\n  CurCmd->Op2.Addr=&CurCmd->Op2.Data;\n  CurCmd->Op1.Type=CurCmd->Op2.Type=VM_OPNONE;\n\n  // If operand 'Addr' field has not been set by DecodeArg calls above,\n  // let's set it to point to operand 'Data' field. It is necessary for\n  // VM_OPINT type operands (usual integers) or maybe if something was \n  // not set properly for other operands. 'Addr' field is required\n  // for quicker addressing of operand data.\n  for (int I=0;I<Prg->CmdCount;I++)\n  {\n    VM_PreparedCommand *Cmd=&Prg->Cmd[I];\n    if (Cmd->Op1.Addr==NULL)\n      Cmd->Op1.Addr=&Cmd->Op1.Data;\n    if (Cmd->Op2.Addr==NULL)\n      Cmd->Op2.Addr=&Cmd->Op2.Data;\n  }\n\n#ifdef VM_OPTIMIZE\n  if (CodeSize!=0)\n    Optimize(Prg);\n#endif\n}\n\n\n#ifndef NORARVM\nvoid RarVM::DecodeArg(VM_PreparedOperand &Op,bool ByteMode)\n{\n  uint Data=fgetbits();\n  if (Data & 0x8000)\n  {\n    Op.Type=VM_OPREG;     // Operand is register (R[0]..R[7])\n    Op.Data=(Data>>12)&7; // Register number\n    Op.Addr=&R[Op.Data];  // Register address\n    faddbits(4);          // 1 flag bit and 3 register number bits \n  }\n  else\n    if ((Data & 0xc000)==0)\n    {\n      Op.Type=VM_OPINT;   // Operand is integer\n      if (ByteMode)\n      {\n        Op.Data=(Data>>6) & 0xff;  // Byte integer.\n        faddbits(10);\n      }\n      else\n      {\n        faddbits(2);\n        Op.Data=ReadData(*this);   // 32 bit integer.\n      }\n    }\n    else\n    {\n      // Operand is data addressed by register data, base address or both.\n      Op.Type=VM_OPREGMEM;\n      if ((Data & 0x2000)==0)\n      {\n        // Base address is zero, just use the address from register.\n        Op.Data=(Data>>10)&7;\n        Op.Addr=&R[Op.Data];\n        Op.Base=0;\n        faddbits(6);\n      }\n      else\n      {\n        if ((Data & 0x1000)==0)\n        {\n          // Use both register and base address.\n          Op.Data=(Data>>9)&7;\n          Op.Addr=&R[Op.Data];\n          faddbits(7);\n        }\n        else\n        {\n          // Use base address only. Access memory by fixed address.\n          Op.Data=0;\n          faddbits(4);\n        }\n        Op.Base=ReadData(*this); // Read base address.\n      }\n    }\n}\n#endif\n\n\nuint RarVM::ReadData(BitInput &Inp)\n{\n  uint Data=Inp.fgetbits();\n  switch(Data&0xc000)\n  {\n    case 0:\n      Inp.faddbits(6);\n      return((Data>>10)&0xf);\n    case 0x4000:\n      if ((Data&0x3c00)==0)\n      {\n        Data=0xffffff00|((Data>>2)&0xff);\n        Inp.faddbits(14);\n      }\n      else\n      {\n        Data=(Data>>6)&0xff;\n        Inp.faddbits(10);\n      }\n      return(Data);\n    case 0x8000:\n      Inp.faddbits(2);\n      Data=Inp.fgetbits();\n      Inp.faddbits(16);\n      return(Data);\n    default:\n      Inp.faddbits(2);\n      Data=(Inp.fgetbits()<<16);\n      Inp.faddbits(16);\n      Data|=Inp.fgetbits();\n      Inp.faddbits(16);\n      return(Data);\n  }\n}\n\n\nvoid RarVM::SetMemory(size_t Pos,byte *Data,size_t DataSize)\n{\n  if (Pos<VM_MEMSIZE && Data!=Mem+Pos)\n    memmove(Mem+Pos,Data,Min(DataSize,VM_MEMSIZE-Pos));\n}\n\n\n#ifdef VM_OPTIMIZE\nvoid RarVM::Optimize(VM_PreparedProgram *Prg)\n{\n  VM_PreparedCommand *Code=&Prg->Cmd[0];\n  uint CodeSize=Prg->CmdCount;\n\n  for (uint I=0;I<CodeSize;I++)\n  {\n    VM_PreparedCommand *Cmd=Code+I;\n\n    // Replace universal opcodes with faster byte or word only processing\n    // opcodes.\n    switch(Cmd->OpCode)\n    {\n      case VM_MOV:\n        Cmd->OpCode=Cmd->ByteMode ? VM_MOVB:VM_MOVD;\n        continue;\n      case VM_CMP:\n        Cmd->OpCode=Cmd->ByteMode ? VM_CMPB:VM_CMPD;\n        continue;\n    }\n    if ((VM_CmdFlags[Cmd->OpCode] & VMCF_CHFLAGS)==0)\n      continue;\n\n    // If we do not have jump commands between the current operation\n    // and next command which will modify processor flags, we can replace\n    // the current command with faster version which does not need to\n    // modify flags.\n    bool FlagsRequired=false;\n    for (uint J=I+1;J<CodeSize;J++)\n    {\n      int Flags=VM_CmdFlags[Code[J].OpCode];\n      if (Flags & (VMCF_JUMP|VMCF_PROC|VMCF_USEFLAGS))\n      {\n        FlagsRequired=true;\n        break;\n      }\n      if (Flags & VMCF_CHFLAGS)\n        break;\n    }\n\n    // Below we'll replace universal opcodes with faster byte or word only \n    // processing opcodes, which also do not modify processor flags to\n    // provide better performance.\n    if (FlagsRequired)\n      continue;\n    switch(Cmd->OpCode)\n    {\n      case VM_ADD:\n        Cmd->OpCode=Cmd->ByteMode ? VM_ADDB:VM_ADDD;\n        continue;\n      case VM_SUB:\n        Cmd->OpCode=Cmd->ByteMode ? VM_SUBB:VM_SUBD;\n        continue;\n      case VM_INC:\n        Cmd->OpCode=Cmd->ByteMode ? VM_INCB:VM_INCD;\n        continue;\n      case VM_DEC:\n        Cmd->OpCode=Cmd->ByteMode ? VM_DECB:VM_DECD;\n        continue;\n      case VM_NEG:\n        Cmd->OpCode=Cmd->ByteMode ? VM_NEGB:VM_NEGD;\n        continue;\n    }\n  }\n}\n#endif\n\n\n#ifdef VM_STANDARDFILTERS\nVM_StandardFilters RarVM::IsStandardFilter(byte *Code,uint CodeSize)\n{\n  struct StandardFilterSignature\n  {\n    int Length;\n    uint CRC;\n    VM_StandardFilters Type;\n  } static StdList[]={\n    53, 0xad576887, VMSF_E8,\n    57, 0x3cd7e57e, VMSF_E8E9,\n   120, 0x3769893f, VMSF_ITANIUM,\n    29, 0x0e06077d, VMSF_DELTA,\n   149, 0x1c2c5dc8, VMSF_RGB,\n   216, 0xbc85e701, VMSF_AUDIO\n  };\n  uint CodeCRC=CRC32(0xffffffff,Code,CodeSize)^0xffffffff;\n  for (uint I=0;I<ASIZE(StdList);I++)\n    if (StdList[I].CRC==CodeCRC && StdList[I].Length==CodeSize)\n      return(StdList[I].Type);\n  return(VMSF_NONE);\n}\n\n\nvoid RarVM::ExecuteStandardFilter(VM_StandardFilters FilterType)\n{\n  switch(FilterType)\n  {\n    case VMSF_E8:\n    case VMSF_E8E9:\n      {\n        byte *Data=Mem;\n        int DataSize=R[4];\n        uint FileOffset=R[6];\n\n        if ((uint)DataSize>=VM_GLOBALMEMADDR || DataSize<4)\n          break;\n\n        const int FileSize=0x1000000;\n        byte CmpByte2=FilterType==VMSF_E8E9 ? 0xe9:0xe8;\n        for (int CurPos=0;CurPos<DataSize-4;)\n        {\n          byte CurByte=*(Data++);\n          CurPos++;\n          if (CurByte==0xe8 || CurByte==CmpByte2)\n          {\n#ifdef PRESENT_INT32\n            int32 Offset=CurPos+FileOffset;\n            int32 Addr=GET_VALUE(false,Data);\n            if (Addr<0)\n            {\n              if (Addr+Offset>=0)\n                SET_VALUE(false,Data,Addr+FileSize);\n            }\n            else\n              if (Addr<FileSize)\n                SET_VALUE(false,Data,Addr-Offset);\n#else\n            long Offset=CurPos+FileOffset;\n            long Addr=GET_VALUE(false,Data);\n            if ((Addr & 0x80000000)!=0)\n            {\n              if (((Addr+Offset) & 0x80000000)==0)\n                SET_VALUE(false,Data,Addr+FileSize);\n            }\n            else \n              if (((Addr-FileSize) & 0x80000000)!=0)\n                SET_VALUE(false,Data,Addr-Offset);\n#endif\n            Data+=4;\n            CurPos+=4;\n          }\n        }\n      }\n      break;\n    case VMSF_ITANIUM:\n      {\n        byte *Data=Mem;\n        int DataSize=R[4];\n        uint FileOffset=R[6];\n\n        if ((uint)DataSize>=VM_GLOBALMEMADDR || DataSize<21)\n          break;\n\n        int CurPos=0;\n\n        FileOffset>>=4;\n\n        while (CurPos<DataSize-21)\n        {\n          int Byte=(Data[0]&0x1f)-0x10;\n          if (Byte>=0)\n          {\n            static byte Masks[16]={4,4,6,6,0,0,7,7,4,4,0,0,4,4,0,0};\n            byte CmdMask=Masks[Byte];\n            if (CmdMask!=0)\n              for (int I=0;I<=2;I++)\n                if (CmdMask & (1<<I))\n                {\n                  int StartPos=I*41+5;\n                  int OpType=FilterItanium_GetBits(Data,StartPos+37,4);\n                  if (OpType==5)\n                  {\n                    int Offset=FilterItanium_GetBits(Data,StartPos+13,20);\n                    FilterItanium_SetBits(Data,(Offset-FileOffset)&0xfffff,StartPos+13,20);\n                  }\n                }\n          }\n          Data+=16;\n          CurPos+=16;\n          FileOffset++;\n        }\n      }\n      break;\n    case VMSF_DELTA:\n      {\n        int DataSize=R[4],Channels=R[0],SrcPos=0,Border=DataSize*2;\n        SET_VALUE(false,&Mem[VM_GLOBALMEMADDR+0x20],DataSize);\n        if ((uint)DataSize>=VM_GLOBALMEMADDR/2)\n          break;\n\n        // Bytes from same channels are grouped to continual data blocks,\n        // so we need to place them back to their interleaving positions.\n        for (int CurChannel=0;CurChannel<Channels;CurChannel++)\n        {\n          byte PrevByte=0;\n          for (int DestPos=DataSize+CurChannel;DestPos<Border;DestPos+=Channels)\n            Mem[DestPos]=(PrevByte-=Mem[SrcPos++]);\n        }\n      }\n      break;\n    case VMSF_RGB:\n      {\n        int DataSize=R[4],Width=R[0]-3,PosR=R[1];\n        byte *SrcData=Mem,*DestData=SrcData+DataSize;\n        const int Channels=3;\n        SET_VALUE(false,&Mem[VM_GLOBALMEMADDR+0x20],DataSize);\n        if ((uint)DataSize>=VM_GLOBALMEMADDR/2 || Width<0 || PosR<0)\n          break;\n        for (int CurChannel=0;CurChannel<Channels;CurChannel++)\n        {\n          uint PrevByte=0;\n\n          for (int I=CurChannel;I<DataSize;I+=Channels)\n          {\n            uint Predicted;\n            int UpperPos=I-Width;\n            if (UpperPos>=3)\n            {\n              byte *UpperData=DestData+UpperPos;\n              uint UpperByte=*UpperData;\n              uint UpperLeftByte=*(UpperData-3);\n              Predicted=PrevByte+UpperByte-UpperLeftByte;\n              int pa=abs((int)(Predicted-PrevByte));\n              int pb=abs((int)(Predicted-UpperByte));\n              int pc=abs((int)(Predicted-UpperLeftByte));\n              if (pa<=pb && pa<=pc)\n                Predicted=PrevByte;\n              else\n                if (pb<=pc)\n                  Predicted=UpperByte;\n                else\n                  Predicted=UpperLeftByte;\n            }\n            else\n              Predicted=PrevByte;\n            DestData[I]=PrevByte=(byte)(Predicted-*(SrcData++));\n          }\n        }\n        for (int I=PosR,Border=DataSize-2;I<Border;I+=3)\n        {\n          byte G=DestData[I+1];\n          DestData[I]+=G;\n          DestData[I+2]+=G;\n        }\n      }\n      break;\n    case VMSF_AUDIO:\n      {\n        int DataSize=R[4],Channels=R[0];\n        byte *SrcData=Mem,*DestData=SrcData+DataSize;\n        SET_VALUE(false,&Mem[VM_GLOBALMEMADDR+0x20],DataSize);\n        if ((uint)DataSize>=VM_GLOBALMEMADDR/2)\n          break;\n        for (int CurChannel=0;CurChannel<Channels;CurChannel++)\n        {\n          uint PrevByte=0,PrevDelta=0,Dif[7];\n          int D1=0,D2=0,D3;\n          int K1=0,K2=0,K3=0;\n          memset(Dif,0,sizeof(Dif));\n\n          for (int I=CurChannel,ByteCount=0;I<DataSize;I+=Channels,ByteCount++)\n          {\n            D3=D2;\n            D2=PrevDelta-D1;\n            D1=PrevDelta;\n\n            uint Predicted=8*PrevByte+K1*D1+K2*D2+K3*D3;\n            Predicted=(Predicted>>3) & 0xff;\n\n            uint CurByte=*(SrcData++);\n\n            Predicted-=CurByte;\n            DestData[I]=Predicted;\n            PrevDelta=(signed char)(Predicted-PrevByte);\n            PrevByte=Predicted;\n\n            int D=((signed char)CurByte)<<3;\n\n            Dif[0]+=abs(D);\n            Dif[1]+=abs(D-D1);\n            Dif[2]+=abs(D+D1);\n            Dif[3]+=abs(D-D2);\n            Dif[4]+=abs(D+D2);\n            Dif[5]+=abs(D-D3);\n            Dif[6]+=abs(D+D3);\n\n            if ((ByteCount & 0x1f)==0)\n            {\n              uint MinDif=Dif[0],NumMinDif=0;\n              Dif[0]=0;\n              for (int J=1;J<sizeof(Dif)/sizeof(Dif[0]);J++)\n              {\n                if (Dif[J]<MinDif)\n                {\n                  MinDif=Dif[J];\n                  NumMinDif=J;\n                }\n                Dif[J]=0;\n              }\n              switch(NumMinDif)\n              {\n                case 1: if (K1>=-16) K1--; break;\n                case 2: if (K1 < 16) K1++; break;\n                case 3: if (K2>=-16) K2--; break;\n                case 4: if (K2 < 16) K2++; break;\n                case 5: if (K3>=-16) K3--; break;\n                case 6: if (K3 < 16) K3++; break;\n              }\n            }\n          }\n        }\n      }\n      break;\n  }\n}\n\n\nuint RarVM::FilterItanium_GetBits(byte *Data,int BitPos,int BitCount)\n{\n  int InAddr=BitPos/8;\n  int InBit=BitPos&7;\n  uint BitField=(uint)Data[InAddr++];\n  BitField|=(uint)Data[InAddr++] << 8;\n  BitField|=(uint)Data[InAddr++] << 16;\n  BitField|=(uint)Data[InAddr] << 24;\n  BitField >>= InBit;\n  return(BitField & (0xffffffff>>(32-BitCount)));\n}\n\n\nvoid RarVM::FilterItanium_SetBits(byte *Data,uint BitField,int BitPos,int BitCount)\n{\n  int InAddr=BitPos/8;\n  int InBit=BitPos&7;\n  uint AndMask=0xffffffff>>(32-BitCount);\n  AndMask=~(AndMask<<InBit);\n\n  BitField<<=InBit;\n\n  for (uint I=0;I<4;I++)\n  {\n    Data[InAddr+I]&=AndMask;\n    Data[InAddr+I]|=BitField;\n    AndMask=(AndMask>>8)|0xff000000;\n    BitField>>=8;\n  }\n}\n#endif\n","#ifndef _RAR_GETBITS_\n#define _RAR_GETBITS_\n\nclass BitInput\n{\n  public:\n    enum BufferSize {MAX_SIZE=0x8000}; // Size of input buffer.\n\n    int InAddr; // Curent byte position in the buffer.\n    int InBit;  // Current bit position in the current byte.\n\n    bool ExternalBuffer;\n  public:\n    BitInput(bool AllocBuffer);\n    ~BitInput();\n\n    byte *InBuf; // Dynamically allocated input buffer.\n\n    void InitBitInput()\n    {\n      InAddr=InBit=0;\n    }\n    \n    // Move forward by 'Bits' bits.\n    void addbits(uint Bits)\n    {\n      Bits+=InBit;\n      InAddr+=Bits>>3;\n      InBit=Bits&7;\n    }\n    \n    // Return 16 bits from current position in the buffer.\n    // Bit at (InAddr,InBit) has the highest position in returning data.\n    uint getbits()\n    {\n      uint BitField=(uint)InBuf[InAddr] << 16;\n      BitField|=(uint)InBuf[InAddr+1] << 8;\n      BitField|=(uint)InBuf[InAddr+2];\n      BitField >>= (8-InBit);\n      return BitField & 0xffff;\n    }\n\n    // Return 32 bits from current position in the buffer.\n    // Bit at (InAddr,InBit) has the highest position in returning data.\n    uint getbits32()\n    {\n      uint BitField=(uint)InBuf[InAddr] << 24;\n      BitField|=(uint)InBuf[InAddr+1] << 16;\n      BitField|=(uint)InBuf[InAddr+2] << 8;\n      BitField|=(uint)InBuf[InAddr+3];\n      BitField <<= InBit;\n      BitField|=(uint)InBuf[InAddr+4] >> (8-InBit);\n      return BitField & 0xffffffff;\n    }\n    \n    void faddbits(uint Bits);\n    uint fgetbits();\n    \n    // Check if buffer has enough space for IncPtr bytes. Returns 'true'\n    // if buffer will be overflown.\n    bool Overflow(uint IncPtr) \n    {\n      return InAddr+IncPtr>=MAX_SIZE;\n    }\n\n    void SetExternalBuffer(byte *Buf);\n};\n#endif\n","#include \"rar.hpp\"\n\n#ifdef _WIN_ALL\ntypedef BOOL (WINAPI *CRYPTPROTECTMEMORY)(LPVOID pData,DWORD cbData,DWORD dwFlags);\ntypedef BOOL (WINAPI *CRYPTUNPROTECTMEMORY)(LPVOID pData,DWORD cbData,DWORD dwFlags);\n\n#ifndef CRYPTPROTECTMEMORY_BLOCK_SIZE\n#define CRYPTPROTECTMEMORY_BLOCK_SIZE           16\n#define CRYPTPROTECTMEMORY_SAME_PROCESS         0x00\n#define CRYPTPROTECTMEMORY_CROSS_PROCESS        0x01\n#endif\n\nclass CryptLoader\n{\n  private:\n    HMODULE hCrypt;\n    bool LoadCalled;\n  public:\n    CryptLoader() \n    {\n      hCrypt=NULL;\n      pCryptProtectMemory=NULL;\n      pCryptUnprotectMemory=NULL;\n      LoadCalled=false;\n    }\n    ~CryptLoader()\n    {\n      if (hCrypt!=NULL)\n        FreeLibrary(hCrypt);\n      hCrypt=NULL;\n      pCryptProtectMemory=NULL;\n      pCryptUnprotectMemory=NULL;\n    };\n    void Load()\n    {\n      if (!LoadCalled)\n      {\n        hCrypt = LoadSysLibrary(L\"Crypt32.dll\");\n        if (hCrypt != NULL)\n        {\n          pCryptProtectMemory = (CRYPTPROTECTMEMORY)GetProcAddress(hCrypt, \"CryptProtectMemory\");\n          pCryptUnprotectMemory = (CRYPTUNPROTECTMEMORY)GetProcAddress(hCrypt, \"CryptUnprotectMemory\");\n        }\n        LoadCalled=true;\n      }\n    }\n\n    CRYPTPROTECTMEMORY pCryptProtectMemory;\n    CRYPTUNPROTECTMEMORY pCryptUnprotectMemory;\n};\n\n// We need to call FreeLibrary when RAR is exiting.\nCryptLoader GlobalCryptLoader;\n#endif\n\nSecPassword::SecPassword()\n{\n  CrossProcess=false;\n  Set(L\"\");\n}\n\n\nSecPassword::~SecPassword()\n{\n  Clean();\n}\n\n\nvoid SecPassword::Clean()\n{\n  PasswordSet=false;\n  cleandata(Password,sizeof(Password));\n}\n \n\n// When we call memset in end of function to clean local variables\n// for security reason, compiler optimizer can remove such call.\n// So we use our own function for this purpose.\nvoid cleandata(void *data,size_t size)\n{\n#if defined(_WIN_ALL) && defined(_MSC_VER)\n  SecureZeroMemory(data,size);\n#else\n  // 'volatile' is required. Otherwise optimizers can remove this function\n  // if cleaning local variables, which are not used after that.\n  volatile byte *d = (volatile byte *)data;\n  for (size_t i=0;i<size;i++)\n    d[i]=0;\n#endif\n}\n\n\n// We got a complain from user that it is possible to create WinRAR dump\n// with \"Create dump file\" command in Windows Task Manager and then easily\n// locate Unicode password string in the dump. It is unsecure if several\n// people share the same computer and somebody left WinRAR copy with entered\n// password. So we decided to obfuscate the password to make it more difficult\n// to find it in dump.\nvoid SecPassword::Process(const wchar *Src,size_t SrcSize,wchar *Dst,size_t DstSize,bool Encode)\n{\n  // Source string can be shorter than destination as in case when we process\n  // -p<pwd> parameter, so we need to take into account both sizes.\n  memcpy(Dst,Src,Min(SrcSize,DstSize)*sizeof(*Dst));\n  SecHideData(Dst,DstSize*sizeof(*Dst),Encode,CrossProcess);\n}\n\n\nvoid SecPassword::Get(wchar *Psw,size_t MaxSize)\n{\n  if (PasswordSet)\n  {\n    Process(Password,ASIZE(Password),Psw,MaxSize,false);\n    Psw[MaxSize-1]=0;\n  }\n  else\n    *Psw=0;\n}\n\n\nvoid SecPassword::Set(const wchar *Psw)\n{\n  if (*Psw==0)\n  {\n    PasswordSet=false;\n    memset(Password,0,sizeof(Password));\n  }\n  else\n  {\n    PasswordSet=true;\n    Process(Psw,wcslen(Psw)+1,Password,ASIZE(Password),true);\n  }\n}\n\n\nsize_t SecPassword::Length()\n{\n  wchar Plain[MAXPASSWORD];\n  Get(Plain,ASIZE(Plain));\n  size_t Length=wcslen(Plain);\n  cleandata(Plain,ASIZE(Plain));\n  return Length;\n}\n\n\nbool SecPassword::operator == (SecPassword &psw)\n{\n  // We cannot compare encoded data directly, because there is no guarantee\n  // than encryption function will always produce the same result for same\n  // data (salt?) and because we do not clean the rest of password buffer\n  // after trailing zero before encoding password. So we decode first.\n  wchar Plain1[MAXPASSWORD],Plain2[MAXPASSWORD];\n  Get(Plain1,ASIZE(Plain1));\n  psw.Get(Plain2,ASIZE(Plain2));\n  bool Result=wcscmp(Plain1,Plain2)==0;\n  cleandata(Plain1,ASIZE(Plain1));\n  cleandata(Plain2,ASIZE(Plain2));\n  return Result;\n}\n\n\nvoid SecHideData(void *Data,size_t DataSize,bool Encode,bool CrossProcess)\n{\n#ifdef _WIN_ALL\n  // Try to utilize the secure Crypt[Un]ProtectMemory if possible.\n  if (GlobalCryptLoader.pCryptProtectMemory==NULL)\n    GlobalCryptLoader.Load();\n  size_t Aligned=DataSize-DataSize%CRYPTPROTECTMEMORY_BLOCK_SIZE;\n  DWORD Flags=CrossProcess ? CRYPTPROTECTMEMORY_CROSS_PROCESS : CRYPTPROTECTMEMORY_SAME_PROCESS;\n  if (Encode)\n  {\n    if (GlobalCryptLoader.pCryptProtectMemory!=NULL)\n    {\n      if (!GlobalCryptLoader.pCryptProtectMemory(Data,DWORD(Aligned),Flags))\n      {\n        ErrHandler.GeneralErrMsg(L\"CryptProtectMemory failed\");\n        ErrHandler.SysErrMsg();\n        ErrHandler.Exit(RARX_FATAL);\n      }\n      return;\n    }\n  }\n  else\n  {\n    if (GlobalCryptLoader.pCryptUnprotectMemory!=NULL)\n    {\n      if (!GlobalCryptLoader.pCryptUnprotectMemory(Data,DWORD(Aligned),Flags))\n      {\n        ErrHandler.GeneralErrMsg(L\"CryptUnprotectMemory failed\");\n        ErrHandler.SysErrMsg();\n        ErrHandler.Exit(RARX_FATAL);\n      }\n      return;\n    }\n  }\n#endif\n  \n  // CryptProtectMemory is not available, so only slightly obfuscate data.\n  uint Key;\n#ifdef _WIN_ALL\n  Key=GetCurrentProcessId();\n#elif defined(_UNIX)\n  Key=getpid();\n#else\n  Key=0; // Just an arbitrary value.\n#endif\n\n  for (size_t I=0;I<DataSize;I++)\n    *((byte *)Data+I)^=Key+I+75;\n}\n","/***************************************************************************\n * This code is based on public domain Szymon Stefanek AES implementation: *\n * http://www.pragmaware.net/software/rijndael/index.php                   *\n *                                                                         *\n * Dynamic tables generation is based on the Brian Gladman work:           *\n * http://fp.gladman.plus.com/cryptography_technology/rijndael             *\n ***************************************************************************/\n#include \"rar.hpp\"\n\n#ifdef USE_SSE\n#include <wmmintrin.h>\n#endif\n\nstatic byte S[256],S5[256],rcon[30];\nstatic byte T1[256][4],T2[256][4],T3[256][4],T4[256][4];\nstatic byte T5[256][4],T6[256][4],T7[256][4],T8[256][4];\nstatic byte U1[256][4],U2[256][4],U3[256][4],U4[256][4];\n\n\ninline void Xor128(void *dest,const void *arg1,const void *arg2)\n{\n#if defined(PRESENT_INT32) && defined(ALLOW_MISALIGNED)\n  ((uint32*)dest)[0]=((uint32*)arg1)[0]^((uint32*)arg2)[0];\n  ((uint32*)dest)[1]=((uint32*)arg1)[1]^((uint32*)arg2)[1];\n  ((uint32*)dest)[2]=((uint32*)arg1)[2]^((uint32*)arg2)[2];\n  ((uint32*)dest)[3]=((uint32*)arg1)[3]^((uint32*)arg2)[3];\n#else\n  for (int I=0;I<16;I++)\n    ((byte*)dest)[I]=((byte*)arg1)[I]^((byte*)arg2)[I];\n#endif\n}\n\n\ninline void Xor128(byte *dest,const byte *arg1,const byte *arg2,\n                   const byte *arg3,const byte *arg4)\n{\n#if defined(PRESENT_INT32) && defined(ALLOW_MISALIGNED)\n  (*(uint32*)dest)=(*(uint32*)arg1)^(*(uint32*)arg2)^(*(uint32*)arg3)^(*(uint32*)arg4);\n#else\n  for (int I=0;I<4;I++)\n    dest[I]=arg1[I]^arg2[I]^arg3[I]^arg4[I];\n#endif\n}\n\n\ninline void Copy128(byte *dest,const byte *src)\n{\n#if defined(PRESENT_INT32) && defined(ALLOW_MISALIGNED)\n  ((uint32*)dest)[0]=((uint32*)src)[0];\n  ((uint32*)dest)[1]=((uint32*)src)[1];\n  ((uint32*)dest)[2]=((uint32*)src)[2];\n  ((uint32*)dest)[3]=((uint32*)src)[3];\n#else\n  for (int I=0;I<16;I++)\n    dest[I]=src[I];\n#endif\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// API\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nRijndael::Rijndael()\n{\n  if (S[0]==0)\n    GenerateTables();\n  CBCMode = true; // Always true for RAR.\n}\n\n\nvoid Rijndael::Init(bool Encrypt,const byte *key,uint keyLen,const byte * initVector)\n{\n#ifdef USE_SSE\n  // Check SSE here instead of constructor, so if object is a part of some\n  // structure memset'ed before use, this variable is not lost.\n  int CPUInfo[4];\n  __cpuid(CPUInfo, 1);\n  AES_NI=(CPUInfo[2] & 0x2000000)!=0;\n#endif\n\n  uint uKeyLenInBytes;\n  switch(keyLen)\n  {\n    case 128:\n      uKeyLenInBytes = 16;\n      m_uRounds = 10;\n      break;\n    case 192:\n      uKeyLenInBytes = 24;\n      m_uRounds = 12;\n      break;\n    case 256:\n      uKeyLenInBytes = 32;\n      m_uRounds = 14;\n      break;\n  }\n\n  byte keyMatrix[_MAX_KEY_COLUMNS][4];\n\n  for(uint i = 0; i < uKeyLenInBytes; i++)\n    keyMatrix[i >> 2][i & 3] = key[i]; \n\n  if (initVector==NULL)\n    memset(m_initVector, 0, sizeof(m_initVector));\n  else\n    for(int i = 0; i < MAX_IV_SIZE; i++)\n      m_initVector[i] = initVector[i];\n\n  keySched(keyMatrix);\n\n  if(!Encrypt)\n    keyEncToDec();\n}\n\n\n  \nvoid Rijndael::blockDecrypt(const byte *input, size_t inputLen, byte *outBuffer)\n{\n  if (inputLen <= 0)\n    return;\n\n  size_t numBlocks=inputLen/16;\n#ifdef USE_SSE\n  if (AES_NI)\n  {\n    blockDecryptSSE(input,numBlocks,outBuffer);\n    return;\n  }\n#endif\n\n  byte block[16], iv[4][4];\n  memcpy(iv,m_initVector,16); \n\n  for (size_t i = numBlocks; i > 0; i--)\n  {\n    byte temp[4][4];\n    \n    Xor128(temp,input,m_expandedKey[m_uRounds]);\n\n    Xor128(block,   T5[temp[0][0]],T6[temp[3][1]],T7[temp[2][2]],T8[temp[1][3]]);\n    Xor128(block+4, T5[temp[1][0]],T6[temp[0][1]],T7[temp[3][2]],T8[temp[2][3]]);\n    Xor128(block+8, T5[temp[2][0]],T6[temp[1][1]],T7[temp[0][2]],T8[temp[3][3]]);\n    Xor128(block+12,T5[temp[3][0]],T6[temp[2][1]],T7[temp[1][2]],T8[temp[0][3]]);\n\n    for(int r = m_uRounds-1; r > 1; r--)\n    {\n      Xor128(temp,block,m_expandedKey[r]);\n      Xor128(block,   T5[temp[0][0]],T6[temp[3][1]],T7[temp[2][2]],T8[temp[1][3]]);\n      Xor128(block+4, T5[temp[1][0]],T6[temp[0][1]],T7[temp[3][2]],T8[temp[2][3]]);\n      Xor128(block+8, T5[temp[2][0]],T6[temp[1][1]],T7[temp[0][2]],T8[temp[3][3]]);\n      Xor128(block+12,T5[temp[3][0]],T6[temp[2][1]],T7[temp[1][2]],T8[temp[0][3]]);\n    }\n   \n    Xor128(temp,block,m_expandedKey[1]);\n    block[ 0] = S5[temp[0][0]];\n    block[ 1] = S5[temp[3][1]];\n    block[ 2] = S5[temp[2][2]];\n    block[ 3] = S5[temp[1][3]];\n    block[ 4] = S5[temp[1][0]];\n    block[ 5] = S5[temp[0][1]];\n    block[ 6] = S5[temp[3][2]];\n    block[ 7] = S5[temp[2][3]];\n    block[ 8] = S5[temp[2][0]];\n    block[ 9] = S5[temp[1][1]];\n    block[10] = S5[temp[0][2]];\n    block[11] = S5[temp[3][3]];\n    block[12] = S5[temp[3][0]];\n    block[13] = S5[temp[2][1]];\n    block[14] = S5[temp[1][2]];\n    block[15] = S5[temp[0][3]];\n    Xor128(block,block,m_expandedKey[0]);\n\n    if (CBCMode)\n      Xor128(block,block,iv);\n\n    Copy128((byte*)iv,input);\n    Copy128(outBuffer,block);\n\n    input += 16;\n    outBuffer += 16;\n  }\n\n  memcpy(m_initVector,iv,16);\n}\n\n\n#ifdef USE_SSE\nvoid Rijndael::blockDecryptSSE(const byte *input, size_t numBlocks, byte *outBuffer)\n{\n  __m128i initVector = _mm_loadu_si128((__m128i*)m_initVector);\n  __m128i *src=(__m128i*)input;\n  __m128i *dest=(__m128i*)outBuffer;\n  __m128i *rkey=(__m128i*)m_expandedKey;\n  while (numBlocks > 0)\n  {\n    __m128i rl = _mm_loadu_si128(rkey + m_uRounds);\n    __m128i d = _mm_loadu_si128(src++);\n    __m128i v = _mm_xor_si128(rl, d);\n\n    for (int i=m_uRounds-1; i>0; i--)\n    {\n      __m128i ri = _mm_loadu_si128(rkey + i);\n      v = _mm_aesdec_si128(v, ri);\n    }\n    \n    __m128i r0 = _mm_loadu_si128(rkey);\n    v = _mm_aesdeclast_si128(v, r0);\n\n    if (CBCMode)\n      v = _mm_xor_si128(v, initVector);\n    initVector = d;\n    _mm_storeu_si128(dest++,v);\n    numBlocks--;\n  }\n  _mm_storeu_si128((__m128i*)m_initVector,initVector);\n}\n#endif\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// ALGORITHM\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nvoid Rijndael::keySched(byte key[_MAX_KEY_COLUMNS][4])\n{\n  int j,rconpointer = 0;\n\n  // Calculate the necessary round keys\n  // The number of calculations depends on keyBits and blockBits\n  int uKeyColumns = m_uRounds - 6;\n\n  byte tempKey[_MAX_KEY_COLUMNS][4];\n\n  // Copy the input key to the temporary key matrix\n\n  memcpy(tempKey,key,sizeof(tempKey));\n\n  int r = 0;\n  int t = 0;\n\n  // copy values into round key array\n  for(j = 0;(j < uKeyColumns) && (r <= m_uRounds); )\n  {\n    for(;(j < uKeyColumns) && (t < 4); j++, t++)\n      for (int k=0;k<4;k++)\n        m_expandedKey[r][t][k]=tempKey[j][k];\n\n    if(t == 4)\n    {\n      r++;\n      t = 0;\n    }\n  }\n    \n  while(r <= m_uRounds)\n  {\n    tempKey[0][0] ^= S[tempKey[uKeyColumns-1][1]];\n    tempKey[0][1] ^= S[tempKey[uKeyColumns-1][2]];\n    tempKey[0][2] ^= S[tempKey[uKeyColumns-1][3]];\n    tempKey[0][3] ^= S[tempKey[uKeyColumns-1][0]];\n    tempKey[0][0] ^= rcon[rconpointer++];\n\n    if (uKeyColumns != 8)\n      for(j = 1; j < uKeyColumns; j++)\n        for (int k=0;k<4;k++)\n          tempKey[j][k] ^= tempKey[j-1][k];\n    else\n    {\n      for(j = 1; j < uKeyColumns/2; j++)\n        for (int k=0;k<4;k++)\n          tempKey[j][k] ^= tempKey[j-1][k];\n\n      tempKey[uKeyColumns/2][0] ^= S[tempKey[uKeyColumns/2 - 1][0]];\n      tempKey[uKeyColumns/2][1] ^= S[tempKey[uKeyColumns/2 - 1][1]];\n      tempKey[uKeyColumns/2][2] ^= S[tempKey[uKeyColumns/2 - 1][2]];\n      tempKey[uKeyColumns/2][3] ^= S[tempKey[uKeyColumns/2 - 1][3]];\n      for(j = uKeyColumns/2 + 1; j < uKeyColumns; j++)\n        for (int k=0;k<4;k++)\n          tempKey[j][k] ^= tempKey[j-1][k];\n    }\n    for(j = 0; (j < uKeyColumns) && (r <= m_uRounds); )\n    {\n      for(; (j < uKeyColumns) && (t < 4); j++, t++)\n        for (int k=0;k<4;k++)\n          m_expandedKey[r][t][k] = tempKey[j][k];\n      if(t == 4)\n      {\n        r++;\n        t = 0;\n      }\n    }\n  }   \n}\n\nvoid Rijndael::keyEncToDec()\n{\n  for(int r = 1; r < m_uRounds; r++)\n  {\n    byte n_expandedKey[4][4];\n    for (int i = 0; i < 4; i++)\n      for (int j = 0; j < 4; j++)\n      {\n        byte *w=m_expandedKey[r][j];\n        n_expandedKey[j][i]=U1[w[0]][i]^U2[w[1]][i]^U3[w[2]][i]^U4[w[3]][i];\n      }\n    memcpy(m_expandedKey[r],n_expandedKey,sizeof(m_expandedKey[0]));\n  }\n} \n\n\n#define ff_poly 0x011b\n#define ff_hi   0x80\n\n#define FFinv(x)    ((x) ? pow[255 - log[x]]: 0)\n\n#define FFmul02(x) (x ? pow[log[x] + 0x19] : 0)\n#define FFmul03(x) (x ? pow[log[x] + 0x01] : 0)\n#define FFmul09(x) (x ? pow[log[x] + 0xc7] : 0)\n#define FFmul0b(x) (x ? pow[log[x] + 0x68] : 0)\n#define FFmul0d(x) (x ? pow[log[x] + 0xee] : 0)\n#define FFmul0e(x) (x ? pow[log[x] + 0xdf] : 0)\n#define fwd_affine(x) \\\n    (w = (uint)x, w ^= (w<<1)^(w<<2)^(w<<3)^(w<<4), (byte)(0x63^(w^(w>>8))))\n\n#define inv_affine(x) \\\n    (w = (uint)x, w = (w<<1)^(w<<3)^(w<<6), (byte)(0x05^(w^(w>>8))))\n\nvoid Rijndael::GenerateTables()\n{\n  unsigned char pow[512],log[256];\n  int i = 0, w = 1; \n  do\n  {   \n    pow[i] = (byte)w;\n    pow[i + 255] = (byte)w;\n    log[w] = (byte)i++;\n    w ^=  (w << 1) ^ (w & ff_hi ? ff_poly : 0);\n  } while (w != 1);\n \n  for (int i = 0,w = 1; i < sizeof(rcon)/sizeof(rcon[0]); i++)\n  {\n    rcon[i] = w;\n    w = (w << 1) ^ (w & ff_hi ? ff_poly : 0);\n  }\n  for(int i = 0; i < 256; ++i)\n  {   \n    unsigned char b=S[i]=fwd_affine(FFinv((byte)i));\n    T1[i][1]=T1[i][2]=T2[i][2]=T2[i][3]=T3[i][0]=T3[i][3]=T4[i][0]=T4[i][1]=b;\n    T1[i][0]=T2[i][1]=T3[i][2]=T4[i][3]=FFmul02(b);\n    T1[i][3]=T2[i][0]=T3[i][1]=T4[i][2]=FFmul03(b);\n    S5[i] = b = FFinv(inv_affine((byte)i));\n    U1[b][3]=U2[b][0]=U3[b][1]=U4[b][2]=T5[i][3]=T6[i][0]=T7[i][1]=T8[i][2]=FFmul0b(b);\n    U1[b][1]=U2[b][2]=U3[b][3]=U4[b][0]=T5[i][1]=T6[i][2]=T7[i][3]=T8[i][0]=FFmul09(b);\n    U1[b][2]=U2[b][3]=U3[b][0]=U4[b][1]=T5[i][2]=T6[i][3]=T7[i][0]=T8[i][1]=FFmul0d(b);\n    U1[b][0]=U2[b][1]=U3[b][2]=U4[b][3]=T5[i][0]=T6[i][1]=T7[i][2]=T8[i][3]=FFmul0e(b);\n  }\n}\n\n\n#if 0\nstatic void TestRijndael();\nstruct TestRij {TestRij() {TestRijndael();exit(0);}} GlobalTestRij;\n\n// Test CBC encryption according to NIST 800-38A.\nvoid TestRijndael()\n{\n  byte IV[16]={0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f};\n  byte PT[64]={\n    0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,\n    0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,\n    0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11,0xe5,0xfb,0xc1,0x19,0x1a,0x0a,0x52,0xef,\n    0xf6,0x9f,0x24,0x45,0xdf,0x4f,0x9b,0x17,0xad,0x2b,0x41,0x7b,0xe6,0x6c,0x37,0x10,\n  };\n\n  byte Key128[16]={0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c};\n  byte Chk128[16]={0x3f,0xf1,0xca,0xa1,0x68,0x1f,0xac,0x09,0x12,0x0e,0xca,0x30,0x75,0x86,0xe1,0xa7};\n  byte Key192[24]={0x8e,0x73,0xb0,0xf7,0xda,0x0e,0x64,0x52,0xc8,0x10,0xf3,0x2b,0x80,0x90,0x79,0xe5,0x62,0xf8,0xea,0xd2,0x52,0x2c,0x6b,0x7b};\n  byte Chk192[16]={0x08,0xb0,0xe2,0x79,0x88,0x59,0x88,0x81,0xd9,0x20,0xa9,0xe6,0x4f,0x56,0x15,0xcd};\n  byte Key256[32]={0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4};\n  byte Chk256[16]={0xb2,0xeb,0x05,0xe2,0xc3,0x9b,0xe9,0xfc,0xda,0x6c,0x19,0x07,0x8c,0x6a,0x9d,0x1b};\n  byte *Key[3]={Key128,Key192,Key256};\n  byte *Chk[3]={Chk128,Chk192,Chk256};\n\n  Rijndael rij; // Declare outside of loop to test re-initialization.\n  for (uint L=0;L<3;L++)\n  {\n    byte Out[16];\n    wchar Str[sizeof(Out)*2+1];\n\n    uint KeyLength=128+L*64;\n    rij.Init(true,Key[L],KeyLength,IV);\n    for (uint I=0;I<sizeof(PT);I+=16)\n      rij.blockEncrypt(PT+I,16,Out);\n    BinToHex(Chk[L],16,NULL,Str,ASIZE(Str));\n    mprintf(L\"\\nAES-%d expected: %s\",KeyLength,Str);\n    BinToHex(Out,sizeof(Out),NULL,Str,ASIZE(Str));\n    mprintf(L\"\\nAES-%d result:   %s\",KeyLength,Str);\n    if (memcmp(Out,Chk[L],16)==0)\n      mprintf(L\" OK\");\n    else\n    {\n      mprintf(L\" FAILED\");\n      getchar();\n    }\n  }\n}\n#endif\n","#include \"rar.hpp\"\n\nBitInput::BitInput(bool AllocBuffer)\n{\n  ExternalBuffer=false;\n  if (AllocBuffer)\n  {\n    // getbits32 attempts to read data from InAddr, ... InAddr+3 positions.\n    // So let's allocate 3 additional bytes for situation, when we need to\n    // read only 1 byte from the last position of buffer and avoid a crash\n    // from access to next 3 bytes, which contents we do not need.\n    size_t BufSize=MAX_SIZE+3;\n    InBuf=new byte[BufSize];\n\n    // Ensure that we get predictable results when accessing bytes in area\n    // not filled with read data.\n    memset(InBuf,0,BufSize);\n  }\n  else\n    InBuf=NULL;\n}\n\n\nBitInput::~BitInput()\n{\n  if (!ExternalBuffer)\n    delete[] InBuf;\n}\n\n\nvoid BitInput::faddbits(uint Bits)\n{\n  // Function wrapped version of inline addbits to save code size.\n  addbits(Bits);\n}\n\n\nuint BitInput::fgetbits()\n{\n  // Function wrapped version of inline getbits to save code size.\n  return getbits();\n}\n\n\nvoid BitInput::SetExternalBuffer(byte *Buf)\n{\n  if (InBuf!=NULL && !ExternalBuffer)\n    delete[] InBuf;\n  InBuf=Buf;\n  ExternalBuffer=true;\n}\n\n","#include \"rar.hpp\"\n\n/*\nSHA-1 in C\nBy Steve Reid <steve@edmweb.com>\n100% Public Domain\n\nTest Vectors (from FIPS PUB 180-1)\n\"abc\"\n  A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D\n\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n  84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1\nA million repetitions of \"a\"\n  34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F\n*/\n\n#if !defined(LITTLE_ENDIAN) && !defined(BIG_ENDIAN)\n  #if defined(_M_IX86) || defined(_M_I86) || defined(__alpha)\n    #define LITTLE_ENDIAN\n  #else\n    #error \"LITTLE_ENDIAN or BIG_ENDIAN must be defined\"\n\t#endif\n#endif\n\n/* #define SHA1HANDSOFF * Copies data before messing with it. */\n\n#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))\n\n/* blk0() and blk() perform the initial expand. */\n/* I got the idea of expanding during the round function from SSLeay */\n#ifdef LITTLE_ENDIAN\n#define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \\\n    |(rol(block->l[i],8)&0x00FF00FF))\n#else\n#define blk0(i) block->l[i]\n#endif\n#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \\\n    ^block->l[(i+2)&15]^block->l[i&15],1))\n\n/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */\n#define R0(v,w,x,y,z,i) {z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);}\n#define R1(v,w,x,y,z,i) {z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);}\n#define R2(v,w,x,y,z,i) {z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);}\n#define R3(v,w,x,y,z,i) {z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);}\n#define R4(v,w,x,y,z,i) {z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);}\n\n#ifdef _MSC_VER\n#pragma optimize( \"\", off )\n// We need to disable the optimization to really wipe these variables.\n#endif\nstatic void wipevars(uint32 &a,uint32 &b,uint32 &c,uint32 &d,uint32 &e)\n{\n  // Wipe used variables for safety reason.\n  a=b=c=d=e=0;\n}\n#ifdef _MSC_VER\n#pragma optimize( \"\", on )\n#endif\n\n/* Hash a single 512-bit block. This is the core of the algorithm. */\n\nvoid SHA1Transform(uint32 state[5], unsigned char workspace[64], const byte buffer[64], bool handsoff)\n{\n#ifndef SFX_MODULE\n  uint32 a, b, c, d, e;\n#endif\n  typedef union {\n    unsigned char c[64];\n    uint32 l[16];\n} CHAR64LONG16;\nCHAR64LONG16* block;\n    if (handsoff)\n    {\n      block = (CHAR64LONG16*)workspace;\n      memcpy(block, buffer, 64);\n    }\n    else\n      block = (CHAR64LONG16*)buffer;\n#ifdef SFX_MODULE\n    static int pos[80][5];\n    static bool pinit=false;\n    if (!pinit)\n    {\n      for (int I=0,P=0;I<80;I++,P=(P ? P-1:4))\n      {\n        pos[I][0]=P;\n        pos[I][1]=(P+1)%5;\n        pos[I][2]=(P+2)%5;\n        pos[I][3]=(P+3)%5;\n        pos[I][4]=(P+4)%5;\n      }\n      pinit=true;\n    }\n    uint32 s[5];\n    for (int I=0;I<sizeof(s)/sizeof(s[0]);I++)\n      s[I]=state[I];\n\n    for (int I=0;I<16;I++)\n      R0(s[pos[I][0]],s[pos[I][1]],s[pos[I][2]],s[pos[I][3]],s[pos[I][4]],I);\n    for (int I=16;I<20;I++)\n      R1(s[pos[I][0]],s[pos[I][1]],s[pos[I][2]],s[pos[I][3]],s[pos[I][4]],I);\n    for (int I=20;I<40;I++)\n      R2(s[pos[I][0]],s[pos[I][1]],s[pos[I][2]],s[pos[I][3]],s[pos[I][4]],I);\n    for (int I=40;I<60;I++)\n      R3(s[pos[I][0]],s[pos[I][1]],s[pos[I][2]],s[pos[I][3]],s[pos[I][4]],I);\n    for (int I=60;I<80;I++)\n      R4(s[pos[I][0]],s[pos[I][1]],s[pos[I][2]],s[pos[I][3]],s[pos[I][4]],I);\n\n    for (int I=0;I<sizeof(s)/sizeof(s[0]);I++)\n      state[I]+=s[I];\n#else\n    /* Copy context->state[] to working vars */\n    a = state[0];\n    b = state[1];\n    c = state[2];\n    d = state[3];\n    e = state[4];\n    /* 4 rounds of 20 operations each. Loop unrolled. */\n    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);\n    R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);\n    R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);\n    R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);\n    R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);\n    R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);\n    R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);\n    R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);\n    R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);\n    R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);\n    R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);\n    R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);\n    R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);\n    R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);\n    R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);\n    R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);\n    R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);\n    R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);\n    R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);\n    R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);\n    /* Add the working vars back into context.state[] */\n    state[0] += a;\n    state[1] += b;\n    state[2] += c;\n    state[3] += d;\n    state[4] += e;\n\n    /* Wipe variables */\n// Such wipe method does not work in optimizing compilers.\n//    a = b = c = d = e = 0;\n//    memset(&a,0,sizeof(a));\n\n    wipevars(a,b,c,d,e);\n#endif\n}\n\n\n/* Initialize new context */\n\nvoid sha1_init(sha1_context* context)\n{\n    /* SHA1 initialization constants */\n    context->state[0] = 0x67452301;\n    context->state[1] = 0xEFCDAB89;\n    context->state[2] = 0x98BADCFE;\n    context->state[3] = 0x10325476;\n    context->state[4] = 0xC3D2E1F0;\n    context->count[0] = context->count[1] = 0;\n}\n\n\n/* Run your data through this. */\nvoid sha1_process( sha1_context * context, const unsigned char * data, size_t len,\n                   bool handsoff )\n{\nunsigned int i, j;\nuint blen = ((uint)len)<<3;\n\n    j = (context->count[0] >> 3) & 63;\n    if ((context->count[0] += blen) < blen ) context->count[1]++;\n    context->count[1] += (uint32)(len >> 29);\n    if ((j + len) > 63) {\n        memcpy(&context->buffer[j], data, (i = 64-j));\n        SHA1Transform(context->state, context->workspace, context->buffer, handsoff);\n        for ( ; i + 63 < len; i += 64) {\n#ifdef ALLOW_MISALIGNED\n            SHA1Transform(context->state, context->workspace, &data[i], handsoff);\n#else\n            uint buffer[16];\n            memcpy(buffer,data+i,sizeof(buffer));\n            SHA1Transform(context->state, context->workspace, (byte*)buffer, handsoff);\n            if (!handsoff)\n              memcpy((byte *)(data+i),buffer,sizeof(buffer));\n#endif\n#ifdef BIG_ENDIAN\n            if (!handsoff)\n            {\n              unsigned char *d=(unsigned char *)(data+i);\n              for (int k=0;k<64;k+=4)\n              {\n                byte b0=d[k],b1=d[k+1];\n                d[k]=d[k+3];\n                d[k+1]=d[k+2];\n                d[k+2]=b1;\n                d[k+3]=b0;\n              }\n            }\n#endif\n        }\n        j = 0;\n    }\n    else i = 0;\n    if (len > i)\n      memcpy(&context->buffer[j], &data[i], len - i);\n}\n\n\n/* Add padding and return the message digest. */\n\nvoid sha1_done( sha1_context* context, uint32 digest[5], bool handsoff)\n{\nuint i, j;\nunsigned char finalcount[8];\n\n    for (i = 0; i < 8; i++) {\n        finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)]\n         >> ((3-(i & 3)) * 8) ) & 255);  /* Endian independent */\n    }\n    unsigned char ch=(unsigned char)'\\200';\n    sha1_process(context, &ch, 1, handsoff);\n    while ((context->count[0] & 504) != 448) {\n        ch=0;\n        sha1_process(context, &ch, 1, handsoff);\n    }\n    sha1_process(context, finalcount, 8, handsoff);  /* Should cause a SHA1Transform() */\n    for (i = 0; i < 5; i++) {\n        digest[i] = context->state[i] & 0xffffffff;\n    }\n    /* Wipe variables */\n    cleandata(&i,sizeof(i));\n    cleandata(&j,sizeof(j));\n    cleandata(context->buffer, 64);\n    cleandata(context->state, 20);\n    cleandata(context->count, 8);\n    cleandata(&finalcount, 8);\n    if (handsoff)\n      memset(context->workspace,0,sizeof(context->workspace)); // Wipe the temporary buffer.\n//      SHA1Transform(context->state, context->workspace, context->buffer, true); /* make SHA1Transform overwrite it's own static vars */\n}\n\n\n","#include \"rar.hpp\"\n#include \"sha256.hpp\"\n\nstatic const uint32 K[64] = \n{\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n};\n\n#define ROTL(x, n) (((x) << (n)) | ((x) >> (32 - (n))))\n#define ROTR(x, n) (((x) >> (n)) | ((x) << (32 - (n))))\n\n// SHA-256 functions. We could optimize Ch and Maj a little,\n// but with no visible speed benefit.\n#define Ch(x, y, z)  ((x & y) ^ (~x & z))\n#define Maj(x, y, z) ((x & y) ^ (x & z) ^ (y & z))\n\n// Sigma functions.\n#define Sg0(x) (ROTR(x, 2) ^ ROTR(x,13) ^ ROTR(x, 22))\n#define Sg1(x) (ROTR(x, 6) ^ ROTR(x,11) ^ ROTR(x, 25))\n#define sg0(x) (ROTR(x, 7) ^ ROTR(x,18) ^ (x >> 3))\n#define sg1(x) (ROTR(x,17) ^ ROTR(x,19) ^ (x >> 10))\n\nvoid sha256_init(sha256_context *ctx)\n{\n  ctx->H[0] = 0x6a09e667; // Set the initial hash value.\n  ctx->H[1] = 0xbb67ae85;\n  ctx->H[2] = 0x3c6ef372;\n  ctx->H[3] = 0xa54ff53a;\n  ctx->H[4] = 0x510e527f;\n  ctx->H[5] = 0x9b05688c;\n  ctx->H[6] = 0x1f83d9ab;\n  ctx->H[7] = 0x5be0cd19;\n  ctx->Count    = 0;      // Processed data counter.\n}\n\n\ninline uint32 b2i(const byte *b) // Big endian bytes to integer.\n{\n#if defined(_MSC_VER)/* && defined(LITTLE_ENDIAN)*/\n  return _byteswap_ulong(*(uint32 *)b);\n#elif (__GNUC__ > 3) && (__GNUC_MINOR__ > 2)\n  return __builtin_bswap32(*(uint32 *)b);\n#else\n  return uint32(b[0]<<24) | uint32(b[1]<<16) | uint32(b[2]<<8) | b[3];\n#endif\n}\n\n\nstatic void sha256_transform(sha256_context *ctx)\n{\n  uint32 W[64]; // Words of message schedule.\n  uint32 v[8];  // FIPS a, b, c, d, e, f, g, h working variables.\n\n  if (ctx == NULL) // Clean variables and return.\n  {\n    cleandata(v,sizeof(v));\n    cleandata(W,sizeof(W));\n    return;\n  }\n\n  // Prepare message schedule. Loop unrolling provides some small gain here.\n  W[0] =  b2i(ctx->Data + 0 * 4 );   W[1] =  b2i(ctx->Data + 1 * 4 );\n  W[2] =  b2i(ctx->Data + 2 * 4 );   W[3] =  b2i(ctx->Data + 3 * 4 );\n  W[4] =  b2i(ctx->Data + 4 * 4 );   W[5] =  b2i(ctx->Data + 5 * 4 );\n  W[6] =  b2i(ctx->Data + 6 * 4 );   W[7] =  b2i(ctx->Data + 7 * 4 );\n  W[8] =  b2i(ctx->Data + 8 * 4 );   W[9] =  b2i(ctx->Data + 9 * 4 );\n  W[10] = b2i(ctx->Data + 10 * 4 );  W[11] = b2i(ctx->Data + 11 * 4 );\n  W[12] = b2i(ctx->Data + 12 * 4 );  W[13] = b2i(ctx->Data + 13 * 4 );\n  W[14] = b2i(ctx->Data + 14 * 4 );  W[15] = b2i(ctx->Data + 15 * 4 );\n\n  for (uint I = 16; I < 64; I++)\n    W[I] = sg1(W[I-2]) + W[I-7] + sg0(W[I-15]) + W[I-16];\n\n  uint32 *H=ctx->H;\n  v[0]=H[0]; v[1]=H[1]; v[2]=H[2]; v[3]=H[3];\n  v[4]=H[4]; v[5]=H[5]; v[6]=H[6]; v[7]=H[7];\n\n  // MSVC -O2 partially unrolls this loop automatically.\n  for (uint I = 0; I < 64; I++)\n  {\n    uint T1 = v[7] + Sg1(v[4]) + Ch(v[4], v[5], v[6]) + K[I] + W[I];\n\n    // It is possible to eliminate variable copying if we unroll loop\n    // and rename variables every time. But my test did not show any speed\n    // gain on i7 for such full or partial unrolling.\n    v[7] = v[6];\n    v[6] = v[5];\n    v[5] = v[4];\n    v[4] = v[3] + T1;\n\n    // It works a little faster when moved here from beginning of loop.\n    uint T2 = Sg0(v[0]) + Maj(v[0], v[1], v[2]);\n\n    v[3] = v[2];\n    v[2] = v[1];\n    v[1] = v[0];\n    v[0] = T1 + T2;\n  }\n\n  H[0]+=v[0]; H[1]+=v[1]; H[2]+=v[2]; H[3]+=v[3];\n  H[4]+=v[4]; H[5]+=v[5]; H[6]+=v[6]; H[7]+=v[7];\n}\n\n\nvoid sha256_process(sha256_context *ctx, const void *Data, size_t Size)\n{\n  const byte *Src=(const byte *)Data;\n  size_t BufPos = (uint)ctx->Count & 0x3f;\n  ctx->Count+=Size;\n  while (Size > 0)\n  {\n    size_t BufSpace=sizeof(ctx->Buffer)-BufPos;\n    size_t CopySize=Size>BufSpace ? BufSpace:Size;\n\n    if (CopySize == 64)\n      ctx->Data=Src; // Point to source data instead of copying it to buffer.\n    else\n    {\n      ctx->Data=ctx->Buffer;\n      memcpy(ctx->Buffer+BufPos,Src,CopySize);\n    }\n    Src+=CopySize;\n    BufPos+=CopySize;\n    Size-=CopySize;\n    if (BufPos == 64)\n    {\n      BufPos = 0;\n      sha256_transform(ctx);\n    }\n  }\n  sha256_transform(NULL);\n}\n\n\nvoid sha256_done(sha256_context *ctx, byte *Digest)\n{\n  ctx->Data = ctx->Buffer;\n  uint64 BitLength = ctx->Count * 8;\n  uint BufPos = (uint)ctx->Count & 0x3f;\n  ctx->Buffer[BufPos++] = 0x80; // Padding the message with \"1\" bit.\n  while (BufPos != 56) // We need 56 bytes block followed by 8 byte length.\n  {\n    BufPos &= 0x3f;\n    if (BufPos == 0)\n      sha256_transform(ctx);\n    ctx->Buffer[BufPos++] = 0;\n  }\n\n  for (uint i = 0; i < 8; i++) // Store bit length of entire message.\n  {\n    ctx->Buffer[BufPos++] = (byte)(BitLength >> 56);\n    BitLength <<= 8;\n  }\n  sha256_transform(ctx);\n\n  for (uint i = 0; i < 32; i++)\n    Digest[i] = byte(ctx->H[i / 4] >> ((3 - i % 4) * 8));\n\n  sha256_init(ctx);\n  sha256_transform(NULL);\n  cleandata(ctx->Buffer, sizeof(ctx->Buffer));\n}\n","/*\n   BLAKE2 reference source code package - reference C implementations\n\n   Written in 2012 by Samuel Neves <sneves@dei.uc.pt>\n\n   To the extent possible under law, the author(s) have dedicated all copyright\n   and related and neighboring rights to this software to the public domain\n   worldwide. This software is distributed without any warranty.\n\n   You should have received a copy of the CC0 Public Domain Dedication along with\n   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n*/\n\n#define PARALLELISM_DEGREE 8\n\nvoid blake2sp_init( blake2sp_state *S )\n{\n  memset( S->buf, 0, sizeof( S->buf ) );\n  S->buflen = 0;\n\n  blake2s_init_param( &S->R, 0, 1 ); // Init root.\n\n  for( uint i = 0; i < PARALLELISM_DEGREE; ++i )\n    blake2s_init_param( &S->S[i], i, 0 ); // Init leaf.\n\n  S->R.last_node = 1;\n  S->S[PARALLELISM_DEGREE - 1].last_node = 1;\n}\n\n\nstruct Blake2ThreadData\n{\n  void Update();\n  blake2s_state *S;\n  const byte *in;\n  size_t inlen;\n};\n\n\nvoid Blake2ThreadData::Update()\n{\n  size_t inlen__ = inlen;\n  const byte *in__ = ( const byte * )in;\n\n  while( inlen__ >= PARALLELISM_DEGREE * BLAKE2S_BLOCKBYTES )\n  {\n#ifdef USE_SSE\n    // We gain 5% in i7 SSE mode by prefetching next data block.\n    if (_SSE_Version>=SSE_SSE && inlen__ >= 2 * PARALLELISM_DEGREE * BLAKE2S_BLOCKBYTES)\n      _mm_prefetch((char*)(in__ +  PARALLELISM_DEGREE * BLAKE2S_BLOCKBYTES), _MM_HINT_T0);\n#endif\n    blake2s_update( S, in__, BLAKE2S_BLOCKBYTES );\n    in__ += PARALLELISM_DEGREE * BLAKE2S_BLOCKBYTES;\n    inlen__ -= PARALLELISM_DEGREE * BLAKE2S_BLOCKBYTES;\n  }\n}\n\n#ifdef RAR_SMP\nTHREAD_PROC(Blake2Thread)\n{\n  Blake2ThreadData *td=(Blake2ThreadData *)Data;\n  td->Update();\n}\n#endif\n\n\nvoid blake2sp_update( blake2sp_state *S, const byte *in, size_t inlen )\n{\n  size_t left = S->buflen;\n  size_t fill = sizeof( S->buf ) - left;\n\n  if( left && inlen >= fill )\n  {\n    memcpy( S->buf + left, in, fill );\n\n    for( size_t i = 0; i < PARALLELISM_DEGREE; ++i )\n      blake2s_update( &S->S[i], S->buf + i * BLAKE2S_BLOCKBYTES, BLAKE2S_BLOCKBYTES );\n\n    in += fill;\n    inlen -= fill;\n    left = 0;\n  }\n\n  Blake2ThreadData btd_array[PARALLELISM_DEGREE];\n\n#ifdef RAR_SMP\n  uint ThreadNumber = inlen < 0x1000 ? 1 : S->MaxThreads;\n  \n  if (ThreadNumber==6 || ThreadNumber==7) // 6 and 7 threads work slower than 4 here.\n    ThreadNumber=4;\n#else\n  uint ThreadNumber=1;\n#endif\n\n  for (size_t id__=0;id__<PARALLELISM_DEGREE;)\n  {\n    for (uint Thread=0;Thread<ThreadNumber && id__<PARALLELISM_DEGREE;Thread++)\n    {\n      Blake2ThreadData *btd=btd_array+Thread;\n\n      btd->inlen = inlen;\n      btd->in = in + id__ * BLAKE2S_BLOCKBYTES;\n      btd->S = &S->S[id__];\n  \n#ifdef RAR_SMP\n      if (ThreadNumber>1)\n        S->ThPool->AddTask(Blake2Thread,(void*)btd);\n      else\n        btd->Update();\n#else\n      btd->Update();\n#endif\n      id__++;\n    }\n#ifdef RAR_SMP\n    if (S->ThPool!=NULL) // Can be NULL in -mt1 mode.\n      S->ThPool->WaitDone();\n#endif // RAR_SMP\n  }\n\n  in += inlen - inlen % ( PARALLELISM_DEGREE * BLAKE2S_BLOCKBYTES );\n  inlen %= PARALLELISM_DEGREE * BLAKE2S_BLOCKBYTES;\n\n  if( inlen > 0 )\n    memcpy( S->buf + left, in, (size_t)inlen );\n\n  S->buflen = left + (size_t)inlen;\n}\n\n\nvoid blake2sp_final( blake2sp_state *S, byte *digest )\n{\n  byte hash[PARALLELISM_DEGREE][BLAKE2S_OUTBYTES];\n\n  for( size_t i = 0; i < PARALLELISM_DEGREE; ++i )\n  {\n    if( S->buflen > i * BLAKE2S_BLOCKBYTES )\n    {\n      size_t left = S->buflen - i * BLAKE2S_BLOCKBYTES;\n\n      if( left > BLAKE2S_BLOCKBYTES ) left = BLAKE2S_BLOCKBYTES;\n\n      blake2s_update( &S->S[i], S->buf + i * BLAKE2S_BLOCKBYTES, left );\n    }\n\n    blake2s_final( &S->S[i], hash[i] );\n  }\n\n  for( size_t i = 0; i < PARALLELISM_DEGREE; ++i )\n    blake2s_update( &S->R, hash[i], BLAKE2S_OUTBYTES );\n\n  blake2s_final( &S->R, digest );\n}\n","// Based on public domain code written in 2012 by Samuel Neves\n\n#include \"rar.hpp\"\n\n#ifdef USE_SSE\n#include \"blake2s_sse.cpp\"\n#endif\n\nstatic void blake2s_init_param( blake2s_state *S, uint32 node_offset, uint32 node_depth);\nstatic void blake2s_update( blake2s_state *S, const byte *in, size_t inlen );\nstatic void blake2s_final( blake2s_state *S, byte *digest );\n\n#include \"blake2sp.cpp\"\n\nstatic const uint32 blake2s_IV[8] =\n{\n  0x6A09E667UL, 0xBB67AE85UL, 0x3C6EF372UL, 0xA54FF53AUL,\n  0x510E527FUL, 0x9B05688CUL, 0x1F83D9ABUL, 0x5BE0CD19UL\n};\n\nstatic const byte blake2s_sigma[10][16] =\n{\n  {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,\n  { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 } ,\n  { 11,  8, 12,  0,  5,  2, 15, 13, 10, 14,  3,  6,  7,  1,  9,  4 } ,\n  {  7,  9,  3,  1, 13, 12, 11, 14,  2,  6,  5, 10,  4,  0, 15,  8 } ,\n  {  9,  0,  5,  7,  2,  4, 10, 15, 14,  1, 11, 12,  6,  8,  3, 13 } ,\n  {  2, 12,  6, 10,  0, 11,  8,  3,  4, 13,  7,  5, 15, 14,  1,  9 } ,\n  { 12,  5,  1, 15, 14, 13,  4, 10,  0,  7,  6,  3,  9,  2,  8, 11 } ,\n  { 13, 11,  7, 14, 12,  1,  3,  9,  5,  0, 15,  4,  8,  6,  2, 10 } ,\n  {  6, 15, 14,  9, 11,  3,  0,  8, 12,  2, 13,  7,  1,  4, 10,  5 } ,\n  { 10,  2,  8,  4,  7,  6,  1,  5, 15, 11,  9, 14,  3, 12, 13 , 0 } ,\n};\n\nstatic inline void blake2s_set_lastnode( blake2s_state *S )\n{\n  S->f[1] = ~0U;\n}\n\n\n/* Some helper functions, not necessarily useful */\nstatic inline void blake2s_set_lastblock( blake2s_state *S )\n{\n  if( S->last_node ) blake2s_set_lastnode( S );\n\n  S->f[0] = ~0U;\n}\n\n\nstatic inline void blake2s_increment_counter( blake2s_state *S, const uint32 inc )\n{\n  S->t[0] += inc;\n  S->t[1] += ( S->t[0] < inc );\n}\n\n\n/* init2 xors IV with input parameter block */\nvoid blake2s_init_param( blake2s_state *S, uint32 node_offset, uint32 node_depth)\n{\n#ifdef USE_SSE\n  if (_SSE_Version>=SSE_SSE2)\n    blake2s_init_sse();\n#endif\n\n  S->init(); // Clean data.\n  for( int i = 0; i < 8; ++i )\n    S->h[i] = blake2s_IV[i];\n\n  S->h[0] ^= 0x02080020; // We use BLAKE2sp parameters block.\n  S->h[2] ^= node_offset;\n  S->h[3] ^= (node_depth<<16)|0x20000000;\n}\n\n\nstatic _forceinline uint32 rotr32( const uint32 w, const unsigned c )\n{\n  return ( w >> c ) | ( w << ( 32 - c ) );\n}\n\n\n#define G(r,i,m,a,b,c,d) \\\n  a = a + b + m[blake2s_sigma[r][2*i+0]]; \\\n  d = rotr32(d ^ a, 16); \\\n  c = c + d; \\\n  b = rotr32(b ^ c, 12); \\\n  a = a + b + m[blake2s_sigma[r][2*i+1]]; \\\n  d = rotr32(d ^ a, 8); \\\n  c = c + d; \\\n  b = rotr32(b ^ c, 7);\n\n\nstatic void blake2s_compress( blake2s_state *S, const byte block[BLAKE2S_BLOCKBYTES] )\n{\n  uint32 m[16];\n  uint32 v[16];\n\n  for( size_t i = 0; i < 16; ++i )\n    m[i] = RawGet4( block + i * 4 );\n\n  for( size_t i = 0; i < 8; ++i )\n    v[i] = S->h[i];\n\n  v[ 8] = blake2s_IV[0];\n  v[ 9] = blake2s_IV[1];\n  v[10] = blake2s_IV[2];\n  v[11] = blake2s_IV[3];\n  v[12] = S->t[0] ^ blake2s_IV[4];\n  v[13] = S->t[1] ^ blake2s_IV[5];\n  v[14] = S->f[0] ^ blake2s_IV[6];\n  v[15] = S->f[1] ^ blake2s_IV[7];\n\n  for ( uint r = 0; r <= 9; ++r ) // No gain on i7 if unrolled, but exe size grows.\n  {\n    G(r,0,m,v[ 0],v[ 4],v[ 8],v[12]);\n    G(r,1,m,v[ 1],v[ 5],v[ 9],v[13]);\n    G(r,2,m,v[ 2],v[ 6],v[10],v[14]);\n    G(r,3,m,v[ 3],v[ 7],v[11],v[15]);\n    G(r,4,m,v[ 0],v[ 5],v[10],v[15]);\n    G(r,5,m,v[ 1],v[ 6],v[11],v[12]);\n    G(r,6,m,v[ 2],v[ 7],v[ 8],v[13]);\n    G(r,7,m,v[ 3],v[ 4],v[ 9],v[14]);\n  }\n\n  for( size_t i = 0; i < 8; ++i )\n    S->h[i] = S->h[i] ^ v[i] ^ v[i + 8];\n}\n\n\nvoid blake2s_update( blake2s_state *S, const byte *in, size_t inlen )\n{\n  while( inlen > 0 )\n  {\n    size_t left = S->buflen;\n    size_t fill = 2 * BLAKE2S_BLOCKBYTES - left;\n\n    if( inlen > fill )\n    {\n      memcpy( S->buf + left, in, fill ); // Fill buffer\n      S->buflen += fill;\n      blake2s_increment_counter( S, BLAKE2S_BLOCKBYTES );\n\n#ifdef USE_SSE\n#ifdef _WIN_32 // We use SSSE3 _mm_shuffle_epi8 only in x64 mode.\n      if (_SSE_Version>=SSE_SSE2)\n#else\n      if (_SSE_Version>=SSE_SSSE3)\n#endif\n        blake2s_compress_sse( S, S->buf );\n      else\n        blake2s_compress( S, S->buf ); // Compress\n#else\n      blake2s_compress( S, S->buf ); // Compress\n#endif\n      \n      memcpy( S->buf, S->buf + BLAKE2S_BLOCKBYTES, BLAKE2S_BLOCKBYTES ); // Shift buffer left\n      S->buflen -= BLAKE2S_BLOCKBYTES;\n      in += fill;\n      inlen -= fill;\n    }\n    else // inlen <= fill\n    {\n      memcpy( S->buf + left, in, (size_t)inlen );\n      S->buflen += (size_t)inlen; // Be lazy, do not compress\n      in += inlen;\n      inlen = 0;\n    }\n  }\n}\n\n\nvoid blake2s_final( blake2s_state *S, byte *digest )\n{\n  if( S->buflen > BLAKE2S_BLOCKBYTES )\n  {\n    blake2s_increment_counter( S, BLAKE2S_BLOCKBYTES );\n    blake2s_compress( S, S->buf );\n    S->buflen -= BLAKE2S_BLOCKBYTES;\n    memcpy( S->buf, S->buf + BLAKE2S_BLOCKBYTES, S->buflen );\n  }\n\n  blake2s_increment_counter( S, ( uint32 )S->buflen );\n  blake2s_set_lastblock( S );\n  memset( S->buf + S->buflen, 0, 2 * BLAKE2S_BLOCKBYTES - S->buflen ); /* Padding */\n  blake2s_compress( S, S->buf );\n\n  for( int i = 0; i < 8; ++i ) /* Output full hash  */\n    RawPut4( S->h[i], digest + 4 * i );\n}\n\n","// Based on public domain code written in 2012 by Samuel Neves\n#ifndef _RAR_BLAKE2_\n#define _RAR_BLAKE2_\n\n#define BLAKE2_DIGEST_SIZE 32\n\nenum blake2s_constant\n{\n  BLAKE2S_BLOCKBYTES = 64,\n  BLAKE2S_OUTBYTES   = 32\n};\n\n\n// Alignment to 64 improves performance of both SSE and non-SSE versions.\n// Alignment to n*16 is required for SSE version, so we selected 64.\n// We use the custom alignment scheme instead of __declspec(align(x)),\n// because it is less compiler dependent. Also the compiler directive\n// does not help if structure is a member of class allocated through\n// 'new' operator.\nstruct blake2s_state\n{\n  enum { BLAKE_ALIGNMENT = 64 };\n\n  // buffer and uint32 h[8], t[2], f[2];\n  enum { BLAKE_DATA_SIZE = 48 + 2 * BLAKE2S_BLOCKBYTES };\n\n  byte ubuf[BLAKE_DATA_SIZE + BLAKE_ALIGNMENT];\n\n  byte   *buf;       // byte   buf[2 * BLAKE2S_BLOCKBYTES].\n  uint32 *h, *t, *f; // uint32 h[8], t[2], f[2].\n\n  size_t   buflen;\n  byte  last_node;\n\n  blake2s_state()\n  {\n    set_pointers();\n  }\n\n  // Required when we declare and assign in the same command.\n  blake2s_state(blake2s_state &st)\n  {\n    set_pointers();\n    *this=st;\n  }\n\n  void set_pointers()\n  {\n    // Set aligned pointers. Must be done in constructor, not in Init(),\n    // so assignments like 'blake2sp_state res=blake2ctx' work correctly\n    // even if blake2sp_init is not called for 'res'.\n    buf = (byte *) ALIGN_VALUE(ubuf, BLAKE_ALIGNMENT);\n    h   = (uint32 *) (buf + 2 * BLAKE2S_BLOCKBYTES);\n    t   = h + 8;\n    f   = t + 2;\n  }\n\n  void init()\n  {\n    memset( ubuf, 0, sizeof( ubuf ) );\n    buflen = 0;\n    last_node = 0;\n  }\n\n  // Since we use pointers, the default = would work incorrectly.\n  blake2s_state& operator = (blake2s_state &st)\n  {\n    if (this != &st)\n    {\n      memcpy(buf, st.buf, BLAKE_DATA_SIZE);\n      buflen = st.buflen;\n      last_node = st.last_node;\n    }\n    return *this;\n  }\n};\n\n\n#ifdef RAR_SMP\nclass ThreadPool;\n#endif\n\nstruct blake2sp_state\n{\n  blake2s_state S[8];\n  blake2s_state R;\n  byte buf[8 * BLAKE2S_BLOCKBYTES];\n  size_t buflen;\n\n#ifdef RAR_SMP\n  ThreadPool *ThPool;\n  uint MaxThreads;\n#endif\n};\n\nvoid blake2sp_init( blake2sp_state *S );\nvoid blake2sp_update( blake2sp_state *S, const byte *in, size_t inlen );\nvoid blake2sp_final( blake2sp_state *S, byte *digest );\n\n#endif\n\n","#include \"rar.hpp\"\n\nvoid HashValue::Init(HASH_TYPE Type)\n{\n  HashValue::Type=Type;\n\n  // Zero length data CRC32 is 0. It is important to set it when creating\n  // headers with no following data like directories or symlinks.\n  if (Type==HASH_RAR14 || Type==HASH_CRC32)\n    CRC32=0;\n  if (Type==HASH_BLAKE2)\n  {\n    // dd0e891776933f43c7d032b08a917e25741f8aa9a12c12e1cac8801500f2ca4f\n    // is BLAKE2sp hash of empty data. We init the structure to this value,\n    // so if we create a file or service header with no following data like\n    // \"file copy\" or \"symlink\", we set the checksum to proper value avoiding\n    // additional header type or size checks when extracting.\n    static byte EmptyHash[32]={\n      0xdd, 0x0e, 0x89, 0x17, 0x76, 0x93, 0x3f, 0x43,\n      0xc7, 0xd0, 0x32, 0xb0, 0x8a, 0x91, 0x7e, 0x25,\n      0x74, 0x1f, 0x8a, 0xa9, 0xa1, 0x2c, 0x12, 0xe1,\n      0xca, 0xc8, 0x80, 0x15, 0x00, 0xf2, 0xca, 0x4f\n    };\n    memcpy(Digest,EmptyHash,sizeof(Digest));\n  }\n}\n\n\nbool HashValue::operator == (const HashValue &cmp)\n{\n  if (Type==HASH_NONE || cmp.Type==HASH_NONE)\n    return true;\n  if (Type==HASH_RAR14 && cmp.Type==HASH_RAR14 || \n      Type==HASH_CRC32 && cmp.Type==HASH_CRC32)\n    return CRC32==cmp.CRC32;\n  if (Type==HASH_BLAKE2 && cmp.Type==HASH_BLAKE2)\n    return memcmp(Digest,cmp.Digest,sizeof(Digest))==0;\n  return false;\n}\n\n\nDataHash::DataHash()\n{\n  blake2ctx=NULL;\n  HashType=HASH_NONE;\n#ifdef RAR_SMP\n  ThPool=NULL;\n  MaxThreads=0;\n#endif\n}\n\n\nDataHash::~DataHash()\n{\n#ifdef RAR_SMP\n  DestroyThreadPool(ThPool);\n#endif\n  cleandata(&CurCRC32, sizeof(CurCRC32));\n  if (blake2ctx!=NULL)\n  {\n    cleandata(blake2ctx, sizeof(blake2sp_state));\n    delete blake2ctx;\n  }\n}\n\n\nvoid DataHash::Init(HASH_TYPE Type,uint MaxThreads)\n{\n  if (blake2ctx==NULL)\n    blake2ctx=new blake2sp_state;\n  HashType=Type;\n  if (Type==HASH_RAR14)\n    CurCRC32=0;\n  if (Type==HASH_CRC32)\n    CurCRC32=0xffffffff; // Initial CRC32 value.\n  if (Type==HASH_BLAKE2)\n    blake2sp_init(blake2ctx);\n#ifdef RAR_SMP\n  DataHash::MaxThreads=Min(MaxThreads,MaxHashThreads);\n#endif\n}\n\n\nvoid DataHash::Update(const void *Data,size_t DataSize)\n{\n#ifndef SFX_MODULE\n  if (HashType==HASH_RAR14)\n    CurCRC32=Checksum14((ushort)CurCRC32,Data,DataSize);\n#endif\n  if (HashType==HASH_CRC32)\n    CurCRC32=CRC32(CurCRC32,Data,DataSize);\n\n  if (HashType==HASH_BLAKE2)\n  {\n#ifdef RAR_SMP\n    if (MaxThreads>1 && ThPool==NULL)\n      ThPool=CreateThreadPool();\n    blake2ctx->ThPool=ThPool;\n    blake2ctx->MaxThreads=MaxThreads;\n#endif\n    blake2sp_update( blake2ctx, (byte *)Data, DataSize);\n  }\n}\n\n\nvoid DataHash::Result(HashValue *Result)\n{\n  Result->Type=HashType;\n  if (HashType==HASH_RAR14)\n    Result->CRC32=CurCRC32;\n  if (HashType==HASH_CRC32)\n    Result->CRC32=CurCRC32^0xffffffff;\n  if (HashType==HASH_BLAKE2)\n  {\n    // Preserve the original context, so we can continue hashing if necessary.\n    blake2sp_state res=*blake2ctx;\n    blake2sp_final(&res,Result->Digest);\n  }\n}\n\n\nuint DataHash::GetCRC32()\n{\n  return HashType==HASH_CRC32 ? CurCRC32^0xffffffff : 0;\n}\n\n\nbool DataHash::Cmp(HashValue *CmpValue,byte *Key)\n{\n  HashValue Final;\n  Result(&Final);\n  if (Key!=NULL)\n    ConvertHashToMAC(&Final,Key);\n  return Final==*CmpValue;\n}\n","bool ExtractHardlink(wchar *NameNew,wchar *NameExisting,size_t NameExistingSize)\n{\n  SlashToNative(NameExisting,NameExisting,NameExistingSize); // Not needed for RAR 5.1+ archives.\n\n  if (!FileExist(NameExisting))\n    return false;\n  CreatePath(NameNew,true);\n\n#ifdef _WIN_ALL\n  bool Success=CreateHardLink(NameNew,NameExisting,NULL)!=0;\n  if (!Success)\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    ErrHandler.SysErrMsg();\n    ErrHandler.SetErrorCode(RARX_CREATE);\n  }\n  return Success;\n#elif defined(_UNIX)\n  char NameExistingA[NM],NameNewA[NM];\n  WideToChar(NameExisting,NameExistingA,ASIZE(NameExistingA));\n  WideToChar(NameNew,NameNewA,ASIZE(NameNewA));\n  bool Success=link(NameExistingA,NameNewA)==0;\n  if (!Success)\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    ErrHandler.SysErrMsg();\n    ErrHandler.SetErrorCode(RARX_CREATE);\n  }\n  return Success;\n#else\n  return false;\n#endif\n}\n\n","#ifndef _RAR_PATHFN_\n#define _RAR_PATHFN_\n\nwchar* PointToName(const wchar *Path);\nwchar* PointToLastChar(const wchar *Path);\nwchar* ConvertPath(const wchar *SrcPath,wchar *DestPath);\nvoid SetName(wchar *FullName,const wchar *Name,size_t MaxSize);\nvoid SetExt(wchar *Name,const wchar *NewExt,size_t MaxSize);\nvoid SetSFXExt(wchar *SFXName,size_t MaxSize);\nwchar *GetExt(const wchar *Name);\nbool CmpExt(const wchar *Name,const wchar *Ext);\nbool IsWildcard(const wchar *Str);\nbool IsPathDiv(int Ch);\nbool IsDriveDiv(int Ch);\nbool IsDriveLetter(const wchar *Path);\nint GetPathDisk(const wchar *Path);\nvoid AddEndSlash(wchar *Path,size_t MaxLength);\nvoid MakeName(const wchar *Path,const wchar *Name,wchar *Pathname,size_t MaxSize);\nvoid GetFilePath(const wchar *FullName,wchar *Path,size_t MaxLength);\nvoid RemoveNameFromPath(wchar *Path);\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\nbool GetAppDataPath(wchar *Path,size_t MaxSize,bool Create);\nvoid GetRarDataPath(wchar *Path,size_t MaxSize,bool Create);\n#endif\n#ifndef SFX_MODULE\nbool EnumConfigPaths(uint Number,wchar *Path,size_t MaxSize,bool Create);\nvoid GetConfigName(const wchar *Name,wchar *FullName,size_t MaxSize,bool CheckExist,bool Create);\n#endif\nwchar* GetVolNumPart(const wchar *ArcName);\nvoid NextVolumeName(wchar *ArcName,uint MaxLength,bool OldNumbering);\nbool IsNameUsable(const wchar *Name);\nvoid MakeNameUsable(char *Name,bool Extended);\nvoid MakeNameUsable(wchar *Name,bool Extended);\n\nvoid UnixSlashToDos(const char *SrcName,char *DestName,size_t MaxLength);\nvoid DosSlashToUnix(const char *SrcName,char *DestName,size_t MaxLength);\nvoid UnixSlashToDos(const wchar *SrcName,wchar *DestName,size_t MaxLength);\nvoid DosSlashToUnix(const wchar *SrcName,wchar *DestName,size_t MaxLength);\n\ninline void SlashToNative(const char *SrcName,char *DestName,size_t MaxLength)\n{\n#ifdef _WIN_ALL\n  UnixSlashToDos(SrcName,DestName,MaxLength);\n#else\n  DosSlashToUnix(SrcName,DestName,MaxLength);\n#endif\n}\n\ninline void SlashToNative(const wchar *SrcName,wchar *DestName,size_t MaxLength)\n{\n#ifdef _WIN_ALL\n  UnixSlashToDos(SrcName,DestName,MaxLength);\n#else\n  DosSlashToUnix(SrcName,DestName,MaxLength);\n#endif\n}\n\nvoid ConvertNameToFull(const wchar *Src,wchar *Dest,size_t MaxSize);\nbool IsFullPath(const wchar *Path);\nbool IsFullRootPath(const wchar *Path);\nvoid GetPathRoot(const wchar *Path,wchar *Root,size_t MaxSize);\nint ParseVersionFileName(wchar *Name,bool Truncate);\nwchar* VolNameToFirstName(const wchar *VolName,wchar *FirstName,size_t MaxSize,bool NewNumbering);\nwchar* GetWideName(const char *Name,const wchar *NameW,wchar *DestW,size_t DestSize);\n\n#ifndef SFX_MODULE\nvoid GenerateArchiveName(wchar *ArcName,size_t MaxSize,const wchar *GenerateMask,bool Archiving);\n#endif\n\n#ifdef _WIN_ALL\nbool GetWinLongPath(const wchar *Src,wchar *Dest,size_t MaxSize);\nvoid ConvertToPrecomposed(wchar *Name,size_t NameSize);\nvoid MakeNameCompatible(wchar *Name);\n#endif\n\n#endif\n","\n\nvoid ExtractUnixOwner20(Archive &Arc,const wchar *FileName)\n{\n  char NameA[NM];\n  WideToChar(FileName,NameA,ASIZE(NameA));\n\n  if (Arc.BrokenHeader)\n  {\n    uiMsg(UIERROR_UOWNERBROKEN,Arc.FileName,FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return;\n  }\n\n  struct passwd *pw;\n  errno=0; // Required by getpwnam specification if we need to check errno.\n  if ((pw=getpwnam(Arc.UOHead.OwnerName))==NULL)\n  {\n    uiMsg(UIERROR_UOWNERGETOWNERID,Arc.FileName,GetWide(Arc.UOHead.OwnerName));\n    ErrHandler.SysErrMsg();\n    ErrHandler.SetErrorCode(RARX_WARNING);\n    return;\n  }\n  uid_t OwnerID=pw->pw_uid;\n\n  struct group *gr;\n  errno=0; // Required by getgrnam specification if we need to check errno.\n  if ((gr=getgrnam(Arc.UOHead.GroupName))==NULL)\n  {\n    uiMsg(UIERROR_UOWNERGETGROUPID,Arc.FileName,GetWide(Arc.UOHead.GroupName));\n    ErrHandler.SysErrMsg();\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return;\n  }\n  uint Attr=GetFileAttr(FileName);\n  gid_t GroupID=gr->gr_gid;\n#if defined(SAVE_LINKS) && !defined(_APPLE)\n  if (lchown(NameA,OwnerID,GroupID)!=0)\n#else\n  if (chown(NameA,OwnerID,GroupID)!=0)\n#endif\n  {\n    uiMsg(UIERROR_UOWNERSET,Arc.FileName,FileName);\n    ErrHandler.SetErrorCode(RARX_CREATE);\n  }\n  SetFileAttr(FileName,Attr);\n}\n\n\nvoid ExtractUnixOwner30(Archive &Arc,const wchar *FileName)\n{\n  char NameA[NM];\n  WideToChar(FileName,NameA,ASIZE(NameA));\n\n  char *OwnerName=(char *)&Arc.SubHead.SubData[0];\n  int OwnerSize=strlen(OwnerName)+1;\n  int GroupSize=Arc.SubHead.SubData.Size()-OwnerSize;\n  char GroupName[NM];\n  strncpy(GroupName,(char *)&Arc.SubHead.SubData[OwnerSize],GroupSize);\n  GroupName[GroupSize]=0;\n\n  struct passwd *pw;\n  if ((pw=getpwnam(OwnerName))==NULL)\n  {\n    uiMsg(UIERROR_UOWNERGETOWNERID,Arc.FileName,GetWide(OwnerName));\n    ErrHandler.SetErrorCode(RARX_WARNING);\n    return;\n  }\n  uid_t OwnerID=pw->pw_uid;\n\n  struct group *gr;\n  if ((gr=getgrnam(GroupName))==NULL)\n  {\n    uiMsg(UIERROR_UOWNERGETGROUPID,Arc.FileName,GetWide(GroupName));\n    ErrHandler.SetErrorCode(RARX_WARNING);\n    return;\n  }\n  uint Attr=GetFileAttr(FileName);\n  gid_t GroupID=gr->gr_gid;\n#if defined(SAVE_LINKS) && !defined(_APPLE)\n  if (lchown(NameA,OwnerID,GroupID)!=0)\n#else\n  if (chown(NameA,OwnerID,GroupID)!=0)\n#endif\n  {\n    uiMsg(UIERROR_UOWNERSET,Arc.FileName,FileName);\n    ErrHandler.SetErrorCode(RARX_CREATE);\n  }\n  SetFileAttr(FileName,Attr);\n}\n\n\nvoid SetUnixOwner(Archive &Arc,const wchar *FileName)\n{\n  char NameA[NM];\n  WideToChar(FileName,NameA,ASIZE(NameA));\n\n  // First, we try to resolve symbolic names. If they are missing or cannot\n  // be resolved, we try to use numeric values if any. If numeric values\n  // are missing too, function fails.\n  FileHeader &hd=Arc.FileHead;\n  if (*hd.UnixOwnerName!=0)\n  {\n    struct passwd *pw;\n    if ((pw=getpwnam(hd.UnixOwnerName))==NULL)\n    {\n      if (!hd.UnixOwnerNumeric)\n      {\n        uiMsg(UIERROR_UOWNERGETOWNERID,Arc.FileName,GetWide(hd.UnixOwnerName));\n        ErrHandler.SetErrorCode(RARX_WARNING);\n        return;\n      }\n    }\n    else\n      hd.UnixOwnerID=pw->pw_uid;\n  }\n  if (*hd.UnixGroupName!=0)\n  {\n    struct group *gr;\n    if ((gr=getgrnam(hd.UnixGroupName))==NULL)\n    {\n      if (!hd.UnixGroupNumeric)\n      {\n        uiMsg(UIERROR_UOWNERGETGROUPID,Arc.FileName,GetWide(hd.UnixGroupName));\n        ErrHandler.SetErrorCode(RARX_WARNING);\n        return;\n      }\n    }\n    else\n      hd.UnixGroupID=gr->gr_gid;\n  }\n#if defined(SAVE_LINKS) && !defined(_APPLE)\n  if (lchown(NameA,hd.UnixOwnerID,hd.UnixGroupID)!=0)\n#else\n  if (chown(NameA,hd.UnixOwnerID,hd.UnixGroupID)!=0)\n#endif\n  {\n    uiMsg(UIERROR_UOWNERSET,Arc.FileName,FileName);\n    ErrHandler.SetErrorCode(RARX_CREATE);\n  }\n}\n","\n\nstatic bool UnixSymlink(const char *Target,const wchar *LinkName,RarTime *ftm,RarTime *fta)\n{\n  CreatePath(LinkName,true);\n  DelFile(LinkName);\n  char LinkNameA[NM];\n  WideToChar(LinkName,LinkNameA,ASIZE(LinkNameA));\n  if (symlink(Target,LinkNameA)==-1) // Error.\n  {\n    if (errno==EEXIST)\n      uiMsg(UIERROR_ULINKEXIST,LinkName);\n    else\n    {\n      uiMsg(UIERROR_SLINKCREATE,UINULL,LinkName);\n      ErrHandler.SetErrorCode(RARX_WARNING);\n    }\n    return false;\n  }\n#ifdef USE_LUTIMES\n  struct timeval tv[2];\n  tv[0].tv_sec=fta->GetUnix();\n  tv[0].tv_usec=long(fta->GetRaw()%10000000/10);\n  tv[1].tv_sec=ftm->GetUnix();\n  tv[1].tv_usec=long(ftm->GetRaw()%10000000/10);\n  lutimes(LinkNameA,tv);\n#endif\n\n  return true;\n}\n\n\nstatic bool IsFullPath(const char *PathA) // Unix ASCII version.\n{\n  return *PathA==CPATHDIVIDER;\n}\n\n\nbool ExtractUnixLink30(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)\n{\n  char Target[NM];\n  if (IsLink(Arc.FileHead.FileAttr))\n  {\n    size_t DataSize=Min(Arc.FileHead.PackSize,ASIZE(Target)-1);\n    DataIO.UnpRead((byte *)Target,DataSize);\n    Target[DataSize]=0;\n\n    DataIO.UnpHash.Init(Arc.FileHead.FileHash.Type,1);\n    DataIO.UnpHash.Update(Target,strlen(Target));\n    DataIO.UnpHash.Result(&Arc.FileHead.FileHash);\n\n    // Return true in case of bad checksum, so link will be processed further\n    // and extraction routine will report the checksum error.\n    if (!DataIO.UnpHash.Cmp(&Arc.FileHead.FileHash,Arc.FileHead.UseHashKey ? Arc.FileHead.HashKey:NULL))\n      return true;\n\n    if (!Cmd->AbsoluteLinks && (IsFullPath(Target) ||\n        !IsRelativeSymlinkSafe(Arc.FileHead.FileName,Arc.FileHead.RedirName)))\n      return false;\n    return UnixSymlink(Target,LinkName,&Arc.FileHead.mtime,&Arc.FileHead.atime);\n  }\n  return false;\n}\n\n\nbool ExtractUnixLink50(CommandData *Cmd,const wchar *Name,FileHeader *hd)\n{\n  char Target[NM];\n  WideToChar(hd->RedirName,Target,ASIZE(Target));\n  if (hd->RedirType==FSREDIR_WINSYMLINK || hd->RedirType==FSREDIR_JUNCTION)\n  {\n    // Cannot create Windows absolute path symlinks in Unix. Only relative path\n    // Windows symlinks can be created here. RAR 5.0 used \\??\\ prefix\n    // for Windows absolute symlinks, since RAR 5.1 /??/ is used.\n    // We escape ? as \\? to avoid \"trigraph\" warning\n    if (strncmp(Target,\"\\\\??\\\\\",4)==0 || strncmp(Target,\"/\\?\\?/\",4)==0)\n      return false;\n    DosSlashToUnix(Target,Target,ASIZE(Target));\n  }\n  if (!Cmd->AbsoluteLinks && (IsFullPath(Target) ||\n      !IsRelativeSymlinkSafe(hd->FileName,hd->RedirName)))\n    return false;\n  return UnixSymlink(Target,Name,&hd->mtime,&hd->atime);\n}\n","#include \"rar.hpp\"\n\n#include \"hardlinks.cpp\"\n#include \"win32stm.cpp\"\n\n#ifdef _WIN_ALL\n#include \"win32acl.cpp\"\n#include \"win32lnk.cpp\"\n#endif\n\n#ifdef _UNIX\n#include \"uowners.cpp\"\n#ifdef SAVE_LINKS\n#include \"ulinks.cpp\"\n#endif\n#endif\n\n\n\n#ifndef SFX_MODULE\nvoid SetExtraInfo20(CommandData *Cmd,Archive &Arc,wchar *Name)\n{\n  if (Cmd->Test)\n    return;\n  switch(Arc.SubBlockHead.SubType)\n  {\n#ifdef _UNIX\n    case UO_HEAD:\n      if (Cmd->ProcessOwners)\n        ExtractUnixOwner20(Arc,Name);\n      break;\n#endif\n#ifdef _WIN_ALL\n    case NTACL_HEAD:\n      if (Cmd->ProcessOwners)\n        ExtractACL20(Arc,Name);\n      break;\n    case STREAM_HEAD:\n      ExtractStreams20(Arc,Name);\n      break;\n#endif\n  }\n}\n#endif\n\n\nvoid SetExtraInfo(CommandData *Cmd,Archive &Arc,wchar *Name)\n{\n#ifdef _UNIX\n  if (!Cmd->Test && Cmd->ProcessOwners && Arc.Format==RARFMT15 &&\n      Arc.SubHead.CmpName(SUBHEAD_TYPE_UOWNER))\n    ExtractUnixOwner30(Arc,Name);\n#endif\n#ifdef _WIN_ALL\n  if (!Cmd->Test && Cmd->ProcessOwners && Arc.SubHead.CmpName(SUBHEAD_TYPE_ACL))\n    ExtractACL(Arc,Name);\n  if (Arc.SubHead.CmpName(SUBHEAD_TYPE_STREAM))\n    ExtractStreams(Arc,Name,Cmd->Test);\n#endif\n}\n\n\n\n\nbool IsRelativeSymlinkSafe(const wchar *SrcName,const wchar *TargetName)\n{\n  if (IsFullRootPath(SrcName))\n    return false;\n  int AllowedDepth=0;\n  while (*SrcName!=0)\n  {\n    if (IsPathDiv(SrcName[0]) && SrcName[1]!=0 && !IsPathDiv(SrcName[1]))\n    {\n      bool Dot=SrcName[1]=='.' && (IsPathDiv(SrcName[2]) || SrcName[2]==0);\n      bool Dot2=SrcName[1]=='.' && SrcName[2]=='.' && (IsPathDiv(SrcName[3]) || SrcName[3]==0);\n      if (!Dot && !Dot2)\n        AllowedDepth++;\n    }\n    SrcName++;\n  }\n  if (IsFullRootPath(TargetName)) // Catch root dir based /path/file paths.\n    return false;\n  for (int Pos=0;*TargetName!=0;Pos++)\n  {\n    bool Dot2=TargetName[0]=='.' && TargetName[1]=='.' && \n              (IsPathDiv(TargetName[2]) || TargetName[2]==0) &&\n              (Pos==0 || IsPathDiv(*(TargetName-1)));\n    if (Dot2)\n      AllowedDepth--;\n    TargetName++;\n  }\n  return AllowedDepth>=0;\n}\n\n\nbool ExtractSymlink(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)\n{\n#if defined(SAVE_LINKS) && defined(_UNIX)\n  // For RAR 3.x archives we process links even in test mode to skip link data.\n  if (Arc.Format==RARFMT15)\n    return ExtractUnixLink30(Cmd,DataIO,Arc,LinkName);\n  if (Arc.Format==RARFMT50)\n    return ExtractUnixLink50(Cmd,LinkName,&Arc.FileHead);\n#elif defined _WIN_ALL\n  // RAR 5.0 archives store link information in file header, so there is\n  // no need to additionally test it if we do not create a file.\n  if (Arc.Format==RARFMT50)\n    return CreateReparsePoint(Cmd,LinkName,&Arc.FileHead);\n#endif\n  return false;\n}\n","#include \"rar.hpp\"\n\nCmdExtract::CmdExtract(CommandData *Cmd)\n{\n  CmdExtract::Cmd=Cmd;\n\n  *ArcName=0;\n\n  *DestFileName=0;\n\n  TotalFileCount=0;\n  Unp=new Unpack(&DataIO);\n#ifdef RAR_SMP\n  Unp->SetThreads(Cmd->Threads);\n#endif\n}\n\n\nCmdExtract::~CmdExtract()\n{\n  delete Unp;\n}\n\n\nvoid CmdExtract::DoExtract()\n{\n#if defined(_WIN_ALL) && !defined(SFX_MODULE) && !defined(SILENT)\n  Fat32=NotFat32=false;\n#endif\n  PasswordCancelled=false;\n  DataIO.SetCurrentCommand(Cmd->Command[0]);\n\n  FindData FD;\n  while (Cmd->GetArcName(ArcName,ASIZE(ArcName)))\n    if (FindFile::FastFind(ArcName,&FD))\n      DataIO.TotalArcSize+=FD.Size;\n\n  Cmd->ArcNames.Rewind();\n  while (Cmd->GetArcName(ArcName,ASIZE(ArcName)))\n  {\n    if (Cmd->ManualPassword)\n      Cmd->Password.Clean(); // Clean user entered password before processing next archive.\n    while (true)\n    {\n      EXTRACT_ARC_CODE Code=ExtractArchive();\n      if (Code!=EXTRACT_ARC_REPEAT)\n        break;\n    }\n    if (FindFile::FastFind(ArcName,&FD))\n      DataIO.ProcessedArcSize+=FD.Size;\n  }\n\n  // Clean user entered password. Not really required, just for extra safety.\n  if (Cmd->ManualPassword)\n    Cmd->Password.Clean();\n\n  if (TotalFileCount==0 && Cmd->Command[0]!='I' && \n      ErrHandler.GetErrorCode()!=RARX_BADPWD) // Not in case of wrong archive password.\n  {\n    if (!PasswordCancelled)\n      uiMsg(UIERROR_NOFILESTOEXTRACT,ArcName);\n    ErrHandler.SetErrorCode(RARX_NOFILES);\n  }\n#ifndef GUI\n  else\n    if (!Cmd->DisableDone)\n      if (Cmd->Command[0]=='I')\n        mprintf(St(MDone));\n      else\n        if (ErrHandler.GetErrorCount()==0)\n          mprintf(St(MExtrAllOk));\n        else\n          mprintf(St(MExtrTotalErr),ErrHandler.GetErrorCount());\n#endif\n}\n\n\nvoid CmdExtract::ExtractArchiveInit(Archive &Arc)\n{\n  DataIO.UnpArcSize=Arc.FileLength();\n\n  FileCount=0;\n  MatchedArgs=0;\n#ifndef SFX_MODULE\n  FirstFile=true;\n#endif\n\n  PasswordAll=(Cmd->Password.IsSet());\n\n  DataIO.UnpVolume=false;\n\n  PrevProcessed=false;\n  AllMatchesExact=true;\n  ReconstructDone=false;\n  AnySolidDataUnpackedWell=false;\n\n  StartTime.SetCurrentTime();\n}\n\n\nEXTRACT_ARC_CODE CmdExtract::ExtractArchive()\n{\n  Archive Arc(Cmd);\n  if (!Arc.WOpen(ArcName))\n    return EXTRACT_ARC_NEXT;\n\n  if (!Arc.IsArchive(true))\n  {\n#if !defined(SFX_MODULE) && !defined(RARDLL)\n    if (CmpExt(ArcName,L\"rev\"))\n    {\n      wchar FirstVolName[NM];\n      VolNameToFirstName(ArcName,FirstVolName,ASIZE(FirstVolName),true);\n\n      // If several volume names from same volume set are specified\n      // and current volume is not first in set and first volume is present\n      // and specified too, let's skip the current volume.\n      if (wcsicomp(ArcName,FirstVolName)!=0 && FileExist(FirstVolName) &&\n          Cmd->ArcNames.Search(FirstVolName,false))\n        return EXTRACT_ARC_NEXT;\n      RecVolumesTest(Cmd,NULL,ArcName);\n      TotalFileCount++; // Suppress \"No files to extract\" message.\n      return EXTRACT_ARC_NEXT;\n    }\n#endif\n\n#ifndef GUI\n    mprintf(St(MNotRAR),ArcName);\n#endif\n\n#ifndef SFX_MODULE\n    if (CmpExt(ArcName,L\"rar\"))\n#endif\n      ErrHandler.SetErrorCode(RARX_WARNING);\n    return EXTRACT_ARC_NEXT;\n  }\n\n  if (Arc.FailedHeaderDecryption) // Bad archive password.\n    return EXTRACT_ARC_NEXT;\n\n#ifndef SFX_MODULE\n  if (Arc.Volume && !Arc.FirstVolume)\n  {\n    wchar FirstVolName[NM];\n    VolNameToFirstName(ArcName,FirstVolName,ASIZE(FirstVolName),Arc.NewNumbering);\n\n    // If several volume names from same volume set are specified\n    // and current volume is not first in set and first volume is present\n    // and specified too, let's skip the current volume.\n    if (wcsicomp(ArcName,FirstVolName)!=0 && FileExist(FirstVolName) &&\n        Cmd->ArcNames.Search(FirstVolName,false))\n      return EXTRACT_ARC_NEXT;\n  }\n#endif\n\n  int64 VolumeSetSize=0; // Total size of volumes after the current volume.\n\n  if (Arc.Volume)\n  {\n    // Calculate the total size of all accessible volumes.\n    // This size is necessary to display the correct total progress indicator.\n\n    wchar NextName[NM];\n    wcscpy(NextName,Arc.FileName);\n\n    while (true)\n    {\n      // First volume is already added to DataIO.TotalArcSize \n      // in initial TotalArcSize calculation in DoExtract.\n      // So we skip it and start from second volume.\n      NextVolumeName(NextName,ASIZE(NextName),!Arc.NewNumbering);\n      FindData FD;\n      if (FindFile::FastFind(NextName,&FD))\n        VolumeSetSize+=FD.Size;\n      else\n        break;\n    }\n    DataIO.TotalArcSize+=VolumeSetSize;\n  }\n\n  ExtractArchiveInit(Arc);\n\n  if (*Cmd->Command=='T' || *Cmd->Command=='I')\n    Cmd->Test=true;\n\n\n  if (*Cmd->Command=='I')\n  {\n#ifndef GUI   \n    Cmd->DisablePercentage=true;\n#endif\n  }\n  else\n    uiStartArchiveExtract(!Cmd->Test,ArcName);\n\n  Arc.ViewComment();\n\n\n  while (1)\n  {\n    size_t Size=Arc.ReadHeader();\n\n\n    bool Repeat=false;\n    if (!ExtractCurrentFile(Arc,Size,Repeat))\n      if (Repeat)\n      {\n        // If we started extraction from not first volume and need to\n        // restart it from first, we must correct DataIO.TotalArcSize\n        // for correct total progress display. We subtract the size\n        // of current volume and all volumes after it and add the size\n        // of new (first) volume.\n        FindData OldArc,NewArc;\n        if (FindFile::FastFind(Arc.FileName,&OldArc) &&\n            FindFile::FastFind(ArcName,&NewArc))\n          DataIO.TotalArcSize-=VolumeSetSize+OldArc.Size-NewArc.Size;\n        return EXTRACT_ARC_REPEAT;\n      }\n      else\n        break;\n  }\n\n\n#if !defined(SFX_MODULE) && !defined(RARDLL)\n  if (Cmd->Test && Arc.Volume)\n    RecVolumesTest(Cmd,&Arc,ArcName);\n#endif\n\n  return EXTRACT_ARC_NEXT;\n}\n\n\nbool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)\n{\n  // We can get negative sizes in corrupt archive and it is unacceptable\n  // for size comparisons in CmdExtract::UnstoreFile and ComprDataIO::UnpRead,\n  // where we cast sizes to size_t and can exceed another read or available\n  // size. We could fix it when reading an archive. But we prefer to do it\n  // here, because this function is called directly in unrar.dll, so we fix\n  // bad parameters passed to dll. Also we want to see real negative sizes\n  // in the listing of corrupt archive.\n  if (Arc.FileHead.PackSize<0)\n    Arc.FileHead.PackSize=0;\n  if (Arc.FileHead.UnpSize<0)\n    Arc.FileHead.UnpSize=0;\n\n  wchar Command=Cmd->Command[0];\n  if (HeaderSize==0)\n    if (DataIO.UnpVolume)\n    {\n#ifdef NOVOLUME\n      return false;\n#else\n      // Supposing we unpack an old RAR volume without end of archive record\n      // and last file is not split between volumes.\n      if (!MergeArchive(Arc,&DataIO,false,Command))\n      {\n        ErrHandler.SetErrorCode(RARX_WARNING);\n        return false;\n      }\n#endif\n    }\n    else\n      return false;\n  HEADER_TYPE HeaderType=Arc.GetHeaderType();\n  if (HeaderType!=HEAD_FILE)\n  {\n#ifndef SFX_MODULE\n    if (HeaderType==HEAD3_OLDSERVICE && PrevProcessed)\n      SetExtraInfo20(Cmd,Arc,DestFileName);\n#endif\n    if (HeaderType==HEAD_SERVICE && PrevProcessed)\n      SetExtraInfo(Cmd,Arc,DestFileName);\n    if (HeaderType==HEAD_ENDARC)\n      if (Arc.EndArcHead.NextVolume)\n      {\n#ifndef NOVOLUME\n        if (!MergeArchive(Arc,&DataIO,false,Command))\n        {\n          ErrHandler.SetErrorCode(RARX_WARNING);\n          return false;\n        }\n#endif\n        Arc.Seek(Arc.CurBlockPos,SEEK_SET);\n        return true;\n      }\n      else\n        return false;\n    Arc.SeekToNext();\n    return true;\n  }\n  PrevProcessed=false;\n\n  if (!Cmd->Recurse && MatchedArgs>=Cmd->FileArgs.ItemsCount() && AllMatchesExact)\n    return false;\n\n  int MatchType=MATCH_WILDSUBPATH;\n\n  bool EqualNames=false;\n  wchar MatchedArg[NM];\n  int MatchNumber=Cmd->IsProcessFile(Arc.FileHead,&EqualNames,MatchType,MatchedArg,ASIZE(MatchedArg));\n  bool MatchFound=MatchNumber!=0;\n#ifndef SFX_MODULE\n  if (Cmd->ExclPath==EXCL_BASEPATH)\n  {\n    wcsncpyz(Cmd->ArcPath,MatchedArg,ASIZE(Cmd->ArcPath));\n    *PointToName(Cmd->ArcPath)=0;\n    if (IsWildcard(Cmd->ArcPath)) // Cannot correctly process path*\\* masks here.\n      *Cmd->ArcPath=0;\n  }\n#endif\n  if (MatchFound && !EqualNames)\n    AllMatchesExact=false;\n\n  Arc.ConvertAttributes();\n\n#if !defined(SFX_MODULE) && !defined(RARDLL)\n  if (Arc.FileHead.SplitBefore && FirstFile)\n  {\n    wchar CurVolName[NM];\n    wcsncpyz(CurVolName,ArcName,ASIZE(CurVolName));\n    VolNameToFirstName(ArcName,ArcName,ASIZE(ArcName),Arc.NewNumbering);\n\n    if (wcsicomp(ArcName,CurVolName)!=0 && FileExist(ArcName))\n    {\n      // If first volume name does not match the current name and if such\n      // volume name really exists, let's unpack from this first volume.\n      Repeat=true;\n      return false;\n    }\n#ifndef RARDLL\n    if (!ReconstructDone)\n    {\n      ReconstructDone=true;\n      if (RecVolumesRestore(Cmd,Arc.FileName,true))\n      {\n        Repeat=true;\n        return false;\n      }\n    }\n#endif\n    wcsncpyz(ArcName,CurVolName,ASIZE(ArcName));\n  }\n#endif\n\n  wchar ArcFileName[NM];\n  ConvertPath(Arc.FileHead.FileName,ArcFileName);\n#ifdef _WIN_ALL\n  if (!Cmd->AllowIncompatNames)\n    MakeNameCompatible(ArcFileName);\n#endif\n\n  if (Arc.FileHead.Version)\n  {\n    if (Cmd->VersionControl!=1 && !EqualNames)\n    {\n      if (Cmd->VersionControl==0)\n        MatchFound=false;\n      int Version=ParseVersionFileName(ArcFileName,false);\n      if (Cmd->VersionControl-1==Version)\n        ParseVersionFileName(ArcFileName,true);\n      else\n        MatchFound=false;\n    }\n  }\n  else\n    if (!Arc.IsArcDir() && Cmd->VersionControl>1)\n      MatchFound=false;\n\n  DataIO.UnpVolume=Arc.FileHead.SplitAfter;\n  DataIO.NextVolumeMissing=false;\n\n  Arc.Seek(Arc.NextBlockPos-Arc.FileHead.PackSize,SEEK_SET);\n\n  bool ExtrFile=false;\n  bool SkipSolid=false;\n\n#ifndef SFX_MODULE\n  if (FirstFile && (MatchFound || Arc.Solid) && Arc.FileHead.SplitBefore)\n  {\n    if (MatchFound)\n    {\n      uiMsg(UIERROR_NEEDPREVVOL,Arc.FileName,ArcFileName);\n#ifdef RARDLL\n      Cmd->DllError=ERAR_BAD_DATA;\n#endif\n      ErrHandler.SetErrorCode(RARX_OPEN);\n    }\n    MatchFound=false;\n  }\n\n  FirstFile=false;\n#endif\n\n  if (MatchFound || (SkipSolid=Arc.Solid)!=0)\n  {\n    // First common call of uiStartFileExtract. It is done before overwrite\n    // prompts, so if SkipSolid state is changed below, we'll need to make\n    // additional uiStartFileExtract calls with updated parameters.\n    if (!uiStartFileExtract(ArcFileName,!Cmd->Test,Cmd->Test && Command!='I',SkipSolid))\n      return false;\n\n    ExtrPrepareName(Arc,ArcFileName,DestFileName,ASIZE(DestFileName));\n\n    // DestFileName can be set empty in case of excessive -ap switch.\n    ExtrFile=!SkipSolid && *DestFileName!=0 && !Arc.FileHead.SplitBefore;\n\n    if ((Cmd->FreshFiles || Cmd->UpdateFiles) && (Command=='E' || Command=='X'))\n    {\n      FindData FD;\n      if (FindFile::FastFind(DestFileName,&FD))\n      {\n        if (FD.mtime >= Arc.FileHead.mtime)\n        {\n          // If directory already exists and its modification time is newer \n          // than start of extraction, it is likely it was created \n          // when creating a path to one of already extracted items. \n          // In such case we'll better update its time even if archived \n          // directory is older.\n\n          if (!FD.IsDir || FD.mtime<StartTime)\n            ExtrFile=false;\n        }\n      }\n      else\n        if (Cmd->FreshFiles)\n          ExtrFile=false;\n    }\n\n    if (Arc.FileHead.Encrypted)\n    {\n      // Stop archive extracting if user cancelled a password prompt.\n#ifdef RARDLL\n      if (!ExtrDllGetPassword())\n      {\n        Cmd->DllError=ERAR_MISSING_PASSWORD;\n        return false;\n      }\n#else\n      if (!ExtrGetPassword(Arc,ArcFileName))\n      {\n        PasswordCancelled=true;\n        return false;\n      }\n#endif\n      // Skip only the current encrypted file if empty password is entered.\n      // Actually our \"cancel\" code above intercepts empty passwords too now,\n      // so we keep the code below just in case we'll decide process empty\n      // and cancelled passwords differently sometimes.\n      if (!Cmd->Password.IsSet())\n      {\n        ErrHandler.SetErrorCode(RARX_WARNING);\n#ifdef RARDLL\n        Cmd->DllError=ERAR_MISSING_PASSWORD;\n#endif\n        ExtrFile=false;\n      }\n    }\n\n#ifdef RARDLL\n    if (*Cmd->DllDestName!=0)\n      wcsncpyz(DestFileName,Cmd->DllDestName,ASIZE(DestFileName));\n#endif\n\n    if (!CheckUnpVer(Arc,ArcFileName))\n    {\n      ErrHandler.SetErrorCode(RARX_FATAL);\n#ifdef RARDLL\n      Cmd->DllError=ERAR_UNKNOWN_FORMAT;\n#endif\n      Arc.SeekToNext();\n      return !Arc.Solid; // Can try extracting next file only in non-solid archive.\n    }\n\n\n    // Set a password before creating the file, so we can skip creating\n    // in case of wrong password.\n    SecPassword FilePassword=Cmd->Password;\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n    ConvertDosPassword(Arc,FilePassword);\n#endif\n\n    byte PswCheck[SIZE_PSWCHECK];\n    DataIO.SetEncryption(false,Arc.FileHead.CryptMethod,&FilePassword,\n           Arc.FileHead.SaltSet ? Arc.FileHead.Salt:NULL,\n           Arc.FileHead.InitV,Arc.FileHead.Lg2Count,\n           Arc.FileHead.HashKey,PswCheck);\n\n    // If header is damaged, we cannot rely on password check value,\n    // because it can be damaged too.\n    if (Arc.FileHead.Encrypted && Arc.FileHead.UsePswCheck &&\n        memcmp(Arc.FileHead.PswCheck,PswCheck,SIZE_PSWCHECK)!=0 &&\n        !Arc.BrokenHeader)\n    {\n      uiMsg(UIERROR_BADPSW,Arc.FileName);\n      ErrHandler.SetErrorCode(RARX_BADPWD);\n      ExtrFile=false;\n#ifdef RARDLL\n      // If we already have ERAR_EOPEN as result of missing volume,\n      // we should not replace it with less precise ERAR_BAD_DATA.\n      if (Cmd->DllError!=ERAR_EOPEN)\n        Cmd->DllError=ERAR_BAD_PASSWORD;\n#endif\n    }\n\n    File CurFile;\n\n    bool LinkEntry=Arc.FileHead.RedirType!=FSREDIR_NONE;\n    if (LinkEntry && Arc.FileHead.RedirType!=FSREDIR_FILECOPY)\n    {\n      if (ExtrFile && Command!='P' && !Cmd->Test)\n      {\n        // Overwrite prompt for symbolic and hard links.\n        bool UserReject=false;\n        if (FileExist(DestFileName) && !UserReject)\n          FileCreate(Cmd,NULL,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime);\n        if (UserReject)\n          ExtrFile=false;\n      }\n    }\n    else\n      if (Arc.IsArcDir())\n      {\n        if (!ExtrFile || Command=='P' || Command=='I' || Command=='E' || Cmd->ExclPath==EXCL_SKIPWHOLEPATH)\n          return true;\n        TotalFileCount++;\n        ExtrCreateDir(Arc,ArcFileName);\n        return true;\n      }\n      else\n        if (ExtrFile) // Create files and file copies (FSREDIR_FILECOPY).\n          ExtrFile=ExtrCreateFile(Arc,CurFile);\n\n    if (!ExtrFile && Arc.Solid)\n    {\n      SkipSolid=true;\n      ExtrFile=true;\n\n      // We changed SkipSolid, so we need to call uiStartFileExtract\n      // with \"Skip\" parameter to change the operation status \n      // from \"extracting\" to \"skipping\". For example, it can be necessary\n      // if user answered \"No\" to overwrite prompt when unpacking\n      // a solid archive.\n      if (!uiStartFileExtract(ArcFileName,false,false,true))\n        return false;\n    }\n    if (ExtrFile)\n    {\n      // Set it in test mode, so we also test subheaders such as NTFS streams\n      // after tested file.\n      if (Cmd->Test)\n        PrevProcessed=true;\n\n      bool TestMode=Cmd->Test || SkipSolid; // Unpack to memory, not to disk.\n\n      if (!SkipSolid)\n      {\n        if (!TestMode && Command!='P' && CurFile.IsDevice())\n        {\n          uiMsg(UIERROR_INVALIDNAME,Arc.FileName,DestFileName);\n          ErrHandler.WriteError(Arc.FileName,DestFileName);\n        }\n        TotalFileCount++;\n      }\n      FileCount++;\n#ifndef GUI\n      if (Command!='I')\n        if (SkipSolid)\n          mprintf(St(MExtrSkipFile),ArcFileName);\n        else\n          switch(Cmd->Test ? 'T':Command) // \"Test\" can be also enabled by -t switch.\n          {\n            case 'T':\n              mprintf(St(MExtrTestFile),ArcFileName);\n              break;\n#ifndef SFX_MODULE\n            case 'P':\n              mprintf(St(MExtrPrinting),ArcFileName);\n              break;\n#endif\n            case 'X':\n            case 'E':\n              mprintf(St(MExtrFile),DestFileName);\n              break;\n          }\n      if (!Cmd->DisablePercentage)\n        mprintf(L\"     \");\n#endif\n\n      DataIO.CurUnpRead=0;\n      DataIO.CurUnpWrite=0;\n      DataIO.UnpHash.Init(Arc.FileHead.FileHash.Type,Cmd->Threads);\n      DataIO.PackedDataHash.Init(Arc.FileHead.FileHash.Type,Cmd->Threads);\n      DataIO.SetPackedSizeToRead(Arc.FileHead.PackSize);\n      DataIO.SetFiles(&Arc,&CurFile);\n      DataIO.SetTestMode(TestMode);\n      DataIO.SetSkipUnpCRC(SkipSolid);\n\n#if defined(_WIN_ALL) && !defined(SFX_MODULE) && !defined(SILENT)\n      if (!TestMode && !Arc.BrokenHeader &&\n          Arc.FileHead.UnpSize>0xffffffff && (Fat32 || !NotFat32))\n      {\n        if (!Fat32) // Not detected yet.\n          NotFat32=!(Fat32=IsFAT(Cmd->ExtrPath));\n        if (Fat32)\n          uiMsg(UIMSG_FAT32SIZE); // Inform user about FAT32 size limit.\n      }\n#endif\n\n      if (!TestMode && !Arc.BrokenHeader &&\n          (Arc.FileHead.PackSize<<11)>Arc.FileHead.UnpSize &&\n          (Arc.FileHead.UnpSize<100000000 || Arc.FileLength()>Arc.FileHead.PackSize))\n        CurFile.Prealloc(Arc.FileHead.UnpSize);\n\n      CurFile.SetAllowDelete(!Cmd->KeepBroken);\n\n      bool FileCreateMode=!TestMode && !SkipSolid && Command!='P';\n      bool ShowChecksum=true; // Display checksum verification result.\n\n      bool LinkSuccess=true; // Assume success for test mode.\n      if (LinkEntry)\n      {\n        FILE_SYSTEM_REDIRECT Type=Arc.FileHead.RedirType;\n\n        if (Type==FSREDIR_HARDLINK || Type==FSREDIR_FILECOPY)\n        {\n          wchar NameExisting[NM];\n          ExtrPrepareName(Arc,Arc.FileHead.RedirName,NameExisting,ASIZE(NameExisting));\n          if (FileCreateMode && *NameExisting!=0) // *NameExisting can be 0 in case of excessive -ap switch.\n            if (Type==FSREDIR_HARDLINK)\n              LinkSuccess=ExtractHardlink(DestFileName,NameExisting,ASIZE(NameExisting));\n            else\n              LinkSuccess=ExtractFileCopy(CurFile,Arc.FileName,DestFileName,NameExisting,ASIZE(NameExisting));\n        }\n        else\n          if (Type==FSREDIR_UNIXSYMLINK || Type==FSREDIR_WINSYMLINK || Type==FSREDIR_JUNCTION)\n          {\n            if (FileCreateMode)\n              LinkSuccess=ExtractSymlink(Cmd,DataIO,Arc,DestFileName);\n          }\n          else\n          {\n            uiMsg(UIERROR_UNKNOWNEXTRA, Arc.FileName, DestFileName);\n            LinkSuccess=false;\n          }\n          \n          if (!LinkSuccess || Arc.Format==RARFMT15 && !FileCreateMode)\n          {\n            // RAR 5.x links have a valid data checksum even in case of\n            // failure, because they do not store any data.\n            // We do not want to display \"OK\" in this case.\n            // For 4.x symlinks we verify the checksum only when extracting,\n            // but not when testing an archive.\n            ShowChecksum=false;\n          }\n          PrevProcessed=FileCreateMode && LinkSuccess;\n      }\n      else\n        if (!Arc.FileHead.SplitBefore)\n          if (Arc.FileHead.Method==0)\n            UnstoreFile(DataIO,Arc.FileHead.UnpSize);\n          else\n          {\n#ifdef _ANDROID\n            // malloc and new do not report memory allocation errors\n            // in Android, so if free memory is set, check it here\n            // trying to prevent crash.\n            if (Cmd->FreeMem!=0 && Cmd->FreeMem < Arc.FileHead.WinSize)\n              throw std::bad_alloc();\n#endif\n            Unp->Init(Arc.FileHead.WinSize,Arc.FileHead.Solid);\n            Unp->SetDestSize(Arc.FileHead.UnpSize);\n#ifndef SFX_MODULE\n            if (Arc.Format!=RARFMT50 && Arc.FileHead.UnpVer<=15)\n              Unp->DoUnpack(15,FileCount>1 && Arc.Solid);\n            else\n#endif\n              Unp->DoUnpack(Arc.FileHead.UnpVer,Arc.FileHead.Solid);\n          }\n\n      Arc.SeekToNext();\n\n      // We check for \"split after\" flag to detect partially extracted files\n      // from incomplete volume sets. For them file header contains packed\n      // data hash, which must not be compared against unpacked data hash\n      // to prevent accidental match. Moreover, for -m0 volumes packed data\n      // hash would match truncated unpacked data hash and lead to fake \"OK\"\n      // in incomplete volume set.\n      bool ValidCRC=!Arc.FileHead.SplitAfter && DataIO.UnpHash.Cmp(&Arc.FileHead.FileHash,Arc.FileHead.UseHashKey ? Arc.FileHead.HashKey:NULL);\n\n      // We set AnySolidDataUnpackedWell to true if we found at least one\n      // valid non-zero solid file in preceding solid stream. If it is true\n      // and if current encrypted file is broken, we do not need to hint\n      // about a wrong password and can report CRC error only.\n      if (!Arc.FileHead.Solid)\n        AnySolidDataUnpackedWell=false; // Reset the flag, because non-solid file is found.\n      else\n        if (Arc.FileHead.Method!=0 && Arc.FileHead.UnpSize>0 && ValidCRC)\n          AnySolidDataUnpackedWell=true;\n \n      bool BrokenFile=false;\n      \n      // Checksum is not calculated in skip solid mode for performance reason.\n      if (!SkipSolid && ShowChecksum)\n      {\n        if (ValidCRC)\n        {\n#ifndef GUI\n          if (Command!='P' && Command!='I')\n            mprintf(L\"%s%s \",Cmd->DisablePercentage ? L\" \":L\"\\b\\b\\b\\b\\b \",\n              Arc.FileHead.FileHash.Type==HASH_NONE ? L\"  ?\":St(MOk));\n#endif\n        }\n        else\n        {\n          if (Arc.FileHead.Encrypted && (!Arc.FileHead.UsePswCheck || \n              Arc.BrokenHeader) && !AnySolidDataUnpackedWell)\n            uiMsg(UIERROR_CHECKSUMENC,Arc.FileName,ArcFileName);\n          else\n            uiMsg(UIERROR_CHECKSUM,Arc.FileName,ArcFileName);\n          BrokenFile=true;\n          ErrHandler.SetErrorCode(RARX_CRC);\n#ifdef RARDLL\n          // If we already have ERAR_EOPEN as result of missing volume\n          // or ERAR_BAD_PASSWORD for RAR5 wrong password,\n          // we should not replace it with less precise ERAR_BAD_DATA.\n          if (Cmd->DllError!=ERAR_EOPEN && Cmd->DllError!=ERAR_BAD_PASSWORD)\n            Cmd->DllError=ERAR_BAD_DATA;\n#endif\n        }\n      }\n#ifndef GUI\n      else\n        mprintf(L\"\\b\\b\\b\\b\\b     \");\n#endif\n\n      if (!TestMode && (Command=='X' || Command=='E') &&\n          (!LinkEntry || Arc.FileHead.RedirType==FSREDIR_FILECOPY && LinkSuccess) && \n          (!BrokenFile || Cmd->KeepBroken))\n      {\n        // We could preallocate more space that really written to broken file.\n        if (BrokenFile)\n          CurFile.Truncate();\n\n#if defined(_WIN_ALL) || defined(_EMX)\n        if (Cmd->ClearArc)\n          Arc.FileHead.FileAttr&=~FILE_ATTRIBUTE_ARCHIVE;\n#endif\n\n\n        CurFile.SetOpenFileTime(\n          Cmd->xmtime==EXTTIME_NONE ? NULL:&Arc.FileHead.mtime,\n          Cmd->xctime==EXTTIME_NONE ? NULL:&Arc.FileHead.ctime,\n          Cmd->xatime==EXTTIME_NONE ? NULL:&Arc.FileHead.atime);\n        CurFile.Close();\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n        if (Cmd->SetCompressedAttr &&\n            (Arc.FileHead.FileAttr & FILE_ATTRIBUTE_COMPRESSED)!=0)\n          SetFileCompression(CurFile.FileName,true);\n#endif\n#ifdef _UNIX\n        if (Cmd->ProcessOwners && Arc.Format==RARFMT50 && Arc.FileHead.UnixOwnerSet)\n          SetUnixOwner(Arc,CurFile.FileName);\n#endif\n\n        CurFile.SetCloseFileTime(\n          Cmd->xmtime==EXTTIME_NONE ? NULL:&Arc.FileHead.mtime,\n          Cmd->xatime==EXTTIME_NONE ? NULL:&Arc.FileHead.atime);\n        if (!Cmd->IgnoreGeneralAttr && !SetFileAttr(CurFile.FileName,Arc.FileHead.FileAttr))\n          uiMsg(UIERROR_FILEATTR,Arc.FileName,CurFile.FileName);\n\n        PrevProcessed=true;\n      }\n    }\n  }\n  if (MatchFound)\n    MatchedArgs++;\n  if (DataIO.NextVolumeMissing)\n    return false;\n  if (!ExtrFile)\n    if (!Arc.Solid)\n      Arc.SeekToNext();\n    else\n      if (!SkipSolid)\n        return false;\n  return true;\n}\n\n\nvoid CmdExtract::UnstoreFile(ComprDataIO &DataIO,int64 DestUnpSize)\n{\n  // 512 KB and larger buffer reported to reduce performance on old XP\n  // computers with WDC WD2000JD HDD. According to test made by user\n  // 256 KB buffer is optimal.\n  Array<byte> Buffer(0x40000);\n  while (1)\n  {\n    uint Code=DataIO.UnpRead(&Buffer[0],Buffer.Size());\n    if (Code==0 || (int)Code==-1)\n      break;\n    Code=Code<DestUnpSize ? Code:(uint)DestUnpSize;\n    DataIO.UnpWrite(&Buffer[0],Code);\n    if (DestUnpSize>=0)\n      DestUnpSize-=Code;\n  }\n}\n\n\nbool CmdExtract::ExtractFileCopy(File &New,wchar *ArcName,wchar *NameNew,wchar *NameExisting,size_t NameExistingSize)\n{\n  SlashToNative(NameExisting,NameExisting,NameExistingSize); // Not needed for RAR 5.1+ archives.\n\n  File Existing;\n  if (!Existing.WOpen(NameExisting))\n  {\n    uiMsg(UIERROR_FILECOPY,ArcName,NameExisting,NameNew);\n    uiMsg(UIERROR_FILECOPYHINT,ArcName);\n#ifdef RARDLL\n    Cmd->DllError=ERAR_EREFERENCE;\n#endif\n    return false;\n  }\n\n  Array<char> Buffer(0x100000);\n  int64 CopySize=0;\n\n  while (true)\n  {\n    Wait();\n    int ReadSize=Existing.Read(&Buffer[0],Buffer.Size());\n    if (ReadSize==0)\n      break;\n    New.Write(&Buffer[0],ReadSize);\n    CopySize+=ReadSize;\n  }\n\n  return true;\n}\n\n\nvoid CmdExtract::ExtrPrepareName(Archive &Arc,const wchar *ArcFileName,wchar *DestName,size_t DestSize)\n{\n  wcsncpyz(DestName,Cmd->ExtrPath,DestSize);\n\n  if (*Cmd->ExtrPath!=0)\n  {\n     wchar LastChar=*PointToLastChar(Cmd->ExtrPath);\n    // We need IsPathDiv check here to correctly handle Unix forward slash\n    // in the end of destination path in Windows: rar x arc dest/\n    // IsDriveDiv is needed for current drive dir: rar x arc d:\n    if (!IsPathDiv(LastChar) && !IsDriveDiv(LastChar))\n    {\n      // Destination path can be without trailing slash if it come from GUI shell.\n      AddEndSlash(DestName,DestSize);\n    }\n  }\n\n#ifndef SFX_MODULE\n  if (Cmd->AppendArcNameToPath)\n  {\n    wcsncatz(DestName,PointToName(Arc.FirstVolumeName),DestSize);\n    SetExt(DestName,NULL,DestSize);\n    AddEndSlash(DestName,DestSize);\n  }\n#endif\n\n#ifndef SFX_MODULE\n  size_t ArcPathLength=wcslen(Cmd->ArcPath);\n  if (ArcPathLength>0)\n  {\n    size_t NameLength=wcslen(ArcFileName);\n    ArcFileName+=Min(ArcPathLength,NameLength);\n    while (*ArcFileName==CPATHDIVIDER)\n      ArcFileName++;\n    if (*ArcFileName==0) // Excessive -ap switch.\n    {\n      *DestName=0;\n      return;\n    }\n  }\n#endif\n\n  wchar Command=Cmd->Command[0];\n  // Use -ep3 only in systems, where disk letters are exist, not in Unix.\n  bool AbsPaths=Cmd->ExclPath==EXCL_ABSPATH && Command=='X' && IsDriveDiv(':');\n\n  // We do not use any user specified destination paths when extracting\n  // absolute paths in -ep3 mode.\n  if (AbsPaths)\n    *DestName=0;\n\n  if (Command=='E' || Cmd->ExclPath==EXCL_SKIPWHOLEPATH)\n    wcsncatz(DestName,PointToName(ArcFileName),DestSize);\n  else\n    wcsncatz(DestName,ArcFileName,DestSize);\n\n  wchar DiskLetter=toupperw(DestName[0]);\n\n  if (AbsPaths)\n  {\n    if (DestName[1]=='_' && IsPathDiv(DestName[2]) &&\n        DiskLetter>='A' && DiskLetter<='Z')\n      DestName[1]=':';\n    else\n      if (DestName[0]=='_' && DestName[1]=='_')\n      {\n        // Convert __server\\share to \\\\server\\share.\n        DestName[0]=CPATHDIVIDER;\n        DestName[1]=CPATHDIVIDER;\n      }\n  }\n}\n\n\n#ifdef RARDLL\nbool CmdExtract::ExtrDllGetPassword()\n{\n  if (!Cmd->Password.IsSet())\n  {\n    if (Cmd->Callback!=NULL)\n    {\n      wchar PasswordW[MAXPASSWORD];\n      *PasswordW=0;\n      if (Cmd->Callback(UCM_NEEDPASSWORDW,Cmd->UserData,(LPARAM)PasswordW,ASIZE(PasswordW))==-1)\n        *PasswordW=0;\n      if (*PasswordW==0)\n      {\n        char PasswordA[MAXPASSWORD];\n        *PasswordA=0;\n        if (Cmd->Callback(UCM_NEEDPASSWORD,Cmd->UserData,(LPARAM)PasswordA,ASIZE(PasswordA))==-1)\n          *PasswordA=0;\n        GetWideName(PasswordA,NULL,PasswordW,ASIZE(PasswordW));\n        cleandata(PasswordA,sizeof(PasswordA));\n      }\n      Cmd->Password.Set(PasswordW);\n      cleandata(PasswordW,sizeof(PasswordW));\n      Cmd->ManualPassword=true;\n    }\n    if (!Cmd->Password.IsSet())\n      return false;\n  }\n  return true;\n}\n#endif\n\n\n#ifndef RARDLL\nbool CmdExtract::ExtrGetPassword(Archive &Arc,const wchar *ArcFileName)\n{\n  if (!Cmd->Password.IsSet())\n  {\n    if (!uiGetPassword(UIPASSWORD_FILE,ArcFileName,&Cmd->Password) || !Cmd->Password.IsSet())\n    {\n      // Suppress \"test is ok\" message in GUI if user entered\n      // an empty password or cancelled a password prompt.\n      uiMsg(UIERROR_INCERRCOUNT);\n\n      return false;\n    }\n    Cmd->ManualPassword=true;\n  }\n#if !defined(GUI) && !defined(SILENT)\n  else\n    if (!PasswordAll && !Arc.FileHead.Solid)\n    {\n      eprintf(St(MUseCurPsw),ArcFileName);\n      switch(Cmd->AllYes ? 1 : Ask(St(MYesNoAll)))\n      {\n        case -1:\n          ErrHandler.Exit(RARX_USERBREAK);\n        case 2:\n          if (!uiGetPassword(UIPASSWORD_FILE,ArcFileName,&Cmd->Password))\n            return false;\n          break;\n        case 3:\n          PasswordAll=true;\n          break;\n      }\n    }\n#endif\n  return true;\n}\n#endif\n\n\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\nvoid CmdExtract::ConvertDosPassword(Archive &Arc,SecPassword &DestPwd)\n{\n  if (Arc.Format==RARFMT15 && Arc.FileHead.HostOS==HOST_MSDOS)\n  {\n    // We need the password in OEM encoding if file was encrypted by\n    // native RAR/DOS (not extender based). Let's make the conversion.\n    wchar PlainPsw[MAXPASSWORD];\n    Cmd->Password.Get(PlainPsw,ASIZE(PlainPsw));\n    char PswA[MAXPASSWORD];\n    CharToOemBuffW(PlainPsw,PswA,ASIZE(PswA));\n    PswA[ASIZE(PswA)-1]=0;\n    CharToWide(PswA,PlainPsw,ASIZE(PlainPsw));\n    DestPwd.Set(PlainPsw);\n    cleandata(PlainPsw,sizeof(PlainPsw));\n    cleandata(PswA,sizeof(PswA));\n  }\n}\n#endif\n\n\nvoid CmdExtract::ExtrCreateDir(Archive &Arc,const wchar *ArcFileName)\n{\n  if (Cmd->Test)\n  {\n#ifndef GUI\n    mprintf(St(MExtrTestFile),ArcFileName);\n    mprintf(L\" %s\",St(MOk));\n#endif\n    return;\n  }\n\n  MKDIR_CODE MDCode=MakeDir(DestFileName,!Cmd->IgnoreGeneralAttr,Arc.FileHead.FileAttr);\n  bool DirExist=false;\n  if (MDCode!=MKDIR_SUCCESS)\n  {\n    DirExist=FileExist(DestFileName);\n    if (DirExist && !IsDir(GetFileAttr(DestFileName)))\n    {\n      // File with name same as this directory exists. Propose user\n      // to overwrite it.\n      bool UserReject;\n      FileCreate(Cmd,NULL,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime);\n      DirExist=false;\n    }\n    if (!DirExist)\n    {\n      CreatePath(DestFileName,true);\n      MDCode=MakeDir(DestFileName,!Cmd->IgnoreGeneralAttr,Arc.FileHead.FileAttr);\n      if (MDCode!=MKDIR_SUCCESS)\n      {\n        wchar OrigName[ASIZE(DestFileName)];\n        wcsncpyz(OrigName,DestFileName,ASIZE(OrigName));\n        MakeNameUsable(DestFileName,true);\n        CreatePath(DestFileName,true);\n        MDCode=MakeDir(DestFileName,!Cmd->IgnoreGeneralAttr,Arc.FileHead.FileAttr);\n#ifndef SFX_MODULE\n        if (MDCode==MKDIR_SUCCESS)\n          uiMsg(UIERROR_RENAMING,Arc.FileName,OrigName,DestFileName);\n#endif\n      }\n    }\n  }\n  if (MDCode==MKDIR_SUCCESS)\n  {\n#ifndef GUI\n    mprintf(St(MCreatDir),DestFileName);\n    mprintf(L\" %s\",St(MOk));\n#endif\n    PrevProcessed=true;\n  }\n  else\n    if (DirExist)\n    {\n      if (!Cmd->IgnoreGeneralAttr)\n        SetFileAttr(DestFileName,Arc.FileHead.FileAttr);\n      PrevProcessed=true;\n    }\n    else\n    {\n      uiMsg(UIERROR_DIRCREATE,Arc.FileName,DestFileName);\n      ErrHandler.SysErrMsg();\n#ifdef RARDLL\n      Cmd->DllError=ERAR_ECREATE;\n#endif\n      ErrHandler.SetErrorCode(RARX_CREATE);\n    }\n  if (PrevProcessed)\n  {\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n    if (Cmd->SetCompressedAttr &&\n        (Arc.FileHead.FileAttr & FILE_ATTRIBUTE_COMPRESSED)!=0 && WinNT())\n      SetFileCompression(DestFileName,true);\n#endif\n    SetDirTime(DestFileName,\n      Cmd->xmtime==EXTTIME_NONE ? NULL:&Arc.FileHead.mtime,\n      Cmd->xctime==EXTTIME_NONE ? NULL:&Arc.FileHead.ctime,\n      Cmd->xatime==EXTTIME_NONE ? NULL:&Arc.FileHead.atime);\n  }\n}\n\n\nbool CmdExtract::ExtrCreateFile(Archive &Arc,File &CurFile)\n{\n  bool Success=true;\n  wchar Command=Cmd->Command[0];\n#if !defined(GUI) && !defined(SFX_MODULE)\n  if (Command=='P')\n    CurFile.SetHandleType(FILE_HANDLESTD);\n#endif\n  if ((Command=='E' || Command=='X') && !Cmd->Test)\n  {\n    bool UserReject;\n    // Specify \"write only\" mode to avoid OpenIndiana NAS problems\n    // with SetFileTime and read+write files.\n    if (!FileCreate(Cmd,&CurFile,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime,true))\n    {\n      Success=false;\n      if (!UserReject)\n      {\n        ErrHandler.CreateErrorMsg(Arc.FileName,DestFileName);\n#ifdef RARDLL\n        Cmd->DllError=ERAR_ECREATE;\n#endif\n        if (!IsNameUsable(DestFileName))\n        {\n          uiMsg(UIMSG_CORRECTINGNAME,Arc.FileName);\n\n          wchar OrigName[ASIZE(DestFileName)];\n          wcsncpyz(OrigName,DestFileName,ASIZE(OrigName));\n\n          MakeNameUsable(DestFileName,true);\n\n          CreatePath(DestFileName,true);\n          if (FileCreate(Cmd,&CurFile,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime,true))\n          {\n#ifndef SFX_MODULE\n            uiMsg(UIERROR_RENAMING,Arc.FileName,OrigName,DestFileName);\n#endif\n            Success=true;\n          }\n          else\n            ErrHandler.CreateErrorMsg(Arc.FileName,DestFileName);\n        }\n      }\n    }\n  }\n  return Success;\n}\n\n\nbool CmdExtract::CheckUnpVer(Archive &Arc,const wchar *ArcFileName)\n{\n  bool WrongVer;\n  if (Arc.Format==RARFMT50) // Both SFX and RAR can unpack RAR 5.0 archives.\n    WrongVer=Arc.FileHead.UnpVer>VER_UNPACK5;\n  else\n  {\n#ifdef SFX_MODULE   // SFX can unpack only RAR 2.9 archives.\n    WrongVer=Arc.FileHead.UnpVer!=VER_UNPACK;\n#else               // All formats since 1.3 for RAR.\n    WrongVer=Arc.FileHead.UnpVer<13 || Arc.FileHead.UnpVer>VER_UNPACK;\n#endif\n  }\n\n  // We can unpack stored files regardless of compression version field.\n  if (Arc.FileHead.Method==0)\n    WrongVer=false;\n\n  if (WrongVer)\n  {\n    ErrHandler.UnknownMethodMsg(Arc.FileName,ArcFileName);\n    uiMsg(UIERROR_NEWERRAR,Arc.FileName);\n  }\n  return !WrongVer;\n}\n","#include \"rar.hpp\"\n\n#ifdef RARDLL\nstatic bool DllVolChange(RAROptions *Cmd,wchar *NextName,size_t NameSize);\nstatic bool DllVolNotify(RAROptions *Cmd,wchar *NextName);\n#endif\n\n\n\nbool MergeArchive(Archive &Arc,ComprDataIO *DataIO,bool ShowFileName,wchar Command)\n{\n  RAROptions *Cmd=Arc.GetRAROptions();\n\n  HEADER_TYPE HeaderType=Arc.GetHeaderType();\n  FileHeader *hd=HeaderType==HEAD_SERVICE ? &Arc.SubHead:&Arc.FileHead;\n  bool SplitHeader=(HeaderType==HEAD_FILE || HeaderType==HEAD_SERVICE) &&\n                   hd->SplitAfter;\n\n  if (DataIO!=NULL && SplitHeader)\n  {\n    bool PackedHashPresent=Arc.Format==RARFMT50 || \n         hd->UnpVer>=20 && hd->FileHash.CRC32!=0xffffffff;\n    if (PackedHashPresent && \n        !DataIO->PackedDataHash.Cmp(&hd->FileHash,hd->UseHashKey ? hd->HashKey:NULL))\n      uiMsg(UIERROR_CHECKSUMPACKED, Arc.FileName, hd->FileName);\n  }\n\n  int64 PosBeforeClose=Arc.Tell();\n\n  if (DataIO!=NULL)\n    DataIO->ProcessedArcSize+=Arc.FileLength();\n\n\n  Arc.Close();\n\n  wchar NextName[NM];\n  wcscpy(NextName,Arc.FileName);\n  NextVolumeName(NextName,ASIZE(NextName),!Arc.NewNumbering);\n\n#if !defined(SFX_MODULE) && !defined(RARDLL)\n  bool RecoveryDone=false;\n#endif\n  bool FailedOpen=false,OldSchemeTested=false;\n\n#if !defined(GUI) && !defined(SILENT)\n  // In -vp mode we force the pause before next volume even if it is present\n  // and even if we are on the hard disk. It is important when user does not\n  // want to process partially downloaded volumes preliminary.\n  if (Cmd->VolumePause && !uiAskNextVolume(NextName,ASIZE(NextName)))\n    FailedOpen=true;\n#endif\n\n  uint OpenMode = Cmd->OpenShared ? FMF_OPENSHARED : 0;\n\n  if (!FailedOpen)\n    while (!Arc.Open(NextName,OpenMode))\n    {\n      // We need to open a new volume which size was not calculated\n      // in total size before, so we cannot calculate the total progress\n      // anymore. Let's reset the total size to zero and stop \n      // the total progress.\n      if (DataIO!=NULL)\n        DataIO->TotalArcSize=0;\n\n      if (!OldSchemeTested)\n      {\n        // Checking for new style volumes renamed by user to old style\n        // name format. Some users did it for unknown reason.\n        wchar AltNextName[NM];\n        wcscpy(AltNextName,Arc.FileName);\n        NextVolumeName(AltNextName,ASIZE(AltNextName),true);\n        OldSchemeTested=true;\n        if (Arc.Open(AltNextName,OpenMode))\n        {\n          wcscpy(NextName,AltNextName);\n          break;\n        }\n      }\n#ifdef RARDLL\n      if (!DllVolChange(Cmd,NextName,ASIZE(NextName)))\n      {\n        FailedOpen=true;\n        break;\n      }\n#else // !RARDLL\n\n#ifndef SFX_MODULE\n      if (!RecoveryDone)\n      {\n        RecVolumesRestore(Cmd,Arc.FileName,true);\n        RecoveryDone=true;\n        continue;\n      }\n#endif\n\n#ifndef GUI\n      if (!Cmd->VolumePause && !IsRemovable(NextName))\n      {\n        FailedOpen=true;\n        break;\n      }\n#endif\n#ifndef SILENT\n      if (Cmd->AllYes || !uiAskNextVolume(NextName,ASIZE(NextName)))\n#endif\n      {\n        FailedOpen=true;\n        break;\n      }\n\n#endif // RARDLL\n    }\n  \n  if (FailedOpen)\n  {\n    uiMsg(UIERROR_MISSINGVOL,NextName);\n    Arc.Open(Arc.FileName,OpenMode);\n    Arc.Seek(PosBeforeClose,SEEK_SET);\n    return false;\n  }\n\n  if (Command=='T' || Command=='X' || Command=='E')\n    mprintf(St(Command=='T' ? MTestVol:MExtrVol),Arc.FileName);\n\n\n  Arc.CheckArc(true);\n#ifdef RARDLL\n  if (!DllVolNotify(Cmd,NextName))\n    return false;\n#endif\n\n  if (SplitHeader)\n    Arc.SearchBlock(HeaderType);\n  else\n    Arc.ReadHeader();\n  if (Arc.GetHeaderType()==HEAD_FILE)\n  {\n    Arc.ConvertAttributes();\n    Arc.Seek(Arc.NextBlockPos-Arc.FileHead.PackSize,SEEK_SET);\n  }\n#ifndef GUI\n  if (ShowFileName)\n  {\n    mprintf(St(MExtrPoints),Arc.FileHead.FileName);\n    if (!Cmd->DisablePercentage)\n      mprintf(L\"     \");\n  }\n#endif\n  if (DataIO!=NULL)\n  {\n    if (HeaderType==HEAD_ENDARC)\n      DataIO->UnpVolume=false;\n    else\n    {\n      DataIO->UnpVolume=hd->SplitAfter;\n      DataIO->SetPackedSizeToRead(hd->PackSize);\n    }\n#ifdef SFX_MODULE\n    DataIO->UnpArcSize=Arc.FileLength();\n#endif\n    \n    // Reset the size of packed data read from current volume. It is used\n    // to display the total progress and preceding volumes are already\n    // compensated with ProcessedArcSize, so we need to reset this variable.\n    DataIO->CurUnpRead=0;\n\n    DataIO->PackedDataHash.Init(hd->FileHash.Type,Cmd->Threads);\n  }\n  return true;\n}\n\n\n\n\n\n\n#ifdef RARDLL\n#if defined(RARDLL) && defined(_MSC_VER) && !defined(_WIN_64)\n// Disable the run time stack check for unrar.dll, so we can manipulate\n// with ChangeVolProc call type below. Run time check would intercept\n// a wrong ESP before we restore it.\n#pragma runtime_checks( \"s\", off )\n#endif\n\nbool DllVolChange(RAROptions *Cmd,wchar *NextName,size_t NameSize)\n{\n  bool DllVolChanged=false,DllVolAborted=false;\n\n  if (Cmd->Callback!=NULL)\n  {\n    wchar OrgNextName[NM];\n    wcscpy(OrgNextName,NextName);\n    if (Cmd->Callback(UCM_CHANGEVOLUMEW,Cmd->UserData,(LPARAM)NextName,RAR_VOL_ASK)==-1)\n      DllVolAborted=true;\n    else\n      if (wcscmp(OrgNextName,NextName)!=0)\n        DllVolChanged=true;\n      else\n      {\n        char NextNameA[NM],OrgNextNameA[NM];\n        WideToChar(NextName,NextNameA,ASIZE(NextNameA));\n        strcpy(OrgNextNameA,NextNameA);\n        if (Cmd->Callback(UCM_CHANGEVOLUME,Cmd->UserData,(LPARAM)NextNameA,RAR_VOL_ASK)==-1)\n          DllVolAborted=true;\n        else\n          if (strcmp(OrgNextNameA,NextNameA)!=0)\n          {\n            // We can damage some Unicode characters by U->A->U conversion,\n            // so set Unicode name only if we see that ANSI name is changed.\n            CharToWide(NextNameA,NextName,NameSize);\n            DllVolChanged=true;\n          }\n      }\n  }\n  if (!DllVolChanged && Cmd->ChangeVolProc!=NULL)\n  {\n    char NextNameA[NM];\n    WideToChar(NextName,NextNameA,ASIZE(NextNameA));\n    // Here we preserve ESP value. It is necessary for those developers,\n    // who still define ChangeVolProc callback as \"C\" type function,\n    // even though in year 2001 we announced in unrar.dll whatsnew.txt\n    // that it will be PASCAL type (for compatibility with Visual Basic).\n#if defined(_MSC_VER)\n#ifndef _WIN_64\n    __asm mov ebx,esp\n#endif\n#elif defined(_WIN_ALL) && defined(__BORLANDC__)\n    _EBX=_ESP;\n#endif\n    int RetCode=Cmd->ChangeVolProc(NextNameA,RAR_VOL_ASK);\n\n    // Restore ESP after ChangeVolProc with wrongly defined calling\n    // convention broken it.\n#if defined(_MSC_VER)\n#ifndef _WIN_64\n    __asm mov esp,ebx\n#endif\n#elif defined(_WIN_ALL) && defined(__BORLANDC__)\n    _ESP=_EBX;\n#endif\n    if (RetCode==0)\n      DllVolAborted=true;\n    else\n      CharToWide(NextNameA,NextName,NameSize);\n  }\n\n  // We quit only on 'abort' condition, but not on 'name not changed'.\n  // It is legitimate for program to return the same name when waiting\n  // for currently non-existent volume.\n  // Also we quit to prevent an infinite loop if no callback is defined.\n  if (DllVolAborted || Cmd->Callback==NULL && Cmd->ChangeVolProc==NULL)\n  {\n    Cmd->DllError=ERAR_EOPEN;\n    return false;\n  }\n  return true;\n}\n#endif\n\n\n#ifdef RARDLL\nbool DllVolNotify(RAROptions *Cmd,wchar *NextName)\n{\n  char NextNameA[NM];\n  WideToChar(NextName,NextNameA,ASIZE(NextNameA));\n  if (Cmd->Callback!=NULL)\n  {\n    if (Cmd->Callback(UCM_CHANGEVOLUMEW,Cmd->UserData,(LPARAM)NextName,RAR_VOL_NOTIFY)==-1)\n      return false;\n    if (Cmd->Callback(UCM_CHANGEVOLUME,Cmd->UserData,(LPARAM)NextNameA,RAR_VOL_NOTIFY)==-1)\n      return false;\n  }\n  if (Cmd->ChangeVolProc!=NULL)\n  {\n#if defined(_WIN_ALL) && !defined(_MSC_VER) && !defined(__MINGW32__)\n    _EBX=_ESP;\n#endif\n    int RetCode=Cmd->ChangeVolProc(NextNameA,RAR_VOL_NOTIFY);\n#if defined(_WIN_ALL) && !defined(_MSC_VER) && !defined(__MINGW32__)\n    _ESP=_EBX;\n#endif\n    if (RetCode==0)\n      return false;\n  }\n  return true;\n}\n\n#if defined(RARDLL) && defined(_MSC_VER) && !defined(_WIN_64)\n// Restore the run time stack check for unrar.dll.\n#pragma runtime_checks( \"s\", restore )\n#endif\n#endif\n","\n\ninline unsigned int RangeCoder::GetChar()\n{\n  return(UnpackRead->GetChar());\n}\n\n\nvoid RangeCoder::InitDecoder(Unpack *UnpackRead)\n{\n  RangeCoder::UnpackRead=UnpackRead;\n\n  low=code=0;\n  range=uint(-1);\n  for (int i=0;i < 4;i++)\n    code=(code << 8) | GetChar();\n}\n\n\n// (int) cast before \"low\" added only to suppress compiler warnings.\n#define ARI_DEC_NORMALIZE(code,low,range,read)                           \\\n{                                                                        \\\n  while ((low^(low+range))<TOP || range<BOT && ((range=-(int)low&(BOT-1)),1)) \\\n  {                                                                      \\\n    code=(code << 8) | read->GetChar();                                  \\\n    range <<= 8;                                                         \\\n    low <<= 8;                                                           \\\n  }                                                                      \\\n}\n\n\ninline int RangeCoder::GetCurrentCount() \n{\n  return (code-low)/(range /= SubRange.scale);\n}\n\n\ninline uint RangeCoder::GetCurrentShiftCount(uint SHIFT) \n{\n  return (code-low)/(range >>= SHIFT);\n}\n\n\ninline void RangeCoder::Decode()\n{\n  low += range*SubRange.LowCount;\n  range *= SubRange.HighCount-SubRange.LowCount;\n}\n","void Unpack::Unpack5(bool Solid)\n{\n  FileExtracted=true;\n\n  if (!Suspended)\n  {\n    UnpInitData(Solid);\n    if (!UnpReadBuf())\n      return;\n    if (!ReadBlockHeader(Inp,BlockHeader) || !ReadTables(Inp,BlockHeader,BlockTables))\n      return;\n  }\n\n  while (true)\n  {\n    UnpPtr&=MaxWinMask;\n\n    if (Inp.InAddr>=ReadBorder)\n    {\n      bool FileDone=false;\n\n      // We use 'while', because for empty block containing only Huffman table,\n      // we'll be on the block border once again just after reading the table.\n      while (Inp.InAddr>BlockHeader.BlockStart+BlockHeader.BlockSize-1 || \n             Inp.InAddr==BlockHeader.BlockStart+BlockHeader.BlockSize-1 && \n             Inp.InBit>=BlockHeader.BlockBitSize)\n      {\n        if (BlockHeader.LastBlockInFile)\n        {\n          FileDone=true;\n          break;\n        }\n        if (!ReadBlockHeader(Inp,BlockHeader) || !ReadTables(Inp,BlockHeader,BlockTables))\n          return;\n      }\n      if (FileDone || !UnpReadBuf())\n        break;\n    }\n\n    if (((WriteBorder-UnpPtr) & MaxWinMask)<MAX_LZ_MATCH+3 && WriteBorder!=UnpPtr)\n    {\n      UnpWriteBuf();\n      if (WrittenFileSize>DestUnpSize)\n        return;\n      if (Suspended)\n      {\n        FileExtracted=false;\n        return;\n      }\n    }\n\n    uint MainSlot=DecodeNumber(Inp,&BlockTables.LD);\n    if (MainSlot<256)\n    {\n      if (Fragmented)\n        FragWindow[UnpPtr++]=(byte)MainSlot;\n      else\n        Window[UnpPtr++]=(byte)MainSlot;\n      continue;\n    }\n    if (MainSlot>=262)\n    {\n      uint Length=SlotToLength(Inp,MainSlot-262);\n\n      uint DBits,Distance=1,DistSlot=DecodeNumber(Inp,&BlockTables.DD);\n      if (DistSlot<4)\n      {\n        DBits=0;\n        Distance+=DistSlot;\n      }\n      else\n      {\n        DBits=DistSlot/2 - 1;\n        Distance+=(2 | (DistSlot & 1)) << DBits;\n      }\n\n      if (DBits>0)\n      {\n        if (DBits>=4)\n        {\n          if (DBits>4)\n          {\n            Distance+=((Inp.getbits32()>>(36-DBits))<<4);\n            Inp.addbits(DBits-4);\n          }\n          uint LowDist=DecodeNumber(Inp,&BlockTables.LDD);\n          Distance+=LowDist;\n        }\n        else\n        {\n          Distance+=Inp.getbits32()>>(32-DBits);\n          Inp.addbits(DBits);\n        }\n      }\n\n      if (Distance>0x100)\n      {\n        Length++;\n        if (Distance>0x2000)\n        {\n          Length++;\n          if (Distance>0x40000)\n            Length++;\n        }\n      }\n\n      InsertOldDist(Distance);\n      LastLength=Length;\n      if (Fragmented)\n        FragWindow.CopyString(Length,Distance,UnpPtr,MaxWinMask);\n      else\n        CopyString(Length,Distance);\n      continue;\n    }\n    if (MainSlot==256)\n    {\n      UnpackFilter Filter;\n      if (!ReadFilter(Inp,Filter) || !AddFilter(Filter))\n        break;\n      continue;\n    }\n    if (MainSlot==257)\n    {\n      if (LastLength!=0)\n        if (Fragmented)\n          FragWindow.CopyString(LastLength,OldDist[0],UnpPtr,MaxWinMask);\n        else\n          CopyString(LastLength,OldDist[0]);\n      continue;\n    }\n    if (MainSlot<262)\n    {\n      uint DistNum=MainSlot-258;\n      uint Distance=OldDist[DistNum];\n      for (uint I=DistNum;I>0;I--)\n        OldDist[I]=OldDist[I-1];\n      OldDist[0]=Distance;\n\n      uint LengthSlot=DecodeNumber(Inp,&BlockTables.RD);\n      uint Length=SlotToLength(Inp,LengthSlot);\n      LastLength=Length;\n      if (Fragmented)\n        FragWindow.CopyString(Length,Distance,UnpPtr,MaxWinMask);\n      else\n        CopyString(Length,Distance);\n      continue;\n    }\n  }\n  UnpWriteBuf();\n}\n\n\nuint Unpack::ReadFilterData(BitInput &Inp)\n{\n  uint ByteCount=(Inp.fgetbits()>>14)+1;\n  Inp.addbits(2);\n\n  uint Data=0;\n  for (uint I=0;I<ByteCount;I++)\n  {\n    Data+=(Inp.fgetbits()>>8)<<(I*8);\n    Inp.addbits(8);\n  }\n  return Data;\n}\n\n\nbool Unpack::ReadFilter(BitInput &Inp,UnpackFilter &Filter)\n{\n  if (!Inp.ExternalBuffer && Inp.InAddr>ReadTop-16)\n    if (!UnpReadBuf())\n      return false;\n\n  Filter.BlockStart=ReadFilterData(Inp);\n  Filter.BlockLength=ReadFilterData(Inp);\n\n  Filter.Type=Inp.fgetbits()>>13;\n  Inp.faddbits(3);\n\n  if (Filter.Type==FILTER_DELTA)\n  {\n    Filter.Channels=(Inp.fgetbits()>>11)+1;\n    Inp.faddbits(5);\n  }\n\n  return true;\n}\n\n\nbool Unpack::AddFilter(UnpackFilter &Filter)\n{\n  if (Filters.Size()>=MAX_UNPACK_FILTERS)\n  {\n    UnpWriteBuf(); // Write data, apply and flush filters.\n    if (Filters.Size()>=MAX_UNPACK_FILTERS)\n      InitFilters(); // Still too many filters, prevent excessive memory use.\n  }\n\n  // If distance to filter start is that large that due to circular dictionary\n  // mode now it points to old not written yet data, then we set 'NextWindow'\n  // flag and process this filter only after processing that older data.\n  Filter.NextWindow=WrPtr!=UnpPtr && ((WrPtr-UnpPtr)&MaxWinMask)<=Filter.BlockStart;\n\n  Filter.BlockStart=uint((Filter.BlockStart+UnpPtr)&MaxWinMask);\n  Filters.Push(Filter);\n  return true;\n}\n\n\nbool Unpack::UnpReadBuf()\n{\n  int DataSize=ReadTop-Inp.InAddr; // Data left to process.\n  if (DataSize<0)\n    return false;\n  BlockHeader.BlockSize-=Inp.InAddr-BlockHeader.BlockStart;\n  if (Inp.InAddr>BitInput::MAX_SIZE/2)\n  {\n    // If we already processed more than half of buffer, let's move\n    // remaining data into beginning to free more space for new data\n    // and ensure that calling function does not cross the buffer border\n    // even if we did not read anything here. Also it ensures that read size\n    // is not less than CRYPT_BLOCK_SIZE, so we can align it without risk\n    // to make it zero.\n    if (DataSize>0)\n      memmove(Inp.InBuf,Inp.InBuf+Inp.InAddr,DataSize);\n    Inp.InAddr=0;\n    ReadTop=DataSize;\n  }\n  else\n    DataSize=ReadTop;\n  int ReadCode=0;\n  if (BitInput::MAX_SIZE!=DataSize)\n    ReadCode=UnpIO->UnpRead(Inp.InBuf+DataSize,BitInput::MAX_SIZE-DataSize);\n  if (ReadCode>0) // Can be also -1.\n    ReadTop+=ReadCode;\n  ReadBorder=ReadTop-30;\n  BlockHeader.BlockStart=Inp.InAddr;\n  if (BlockHeader.BlockSize!=-1) // '-1' means not defined yet.\n  {\n    // We may need to quit from main extraction loop and read new block header\n    // and trees earlier than data in input buffer ends.\n    ReadBorder=Min(ReadBorder,BlockHeader.BlockStart+BlockHeader.BlockSize-1);\n  }\n  return ReadCode!=-1;\n}\n\n\nvoid Unpack::UnpWriteBuf()\n{\n  size_t WrittenBorder=WrPtr;\n  size_t FullWriteSize=(UnpPtr-WrittenBorder)&MaxWinMask;\n  size_t WriteSizeLeft=FullWriteSize;\n  bool NotAllFiltersProcessed=false;\n  for (size_t I=0;I<Filters.Size();I++)\n  {\n    // Here we apply filters to data which we need to write.\n    // We always copy data to another memory block before processing.\n    // We cannot process them just in place in Window buffer, because\n    // these data can be used for future string matches, so we must\n    // preserve them in original form.\n\n    UnpackFilter *flt=&Filters[I];\n    if (flt->Type==FILTER_NONE)\n      continue;\n    if (flt->NextWindow)\n    {\n      // Here we skip filters which have block start in current data range\n      // due to address wrap around in circular dictionary, but actually\n      // belong to next dictionary block. If such filter start position\n      // is included to current write range, then we reset 'NextWindow' flag.\n      // In fact we can reset it even without such check, because current\n      // implementation seems to guarantee 'NextWindow' flag reset after\n      // buffer writing for all existing filters. But let's keep this check\n      // just in case. Compressor guarantees that distance between\n      // filter block start and filter storing position cannot exceed\n      // the dictionary size. So if we covered the filter block start with\n      // our write here, we can safely assume that filter is applicable\n      // to next block on no further wrap arounds is possible.\n      if (((flt->BlockStart-WrPtr)&MaxWinMask)<=FullWriteSize)\n        flt->NextWindow=false;\n      continue;\n    }\n    uint BlockStart=flt->BlockStart;\n    uint BlockLength=flt->BlockLength;\n    if (((BlockStart-WrittenBorder)&MaxWinMask)<WriteSizeLeft)\n    {\n      if (WrittenBorder!=BlockStart)\n      {\n        UnpWriteArea(WrittenBorder,BlockStart);\n        WrittenBorder=BlockStart;\n        WriteSizeLeft=(UnpPtr-WrittenBorder)&MaxWinMask;\n      }\n      if (BlockLength<=WriteSizeLeft)\n      {\n        if (BlockLength>0)\n        {\n          uint BlockEnd=(BlockStart+BlockLength)&MaxWinMask;\n\n          FilterSrcMemory.Alloc(BlockLength);\n          byte *Mem=&FilterSrcMemory[0];\n          if (BlockStart<BlockEnd || BlockEnd==0)\n          {\n            if (Fragmented)\n              FragWindow.CopyData(Mem,BlockStart,BlockLength);\n            else\n              memcpy(Mem,Window+BlockStart,BlockLength);\n          }\n          else\n          {\n            size_t FirstPartLength=size_t(MaxWinSize-BlockStart);\n            if (Fragmented)\n            {\n              FragWindow.CopyData(Mem,BlockStart,FirstPartLength);\n              FragWindow.CopyData(Mem+FirstPartLength,0,BlockEnd);\n            }\n            else\n            {\n              memcpy(Mem,Window+BlockStart,FirstPartLength);\n              memcpy(Mem+FirstPartLength,Window,BlockEnd);\n            }\n          }\n\n          byte *OutMem=ApplyFilter(Mem,BlockLength,flt);\n\n          Filters[I].Type=FILTER_NONE;\n\n          if (OutMem!=NULL)\n            UnpIO->UnpWrite(OutMem,BlockLength);\n\n          UnpSomeRead=true;\n          WrittenFileSize+=BlockLength;\n          WrittenBorder=BlockEnd;\n          WriteSizeLeft=(UnpPtr-WrittenBorder)&MaxWinMask;\n        }\n      }\n      else\n      {\n        // Current filter intersects the window write border, so we adjust\n        // the window border to process this filter next time, not now.\n        WrPtr=WrittenBorder;\n\n        // Since Filter start position can only increase, we quit processing\n        // all following filters for this data block and reset 'NextWindow'\n        // flag for them.\n        for (size_t J=I;J<Filters.Size();J++)\n        {\n          UnpackFilter *flt=&Filters[J];\n          if (flt->Type!=FILTER_NONE)\n            flt->NextWindow=false;\n        }\n\n        // Do not write data left after current filter now.\n        NotAllFiltersProcessed=true;\n        break;\n      }\n    }\n  }\n\n  // Remove processed filters from queue.\n  size_t EmptyCount=0;\n  for (size_t I=0;I<Filters.Size();I++)\n  {\n    if (EmptyCount>0)\n      Filters[I-EmptyCount]=Filters[I];\n    if (Filters[I].Type==FILTER_NONE)\n      EmptyCount++;\n  }\n  if (EmptyCount>0)\n    Filters.Alloc(Filters.Size()-EmptyCount);\n\n  if (!NotAllFiltersProcessed) // Only if all filters are processed.\n  {\n    // Write data left after last filter.\n    UnpWriteArea(WrittenBorder,UnpPtr);\n    WrPtr=UnpPtr;\n  }\n\n  // We prefer to write data in blocks not exceeding UNPACK_MAX_WRITE\n  // instead of potentially huge MaxWinSize blocks. It also allows us\n  // to keep the size of Filters array reasonable.\n  WriteBorder=(UnpPtr+Min(MaxWinSize,UNPACK_MAX_WRITE))&MaxWinMask;\n\n  // Choose the nearest among WriteBorder and WrPtr actual written border.\n  // If border is equal to UnpPtr, it means that we have MaxWinSize data ahead.\n  if (WriteBorder==UnpPtr || \n      WrPtr!=UnpPtr && ((WrPtr-UnpPtr)&MaxWinMask)<((WriteBorder-UnpPtr)&MaxWinMask))\n    WriteBorder=WrPtr;\n}\n\n\nbyte* Unpack::ApplyFilter(byte *Data,uint DataSize,UnpackFilter *Flt)\n{\n  byte *SrcData=Data;\n  switch(Flt->Type)\n  {\n    case FILTER_E8:\n    case FILTER_E8E9:\n      {\n        uint FileOffset=(uint)WrittenFileSize;\n\n        const int FileSize=0x1000000;\n        byte CmpByte2=Flt->Type==FILTER_E8E9 ? 0xe9:0xe8;\n        for (uint CurPos=0;(int)CurPos<(int)DataSize-4;)\n        {\n          byte CurByte=*(Data++);\n          CurPos++;\n          if (CurByte==0xe8 || CurByte==CmpByte2)\n          {\n            uint Offset=(CurPos+FileOffset)%FileSize;\n            uint Addr=RawGet4(Data);\n\n            // We check 0x80000000 bit instead of '< 0' comparison\n            // not assuming int32 presence or uint size and endianness.\n            if ((Addr & 0x80000000)!=0)              // Addr<0\n            {\n              if (((Addr+Offset) & 0x80000000)==0)   // Addr+Offset>=0\n                RawPut4(Addr+FileSize,Data);\n            }\n            else\n              if (((Addr-FileSize) & 0x80000000)!=0) // Addr<FileSize\n                RawPut4(Addr-Offset,Data);\n\n            Data+=4;\n            CurPos+=4;\n          }\n        }\n      }\n      return SrcData;\n    case FILTER_ARM:\n      {\n        uint FileOffset=(uint)WrittenFileSize;\n        for (uint CurPos=0;(int)CurPos<(int)DataSize-3;CurPos+=4)\n        {\n          byte *D=Data+CurPos;\n          if (D[3]==0xeb) // BL command with '1110' (Always) condition.\n          {\n            uint Offset=D[0]+uint(D[1])*0x100+uint(D[2])*0x10000;\n            Offset-=(FileOffset+CurPos)/4;\n            D[0]=(byte)Offset;\n            D[1]=(byte)(Offset>>8);\n            D[2]=(byte)(Offset>>16);\n          }\n        }\n      }\n      return SrcData;\n    case FILTER_DELTA:\n      {\n        uint Channels=Flt->Channels,SrcPos=0;\n\n        FilterDstMemory.Alloc(DataSize);\n        byte *DstData=&FilterDstMemory[0];\n\n        // Bytes from same channels are grouped to continual data blocks,\n        // so we need to place them back to their interleaving positions.\n        for (uint CurChannel=0;CurChannel<Channels;CurChannel++)\n        {\n          byte PrevByte=0;\n          for (uint DestPos=CurChannel;DestPos<DataSize;DestPos+=Channels)\n            DstData[DestPos]=(PrevByte-=Data[SrcPos++]);\n        }\n        return DstData;\n      }\n\n  }\n  return NULL;\n}\n\n\nvoid Unpack::UnpWriteArea(size_t StartPtr,size_t EndPtr)\n{\n  if (EndPtr!=StartPtr)\n    UnpSomeRead=true;\n  if (EndPtr<StartPtr)\n    UnpAllBuf=true;\n\n  if (Fragmented)\n  {\n    size_t SizeToWrite=(EndPtr-StartPtr) & MaxWinMask;\n    while (SizeToWrite>0)\n    {\n      size_t BlockSize=FragWindow.GetBlockSize(StartPtr,SizeToWrite);\n      UnpWriteData(&FragWindow[StartPtr],BlockSize);\n      SizeToWrite-=BlockSize;\n      StartPtr=(StartPtr+BlockSize) & MaxWinMask;\n    }\n  }\n  else\n    if (EndPtr<StartPtr)\n    {\n      UnpWriteData(Window+StartPtr,MaxWinSize-StartPtr);\n      UnpWriteData(Window,EndPtr);\n    }\n    else\n      UnpWriteData(Window+StartPtr,EndPtr-StartPtr);\n}\n\n\nvoid Unpack::UnpWriteData(byte *Data,size_t Size)\n{\n  if (WrittenFileSize>=DestUnpSize)\n    return;\n  size_t WriteSize=Size;\n  int64 LeftToWrite=DestUnpSize-WrittenFileSize;\n  if ((int64)WriteSize>LeftToWrite)\n    WriteSize=(size_t)LeftToWrite;\n  UnpIO->UnpWrite(Data,WriteSize);\n  WrittenFileSize+=Size;\n}\n\n\nbool Unpack::ReadBlockHeader(BitInput &Inp,UnpackBlockHeader &Header)\n{\n  Header.HeaderSize=0;\n\n  if (!Inp.ExternalBuffer && Inp.InAddr>ReadTop-7)\n    if (!UnpReadBuf())\n      return false;\n  Inp.faddbits((8-Inp.InBit)&7);\n  \n  byte BlockFlags=Inp.fgetbits()>>8;\n  Inp.faddbits(8);\n  uint ByteCount=((BlockFlags>>3)&3)+1; // Block size byte count.\n  \n  if (ByteCount==4)\n    return false;\n\n  Header.HeaderSize=2+ByteCount;\n\n  Header.BlockBitSize=(BlockFlags&7)+1;\n\n  byte SavedCheckSum=Inp.fgetbits()>>8;\n  Inp.faddbits(8);\n\n  int BlockSize=0;\n  for (uint I=0;I<ByteCount;I++)\n  {\n    BlockSize+=(Inp.fgetbits()>>8)<<(I*8);\n    Inp.addbits(8);\n  }\n\n  Header.BlockSize=BlockSize;\n  byte CheckSum=byte(0x5a^BlockFlags^BlockSize^(BlockSize>>8)^(BlockSize>>16));\n  if (CheckSum!=SavedCheckSum)\n    return false;\n\n  Header.BlockStart=Inp.InAddr;\n  ReadBorder=Min(ReadBorder,Header.BlockStart+Header.BlockSize-1);\n\n  Header.LastBlockInFile=(BlockFlags & 0x40)!=0;\n  Header.TablePresent=(BlockFlags & 0x80)!=0;\n  return true;\n}\n\n\nbool Unpack::ReadTables(BitInput &Inp,UnpackBlockHeader &Header,UnpackBlockTables &Tables)\n{\n  if (!Header.TablePresent)\n    return true;\n\n  if (!Inp.ExternalBuffer && Inp.InAddr>ReadTop-25)\n    if (!UnpReadBuf())\n      return false;\n\n  byte BitLength[BC];\n  for (int I=0;I<BC;I++)\n  {\n    int Length=(byte)(Inp.fgetbits() >> 12);\n    Inp.faddbits(4);\n    if (Length==15)\n    {\n      int ZeroCount=(byte)(Inp.fgetbits() >> 12);\n      Inp.faddbits(4);\n      if (ZeroCount==0)\n        BitLength[I]=15;\n      else\n      {\n        ZeroCount+=2;\n        while (ZeroCount-- > 0 && I<ASIZE(BitLength))\n          BitLength[I++]=0;\n        I--;\n      }\n    }\n    else\n      BitLength[I]=Length;\n  }\n\n  MakeDecodeTables(BitLength,&Tables.BD,BC);\n\n  byte Table[HUFF_TABLE_SIZE];\n  const int TableSize=HUFF_TABLE_SIZE;\n  for (int I=0;I<TableSize;)\n  {\n    if (!Inp.ExternalBuffer && Inp.InAddr>ReadTop-5)\n      if (!UnpReadBuf())\n        return false;\n    int Number=DecodeNumber(Inp,&Tables.BD);\n    if (Number<16)\n    {\n      Table[I]=Number;\n      I++;\n    }\n    else\n      if (Number<18)\n      {\n        int N;\n        if (Number==16)\n        {\n          N=(Inp.fgetbits() >> 13)+3;\n          Inp.faddbits(3);\n        }\n        else\n        {\n          N=(Inp.fgetbits() >> 9)+11;\n          Inp.faddbits(7);\n        }\n        if (I>0)\n          while (N-- > 0 && I<TableSize)\n          {\n            Table[I]=Table[I-1];\n            I++;\n          }\n      }\n      else\n      {\n        int N;\n        if (Number==18)\n        {\n          N=(Inp.fgetbits() >> 13)+3;\n          Inp.faddbits(3);\n        }\n        else\n        {\n          N=(Inp.fgetbits() >> 9)+11;\n          Inp.faddbits(7);\n        }\n        while (N-- > 0 && I<TableSize)\n          Table[I++]=0;\n      }\n  }\n  if (!Inp.ExternalBuffer && Inp.InAddr>ReadTop)\n    return false;\n  MakeDecodeTables(&Table[0],&Tables.LD,NC);\n  MakeDecodeTables(&Table[NC],&Tables.DD,DC);\n  MakeDecodeTables(&Table[NC+DC],&Tables.LDD,LDC);\n  MakeDecodeTables(&Table[NC+DC+LDC],&Tables.RD,RC);\n  return true;\n}\n\n\nvoid Unpack::InitFilters()\n{\n  Filters.SoftReset();\n}\n","/****************************************************************************\n *  This file is part of PPMd project                                       *\n *  Written and distributed to public domain by Dmitry Shkarin 1997,        *\n *  1999-2000                                                               *\n *  Contents: memory allocation routines                                    *\n ****************************************************************************/\n\nstatic const uint UNIT_SIZE=Max(sizeof(RARPPM_CONTEXT),sizeof(RARPPM_MEM_BLK));\nstatic const uint FIXED_UNIT_SIZE=12;\n\nSubAllocator::SubAllocator()\n{\n  Clean();\n}\n\n\nvoid SubAllocator::Clean()\n{\n  SubAllocatorSize=0;\n}\n\n\ninline void SubAllocator::InsertNode(void* p,int indx) \n{\n  ((RAR_NODE*) p)->next=FreeList[indx].next;\n  FreeList[indx].next=(RAR_NODE*) p;\n}\n\n\ninline void* SubAllocator::RemoveNode(int indx) \n{\n  RAR_NODE* RetVal=FreeList[indx].next;\n  FreeList[indx].next=RetVal->next;\n  return RetVal;\n}\n\n\ninline uint SubAllocator::U2B(int NU) \n{ \n  // We calculate the size of units in bytes based on real UNIT_SIZE.\n  // In original implementation it was 8*NU+4*NU.\n  return UNIT_SIZE*NU;\n}\n\n\n\n// Calculate RARPPM_MEM_BLK+Items address. Real RARPPM_MEM_BLK size must be\n// equal to UNIT_SIZE, so we cannot just add Items to RARPPM_MEM_BLK address.\ninline RARPPM_MEM_BLK* SubAllocator::MBPtr(RARPPM_MEM_BLK *BasePtr,int Items)\n{\n  return((RARPPM_MEM_BLK*)( ((byte *)(BasePtr))+U2B(Items) ));\n}\n\n\ninline void SubAllocator::SplitBlock(void* pv,int OldIndx,int NewIndx)\n{\n  int i, UDiff=Indx2Units[OldIndx]-Indx2Units[NewIndx];\n  byte* p=((byte*) pv)+U2B(Indx2Units[NewIndx]);\n  if (Indx2Units[i=Units2Indx[UDiff-1]] != UDiff) \n  {\n    InsertNode(p,--i);\n    p += U2B(i=Indx2Units[i]);\n    UDiff -= i;\n  }\n  InsertNode(p,Units2Indx[UDiff-1]);\n}\n\n\nvoid SubAllocator::StopSubAllocator()\n{\n  if ( SubAllocatorSize ) \n  {\n    SubAllocatorSize=0;\n    free(HeapStart);\n  }\n}\n\n\nbool SubAllocator::StartSubAllocator(int SASize)\n{\n  uint t=SASize << 20;\n  if (SubAllocatorSize == t)\n    return TRUE;\n  StopSubAllocator();\n\n  // Original algorithm expects FIXED_UNIT_SIZE, but actual structure size\n  // can be larger. So let's recalculate the allocated size and add two more\n  // units: one as reserve for HeapEnd overflow checks and another\n  // to provide the space to correctly align UnitsStart.\n  uint AllocSize=t/FIXED_UNIT_SIZE*UNIT_SIZE+2*UNIT_SIZE;\n  if ((HeapStart=(byte *)malloc(AllocSize)) == NULL)\n  {\n    ErrHandler.MemoryError();\n    return FALSE;\n  }\n\n  // HeapEnd did not present in original algorithm. We added it to control\n  // invalid memory access attempts when processing corrupt archived data.\n  HeapEnd=HeapStart+AllocSize-UNIT_SIZE;\n\n  SubAllocatorSize=t;\n  return TRUE;\n}\n\n\nvoid SubAllocator::InitSubAllocator()\n{\n  int i, k;\n  memset(FreeList,0,sizeof(FreeList));\n  pText=HeapStart;\n\n  // Original algorithm operates with 12 byte FIXED_UNIT_SIZE, but actual\n  // size of RARPPM_MEM_BLK and RARPPM_CONTEXT structures can exceed this value\n  // because of alignment and larger pointer fields size.\n  // So we define UNIT_SIZE for this larger size and adjust memory\n  // pointers accordingly.\n\n  // Size2 is (HiUnit-LoUnit) memory area size to allocate as originally\n  // supposed by compression algorithm. It is 7/8 of total allocated size.\n  uint Size2=FIXED_UNIT_SIZE*(SubAllocatorSize/8/FIXED_UNIT_SIZE*7);\n\n  // RealSize2 is the real adjusted size of (HiUnit-LoUnit) memory taking\n  // into account that our UNIT_SIZE can be larger than FIXED_UNIT_SIZE.\n  uint RealSize2=Size2/FIXED_UNIT_SIZE*UNIT_SIZE;\n\n  // Size1 is the size of memory area from HeapStart to FakeUnitsStart\n  // as originally supposed by compression algorithm. This area can contain\n  // different data types, both single symbols and structures.\n  uint Size1=SubAllocatorSize-Size2;\n\n  // Real size of this area. We correct it according to UNIT_SIZE vs\n  // FIXED_UNIT_SIZE difference. Also we add one more UNIT_SIZE\n  // to compensate a possible reminder from Size1/FIXED_UNIT_SIZE,\n  // which would be lost otherwise. We add UNIT_SIZE instead of \n  // this Size1%FIXED_UNIT_SIZE reminder, because it allows to align\n  // UnitsStart easily and adding more than reminder is ok for algorithm.\n  uint RealSize1=Size1/FIXED_UNIT_SIZE*UNIT_SIZE+UNIT_SIZE;\n\n  // RealSize1 must be divided by UNIT_SIZE without a reminder, so UnitsStart\n  // is aligned to UNIT_SIZE. It is important for those architectures,\n  // where a proper memory alignment is mandatory. Since we produce RealSize1\n  // multiplying by UNIT_SIZE, this condition is always true. So LoUnit,\n  // UnitsStart, HeapStart are properly aligned,\n  LoUnit=UnitsStart=HeapStart+RealSize1;\n\n  // When we reach FakeUnitsStart, we restart the model. It is where\n  // the original algorithm expected to see UnitsStart. Real UnitsStart\n  // can have a larger value.\n  FakeUnitsStart=HeapStart+Size1;\n\n  HiUnit=LoUnit+RealSize2;\n  for (i=0,k=1;i < N1     ;i++,k += 1)\n    Indx2Units[i]=k;\n  for (k++;i < N1+N2      ;i++,k += 2)\n    Indx2Units[i]=k;\n  for (k++;i < N1+N2+N3   ;i++,k += 3)\n    Indx2Units[i]=k;\n  for (k++;i < N1+N2+N3+N4;i++,k += 4)\n    Indx2Units[i]=k;\n  for (GlueCount=k=i=0;k < 128;k++)\n  {\n    i += (Indx2Units[i] < k+1);\n    Units2Indx[k]=i;\n  }\n}\n\n\ninline void SubAllocator::GlueFreeBlocks()\n{\n  RARPPM_MEM_BLK s0, * p, * p1;\n  int i, k, sz;\n  if (LoUnit != HiUnit)\n    *LoUnit=0;\n  for (i=0, s0.next=s0.prev=&s0;i < N_INDEXES;i++)\n    while ( FreeList[i].next )\n    {\n      p=(RARPPM_MEM_BLK*)RemoveNode(i);\n      p->insertAt(&s0);\n      p->Stamp=0xFFFF;\n      p->NU=Indx2Units[i];\n    }\n  for (p=s0.next;p != &s0;p=p->next)\n    while ((p1=MBPtr(p,p->NU))->Stamp == 0xFFFF && int(p->NU)+p1->NU < 0x10000)\n    {\n      p1->remove();\n      p->NU += p1->NU;\n    }\n  while ((p=s0.next) != &s0)\n  {\n    for (p->remove(), sz=p->NU;sz > 128;sz -= 128, p=MBPtr(p,128))\n      InsertNode(p,N_INDEXES-1);\n    if (Indx2Units[i=Units2Indx[sz-1]] != sz)\n    {\n      k=sz-Indx2Units[--i];\n      InsertNode(MBPtr(p,sz-k),k-1);\n    }\n    InsertNode(p,i);\n  }\n}\n\nvoid* SubAllocator::AllocUnitsRare(int indx)\n{\n  if ( !GlueCount )\n  {\n    GlueCount = 255;\n    GlueFreeBlocks();\n    if ( FreeList[indx].next )\n      return RemoveNode(indx);\n  }\n  int i=indx;\n  do\n  {\n    if (++i == N_INDEXES)\n    {\n      GlueCount--;\n      i=U2B(Indx2Units[indx]);\n      int j=FIXED_UNIT_SIZE*Indx2Units[indx];\n      if (FakeUnitsStart-pText > j)\n      {\n        FakeUnitsStart-=j;\n        UnitsStart -= i;\n        return(UnitsStart);\n      }\n      return(NULL);\n    }\n  } while ( !FreeList[i].next );\n  void* RetVal=RemoveNode(i);\n  SplitBlock(RetVal,i,indx);\n  return RetVal;\n}\n\n\ninline void* SubAllocator::AllocUnits(int NU)\n{\n  int indx=Units2Indx[NU-1];\n  if ( FreeList[indx].next )\n    return RemoveNode(indx);\n  void* RetVal=LoUnit;\n  LoUnit += U2B(Indx2Units[indx]);\n  if (LoUnit <= HiUnit)\n    return RetVal;\n  LoUnit -= U2B(Indx2Units[indx]);\n  return AllocUnitsRare(indx);\n}\n\n\nvoid* SubAllocator::AllocContext()\n{\n  if (HiUnit != LoUnit)\n    return (HiUnit -= UNIT_SIZE);\n  if ( FreeList->next )\n    return RemoveNode(0);\n  return AllocUnitsRare(0);\n}\n\n\nvoid* SubAllocator::ExpandUnits(void* OldPtr,int OldNU)\n{\n  int i0=Units2Indx[OldNU-1], i1=Units2Indx[OldNU-1+1];\n  if (i0 == i1)\n    return OldPtr;\n  void* ptr=AllocUnits(OldNU+1);\n  if ( ptr ) \n  {\n    memcpy(ptr,OldPtr,U2B(OldNU));\n    InsertNode(OldPtr,i0);\n  }\n  return ptr;\n}\n\n\nvoid* SubAllocator::ShrinkUnits(void* OldPtr,int OldNU,int NewNU)\n{\n  int i0=Units2Indx[OldNU-1], i1=Units2Indx[NewNU-1];\n  if (i0 == i1)\n    return OldPtr;\n  if ( FreeList[i1].next )\n  {\n    void* ptr=RemoveNode(i1);\n    memcpy(ptr,OldPtr,U2B(NewNU));\n    InsertNode(OldPtr,i0);\n    return ptr;\n  } \n  else \n  {\n    SplitBlock(OldPtr,i0,i1);\n    return OldPtr;\n  }\n}\n\n\nvoid SubAllocator::FreeUnits(void* ptr,int OldNU)\n{\n  InsertNode(ptr,Units2Indx[OldNU-1]);\n}\n","/****************************************************************************\n *  This file is part of PPMd project                                       *\n *  Written and distributed to public domain by Dmitry Shkarin 1997,        *\n *  1999-2000                                                               *\n *  Contents: interface to memory allocation routines                       *\n ****************************************************************************/\n#if !defined(_SUBALLOC_H_)\n#define _SUBALLOC_H_\n\n#if defined(__GNUC__) && defined(ALLOW_MISALIGNED)\n#define RARPPM_PACK_ATTR __attribute__ ((packed))\n#else\n#define RARPPM_PACK_ATTR\n#endif /* defined(__GNUC__) */\n\n#ifdef ALLOW_MISALIGNED\n#pragma pack(1)\n#endif\n\nstruct RARPPM_MEM_BLK \n{\n  ushort Stamp, NU;\n  RARPPM_MEM_BLK* next, * prev;\n  void insertAt(RARPPM_MEM_BLK* p) \n  {\n    next=(prev=p)->next;\n    p->next=next->prev=this;\n  }\n  void remove() \n  {\n    prev->next=next;\n    next->prev=prev;\n  }\n} RARPPM_PACK_ATTR;\n\n#ifdef ALLOW_MISALIGNED\n#ifdef _AIX\n#pragma pack(pop)\n#else\n#pragma pack()\n#endif\n#endif\n\n\nclass SubAllocator\n{\n  private:\n    static const int N1=4, N2=4, N3=4, N4=(128+3-1*N1-2*N2-3*N3)/4;\n    static const int N_INDEXES=N1+N2+N3+N4;\n\n    struct RAR_NODE\n    {\n      RAR_NODE* next;\n    };\n\n    inline void InsertNode(void* p,int indx);\n    inline void* RemoveNode(int indx);\n    inline uint U2B(int NU);\n    inline void SplitBlock(void* pv,int OldIndx,int NewIndx);\n    inline void GlueFreeBlocks();\n    void* AllocUnitsRare(int indx);\n    inline RARPPM_MEM_BLK* MBPtr(RARPPM_MEM_BLK *BasePtr,int Items);\n\n    long SubAllocatorSize;\n    byte Indx2Units[N_INDEXES], Units2Indx[128], GlueCount;\n    byte *HeapStart,*LoUnit, *HiUnit;\n    struct RAR_NODE FreeList[N_INDEXES];\n  public:\n    SubAllocator();\n    ~SubAllocator() {StopSubAllocator();}\n    void Clean();\n    bool StartSubAllocator(int SASize);\n    void StopSubAllocator();\n    void  InitSubAllocator();\n    inline void* AllocContext();\n    inline void* AllocUnits(int NU);\n    inline void* ExpandUnits(void* ptr,int OldNU);\n    inline void* ShrinkUnits(void* ptr,int OldNU,int NewNU);\n    inline void  FreeUnits(void* ptr,int OldNU);\n    long GetAllocatedMemory() {return(SubAllocatorSize);};\n\n    byte *pText, *UnitsStart,*HeapEnd,*FakeUnitsStart;\n};\n\n\n#endif /* !defined(_SUBALLOC_H_) */\n","/****************************************************************************\n *  This file is part of PPMd project                                       *\n *  Written and distributed to public domain by Dmitry Shkarin 1997,        *\n *  1999-2000                                                               *\n *  Contents: model description and encoding/decoding routines              *\n ****************************************************************************/\n\nstatic const int MAX_O=64; /* maximum allowed model order */\nconst uint TOP=1 << 24, BOT=1 << 15;\n\ntemplate <class T>\ninline void _PPMD_SWAP(T& t1,T& t2) { T tmp=t1; t1=t2; t2=tmp; }\n\n\ninline RARPPM_CONTEXT* RARPPM_CONTEXT::createChild(ModelPPM *Model,RARPPM_STATE* pStats,\n                                             RARPPM_STATE& FirstState)\n{\n  RARPPM_CONTEXT* pc = (RARPPM_CONTEXT*) Model->SubAlloc.AllocContext();\n  if ( pc ) \n  {\n    pc->NumStats=1;                     \n    pc->OneState=FirstState;\n    pc->Suffix=this;                    \n    pStats->Successor=pc;\n  }\n  return pc;\n}\n\n\nModelPPM::ModelPPM()\n{\n  MinContext=NULL;\n  MaxContext=NULL;\n  MedContext=NULL;\n}\n\n\nvoid ModelPPM::RestartModelRare()\n{\n  int i, k, m;\n  memset(CharMask,0,sizeof(CharMask));\n  SubAlloc.InitSubAllocator();\n  InitRL=-(MaxOrder < 12 ? MaxOrder:12)-1;\n  MinContext = MaxContext = (RARPPM_CONTEXT*) SubAlloc.AllocContext();\n  MinContext->Suffix=NULL;\n  OrderFall=MaxOrder;\n  MinContext->U.SummFreq=(MinContext->NumStats=256)+1;\n  FoundState=MinContext->U.Stats=(RARPPM_STATE*)SubAlloc.AllocUnits(256/2);\n  for (RunLength=InitRL, PrevSuccess=i=0;i < 256;i++) \n  {\n    MinContext->U.Stats[i].Symbol=i;      \n    MinContext->U.Stats[i].Freq=1;\n    MinContext->U.Stats[i].Successor=NULL;\n  }\n  \n  static const ushort InitBinEsc[]={\n    0x3CDD,0x1F3F,0x59BF,0x48F3,0x64A1,0x5ABC,0x6632,0x6051\n  };\n\n  for (i=0;i < 128;i++)\n    for (k=0;k < 8;k++)\n      for (m=0;m < 64;m += 8)\n        BinSumm[i][k+m]=BIN_SCALE-InitBinEsc[k]/(i+2);\n  for (i=0;i < 25;i++)\n    for (k=0;k < 16;k++)            \n      SEE2Cont[i][k].init(5*i+10);\n}\n\n\nvoid ModelPPM::StartModelRare(int MaxOrder)\n{\n  int i, k, m ,Step;\n  EscCount=1;\n/*\n  if (MaxOrder < 2) \n  {\n    memset(CharMask,0,sizeof(CharMask));\n    OrderFall=ModelPPM::MaxOrder;\n    MinContext=MaxContext;\n    while (MinContext->Suffix != NULL)\n    {\n      MinContext=MinContext->Suffix;\n      OrderFall--;\n    }\n    FoundState=MinContext->U.Stats;\n    MinContext=MaxContext;\n  } \n  else \n*/\n  {\n    ModelPPM::MaxOrder=MaxOrder;\n    RestartModelRare();\n    NS2BSIndx[0]=2*0;\n    NS2BSIndx[1]=2*1;\n    memset(NS2BSIndx+2,2*2,9);\n    memset(NS2BSIndx+11,2*3,256-11);\n    for (i=0;i < 3;i++)\n      NS2Indx[i]=i;\n    for (m=i, k=Step=1;i < 256;i++) \n    {\n      NS2Indx[i]=m;\n      if ( !--k ) \n      { \n        k = ++Step;\n        m++; \n      }\n    }\n    memset(HB2Flag,0,0x40);\n    memset(HB2Flag+0x40,0x08,0x100-0x40);\n    DummySEE2Cont.Shift=PERIOD_BITS;\n  }\n}\n\n\nvoid RARPPM_CONTEXT::rescale(ModelPPM *Model)\n{\n  int OldNS=NumStats, i=NumStats-1, Adder, EscFreq;\n  RARPPM_STATE* p1, * p;\n  for (p=Model->FoundState;p != U.Stats;p--)\n    _PPMD_SWAP(p[0],p[-1]);\n  U.Stats->Freq += 4;\n  U.SummFreq += 4;\n  EscFreq=U.SummFreq-p->Freq;\n  Adder=(Model->OrderFall != 0);\n  U.SummFreq = (p->Freq=(p->Freq+Adder) >> 1);\n  do \n  {\n    EscFreq -= (++p)->Freq;\n    U.SummFreq += (p->Freq=(p->Freq+Adder) >> 1);\n    if (p[0].Freq > p[-1].Freq) \n    {\n      RARPPM_STATE tmp=*(p1=p);\n      do \n      { \n        p1[0]=p1[-1]; \n      } while (--p1 != U.Stats && tmp.Freq > p1[-1].Freq);\n      *p1=tmp;\n    }\n  } while ( --i );\n  if (p->Freq == 0) \n  {\n    do \n    { \n      i++; \n    } while ((--p)->Freq == 0);\n    EscFreq += i;\n    if ((NumStats -= i) == 1) \n    {\n      RARPPM_STATE tmp=*U.Stats;\n      do \n      { \n        tmp.Freq-=(tmp.Freq >> 1); \n        EscFreq>>=1; \n      } while (EscFreq > 1);\n      Model->SubAlloc.FreeUnits(U.Stats,(OldNS+1) >> 1);\n      *(Model->FoundState=&OneState)=tmp;  return;\n    }\n  }\n  U.SummFreq += (EscFreq -= (EscFreq >> 1));\n  int n0=(OldNS+1) >> 1, n1=(NumStats+1) >> 1;\n  if (n0 != n1)\n    U.Stats = (RARPPM_STATE*) Model->SubAlloc.ShrinkUnits(U.Stats,n0,n1);\n  Model->FoundState=U.Stats;\n}\n\n\ninline RARPPM_CONTEXT* ModelPPM::CreateSuccessors(bool Skip,RARPPM_STATE* p1)\n{\n#ifdef __ICL\n  static\n#endif\n  RARPPM_STATE UpState;\n  RARPPM_CONTEXT* pc=MinContext, * UpBranch=FoundState->Successor;\n  RARPPM_STATE * p, * ps[MAX_O], ** pps=ps;\n  if ( !Skip ) \n  {\n    *pps++ = FoundState;\n    if ( !pc->Suffix )\n      goto NO_LOOP;\n  }\n  if ( p1 ) \n  {\n    p=p1;\n    pc=pc->Suffix;\n    goto LOOP_ENTRY;\n  }\n  do \n  {\n    pc=pc->Suffix;\n    if (pc->NumStats != 1) \n    {\n      if ((p=pc->U.Stats)->Symbol != FoundState->Symbol)\n        do \n        {\n          p++; \n        } while (p->Symbol != FoundState->Symbol);\n    } \n    else\n      p=&(pc->OneState);\nLOOP_ENTRY:\n    if (p->Successor != UpBranch) \n    {\n      pc=p->Successor;\n      break;\n    }\n    *pps++ = p;\n  } while ( pc->Suffix );\nNO_LOOP:\n  if (pps == ps)\n    return pc;\n  UpState.Symbol=*(byte*) UpBranch;\n  UpState.Successor=(RARPPM_CONTEXT*) (((byte*) UpBranch)+1);\n  if (pc->NumStats != 1) \n  {\n    if ((byte*) pc <= SubAlloc.pText)\n      return(NULL);\n    if ((p=pc->U.Stats)->Symbol != UpState.Symbol)\n    do \n    { \n      p++; \n    } while (p->Symbol != UpState.Symbol);\n    uint cf=p->Freq-1;\n    uint s0=pc->U.SummFreq-pc->NumStats-cf;\n    UpState.Freq=1+((2*cf <= s0)?(5*cf > s0):((2*cf+3*s0-1)/(2*s0)));\n  } \n  else\n    UpState.Freq=pc->OneState.Freq;\n  do \n  {\n    pc = pc->createChild(this,*--pps,UpState);\n    if ( !pc )\n      return NULL;\n  } while (pps != ps);\n  return pc;\n}\n\n\ninline void ModelPPM::UpdateModel()\n{\n  RARPPM_STATE fs = *FoundState, *p = NULL;\n  RARPPM_CONTEXT *pc, *Successor;\n  uint ns1, ns, cf, sf, s0;\n  if (fs.Freq < MAX_FREQ/4 && (pc=MinContext->Suffix) != NULL) \n  {\n    if (pc->NumStats != 1) \n    {\n      if ((p=pc->U.Stats)->Symbol != fs.Symbol) \n      {\n        do \n        { \n          p++; \n        } while (p->Symbol != fs.Symbol);\n        if (p[0].Freq >= p[-1].Freq) \n        {\n          _PPMD_SWAP(p[0],p[-1]); \n          p--;\n        }\n      }\n      if (p->Freq < MAX_FREQ-9) \n      {\n        p->Freq += 2;               \n        pc->U.SummFreq += 2;\n      }\n    } \n    else \n    {\n      p=&(pc->OneState);\n      p->Freq += (p->Freq < 32);\n    }\n  }\n  if ( !OrderFall ) \n  {\n    MinContext=MaxContext=FoundState->Successor=CreateSuccessors(TRUE,p);\n    if ( !MinContext )\n      goto RESTART_MODEL;\n    return;\n  }\n  *SubAlloc.pText++ = fs.Symbol;                   \n  Successor = (RARPPM_CONTEXT*) SubAlloc.pText;\n  if (SubAlloc.pText >= SubAlloc.FakeUnitsStart)                \n    goto RESTART_MODEL;\n  if ( fs.Successor ) \n  {\n    if ((byte*) fs.Successor <= SubAlloc.pText &&\n        (fs.Successor=CreateSuccessors(FALSE,p)) == NULL)\n      goto RESTART_MODEL;\n    if ( !--OrderFall ) \n    {\n      Successor=fs.Successor;\n      SubAlloc.pText -= (MaxContext != MinContext);\n    }\n  } \n  else \n  {\n    FoundState->Successor=Successor;\n    fs.Successor=MinContext;\n  }\n  s0=MinContext->U.SummFreq-(ns=MinContext->NumStats)-(fs.Freq-1);\n  for (pc=MaxContext;pc != MinContext;pc=pc->Suffix) \n  {\n    if ((ns1=pc->NumStats) != 1) \n    {\n      if ((ns1 & 1) == 0) \n      {\n        pc->U.Stats=(RARPPM_STATE*) SubAlloc.ExpandUnits(pc->U.Stats,ns1 >> 1);\n        if ( !pc->U.Stats )           \n          goto RESTART_MODEL;\n      }\n      pc->U.SummFreq += (2*ns1 < ns)+2*((4*ns1 <= ns) & (pc->U.SummFreq <= 8*ns1));\n    } \n    else \n    {\n      p=(RARPPM_STATE*) SubAlloc.AllocUnits(1);\n      if ( !p )\n        goto RESTART_MODEL;\n      *p=pc->OneState;\n      pc->U.Stats=p;\n      if (p->Freq < MAX_FREQ/4-1)\n        p->Freq += p->Freq;\n      else\n        p->Freq  = MAX_FREQ-4;\n      pc->U.SummFreq=p->Freq+InitEsc+(ns > 3);\n    }\n    cf=2*fs.Freq*(pc->U.SummFreq+6);\n    sf=s0+pc->U.SummFreq;\n    if (cf < 6*sf) \n    {\n      cf=1+(cf > sf)+(cf >= 4*sf);\n      pc->U.SummFreq += 3;\n    }\n    else \n    {\n      cf=4+(cf >= 9*sf)+(cf >= 12*sf)+(cf >= 15*sf);\n      pc->U.SummFreq += cf;\n    }\n    p=pc->U.Stats+ns1;\n    p->Successor=Successor;\n    p->Symbol = fs.Symbol;\n    p->Freq = cf;\n    pc->NumStats=++ns1;\n  }\n  MaxContext=MinContext=fs.Successor;\n  return;\nRESTART_MODEL:\n  RestartModelRare();\n  EscCount=0;\n}\n\n\n// Tabulated escapes for exponential symbol distribution\nstatic const byte ExpEscape[16]={ 25,14, 9, 7, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2 };\n#define GET_MEAN(SUMM,SHIFT,ROUND) ((SUMM+(1 << (SHIFT-ROUND))) >> (SHIFT))\n\n\n\ninline void RARPPM_CONTEXT::decodeBinSymbol(ModelPPM *Model)\n{\n  RARPPM_STATE& rs=OneState;\n  Model->HiBitsFlag=Model->HB2Flag[Model->FoundState->Symbol];\n  ushort& bs=Model->BinSumm[rs.Freq-1][Model->PrevSuccess+\n           Model->NS2BSIndx[Suffix->NumStats-1]+\n           Model->HiBitsFlag+2*Model->HB2Flag[rs.Symbol]+\n           ((Model->RunLength >> 26) & 0x20)];\n  if (Model->Coder.GetCurrentShiftCount(TOT_BITS) < bs) \n  {\n    Model->FoundState=&rs;\n    rs.Freq += (rs.Freq < 128);\n    Model->Coder.SubRange.LowCount=0;\n    Model->Coder.SubRange.HighCount=bs;\n    bs = GET_SHORT16(bs+INTERVAL-GET_MEAN(bs,PERIOD_BITS,2));\n    Model->PrevSuccess=1;\n    Model->RunLength++;\n  } \n  else \n  {\n    Model->Coder.SubRange.LowCount=bs;\n    bs = GET_SHORT16(bs-GET_MEAN(bs,PERIOD_BITS,2));\n    Model->Coder.SubRange.HighCount=BIN_SCALE;\n    Model->InitEsc=ExpEscape[bs >> 10];\n    Model->NumMasked=1;\n    Model->CharMask[rs.Symbol]=Model->EscCount;\n    Model->PrevSuccess=0;\n    Model->FoundState=NULL;\n  }\n}\n\n\ninline void RARPPM_CONTEXT::update1(ModelPPM *Model,RARPPM_STATE* p)\n{\n  (Model->FoundState=p)->Freq += 4;              \n  U.SummFreq += 4;\n  if (p[0].Freq > p[-1].Freq) \n  {\n    _PPMD_SWAP(p[0],p[-1]);                   \n    Model->FoundState=--p;\n    if (p->Freq > MAX_FREQ)             \n      rescale(Model);\n  }\n}\n\n\n\n\ninline bool RARPPM_CONTEXT::decodeSymbol1(ModelPPM *Model)\n{\n  Model->Coder.SubRange.scale=U.SummFreq;\n  RARPPM_STATE* p=U.Stats;\n  int i, HiCnt;\n  int count=Model->Coder.GetCurrentCount();\n  if (count>=(int)Model->Coder.SubRange.scale)\n    return(false);\n  if (count < (HiCnt=p->Freq)) \n  {\n    Model->PrevSuccess=(2*(Model->Coder.SubRange.HighCount=HiCnt) > Model->Coder.SubRange.scale);\n    Model->RunLength += Model->PrevSuccess;\n    (Model->FoundState=p)->Freq=(HiCnt += 4);\n    U.SummFreq += 4;\n    if (HiCnt > MAX_FREQ)\n      rescale(Model);\n    Model->Coder.SubRange.LowCount=0;\n    return(true);\n  }\n  else\n    if (Model->FoundState==NULL)\n      return(false);\n  Model->PrevSuccess=0;\n  i=NumStats-1;\n  while ((HiCnt += (++p)->Freq) <= count)\n    if (--i == 0) \n    {\n      Model->HiBitsFlag=Model->HB2Flag[Model->FoundState->Symbol];\n      Model->Coder.SubRange.LowCount=HiCnt;\n      Model->CharMask[p->Symbol]=Model->EscCount;\n      i=(Model->NumMasked=NumStats)-1;\n      Model->FoundState=NULL;\n      do \n      { \n        Model->CharMask[(--p)->Symbol]=Model->EscCount; \n      } while ( --i );\n      Model->Coder.SubRange.HighCount=Model->Coder.SubRange.scale;\n      return(true);\n    }\n  Model->Coder.SubRange.LowCount=(Model->Coder.SubRange.HighCount=HiCnt)-p->Freq;\n  update1(Model,p);\n  return(true);\n}\n\n\ninline void RARPPM_CONTEXT::update2(ModelPPM *Model,RARPPM_STATE* p)\n{\n  (Model->FoundState=p)->Freq += 4;              \n  U.SummFreq += 4;\n  if (p->Freq > MAX_FREQ)                 \n    rescale(Model);\n  Model->EscCount++;\n  Model->RunLength=Model->InitRL;\n}\n\n\ninline RARPPM_SEE2_CONTEXT* RARPPM_CONTEXT::makeEscFreq2(ModelPPM *Model,int Diff)\n{\n  RARPPM_SEE2_CONTEXT* psee2c;\n  if (NumStats != 256) \n  {\n    psee2c=Model->SEE2Cont[Model->NS2Indx[Diff-1]]+\n           (Diff < Suffix->NumStats-NumStats)+\n           2*(U.SummFreq < 11*NumStats)+4*(Model->NumMasked > Diff)+\n           Model->HiBitsFlag;\n    Model->Coder.SubRange.scale=psee2c->getMean();\n  }\n  else \n  {\n    psee2c=&Model->DummySEE2Cont;\n    Model->Coder.SubRange.scale=1;\n  }\n  return psee2c;\n}\n\n\n\n\ninline bool RARPPM_CONTEXT::decodeSymbol2(ModelPPM *Model)\n{\n  int count, HiCnt, i=NumStats-Model->NumMasked;\n  RARPPM_SEE2_CONTEXT* psee2c=makeEscFreq2(Model,i);\n  RARPPM_STATE* ps[256], ** pps=ps, * p=U.Stats-1;\n  HiCnt=0;\n  do \n  {\n    do \n    { \n      p++; \n    } while (Model->CharMask[p->Symbol] == Model->EscCount);\n    HiCnt += p->Freq;\n    *pps++ = p;\n  } while ( --i );\n  Model->Coder.SubRange.scale += HiCnt;\n  count=Model->Coder.GetCurrentCount();\n  if (count>=(int)Model->Coder.SubRange.scale)\n    return(false);\n  p=*(pps=ps);\n  if (count < HiCnt) \n  {\n    HiCnt=0;\n    while ((HiCnt += p->Freq) <= count) \n      p=*++pps;\n    Model->Coder.SubRange.LowCount = (Model->Coder.SubRange.HighCount=HiCnt)-p->Freq;\n    psee2c->update();\n    update2(Model,p);\n  }\n  else\n  {\n    Model->Coder.SubRange.LowCount=HiCnt;\n    Model->Coder.SubRange.HighCount=Model->Coder.SubRange.scale;\n    i=NumStats-Model->NumMasked;\n    pps--;\n    do \n    { \n      Model->CharMask[(*++pps)->Symbol]=Model->EscCount; \n    } while ( --i );\n    psee2c->Summ += Model->Coder.SubRange.scale;\n    Model->NumMasked = NumStats;\n  }\n  return(true);\n}\n\n\ninline void ModelPPM::ClearMask()\n{\n  EscCount=1;                             \n  memset(CharMask,0,sizeof(CharMask));\n}\n\n\n\n\n// reset PPM variables after data error allowing safe resuming\n// of further data processing\nvoid ModelPPM::CleanUp()\n{\n  SubAlloc.StopSubAllocator();\n  SubAlloc.StartSubAllocator(1);\n  StartModelRare(2);\n}\n\n\nbool ModelPPM::DecodeInit(Unpack *UnpackRead,int &EscChar)\n{\n  int MaxOrder=UnpackRead->GetChar();\n  bool Reset=(MaxOrder & 0x20)!=0;\n\n  int MaxMB;\n  if (Reset)\n    MaxMB=UnpackRead->GetChar();\n  else\n    if (SubAlloc.GetAllocatedMemory()==0)\n      return(false);\n  if (MaxOrder & 0x40)\n    EscChar=UnpackRead->GetChar();\n  Coder.InitDecoder(UnpackRead);\n  if (Reset)\n  {\n    MaxOrder=(MaxOrder & 0x1f)+1;\n    if (MaxOrder>16)\n      MaxOrder=16+(MaxOrder-16)*3;\n    if (MaxOrder==1)\n    {\n      SubAlloc.StopSubAllocator();\n      return(false);\n    }\n    SubAlloc.StartSubAllocator(MaxMB+1);\n    StartModelRare(MaxOrder);\n  }\n  return(MinContext!=NULL);\n}\n\n\nint ModelPPM::DecodeChar()\n{\n  if ((byte*)MinContext <= SubAlloc.pText || (byte*)MinContext>SubAlloc.HeapEnd)\n    return(-1);\n  if (MinContext->NumStats != 1)      \n  {\n    if ((byte*)MinContext->U.Stats <= SubAlloc.pText || (byte*)MinContext->U.Stats>SubAlloc.HeapEnd)\n      return(-1);\n    if (!MinContext->decodeSymbol1(this))\n      return(-1);\n  }\n  else                                \n    MinContext->decodeBinSymbol(this);\n  Coder.Decode();\n  while ( !FoundState ) \n  {\n    ARI_DEC_NORMALIZE(Coder.code,Coder.low,Coder.range,Coder.UnpackRead);\n    do\n    {\n      OrderFall++;                \n      MinContext=MinContext->Suffix;\n      if ((byte*)MinContext <= SubAlloc.pText || (byte*)MinContext>SubAlloc.HeapEnd)\n        return(-1);\n    } while (MinContext->NumStats == NumMasked);\n    if (!MinContext->decodeSymbol2(this))\n      return(-1);\n    Coder.Decode();\n  }\n  int Symbol=FoundState->Symbol;\n  if (!OrderFall && (byte*) FoundState->Successor > SubAlloc.pText)\n    MinContext=MaxContext=FoundState->Successor;\n  else\n  {\n    UpdateModel();\n    if (EscCount == 0)\n      ClearMask();\n  }\n  ARI_DEC_NORMALIZE(Coder.code,Coder.low,Coder.range,Coder.UnpackRead);\n  return(Symbol);\n}\n","#ifndef _RAR_PPMMODEL_\n#define _RAR_PPMMODEL_\n\n#include \"coder.hpp\"\n#include \"suballoc.hpp\"\n\n#ifdef ALLOW_MISALIGNED\n#pragma pack(1)\n#endif\n\nstruct RARPPM_DEF\n{\n  static const int INT_BITS=7, PERIOD_BITS=7, TOT_BITS=INT_BITS+PERIOD_BITS,\n    INTERVAL=1 << INT_BITS, BIN_SCALE=1 << TOT_BITS, MAX_FREQ=124;\n};\n\nstruct RARPPM_SEE2_CONTEXT : RARPPM_DEF\n{ // SEE-contexts for PPM-contexts with masked symbols\n  ushort Summ;\n  byte Shift, Count;\n  void init(int InitVal)\n  {\n    Summ=InitVal << (Shift=PERIOD_BITS-4);\n    Count=4;\n  }\n  uint getMean()\n  {\n    uint RetVal=GET_SHORT16(Summ) >> Shift;\n    Summ -= RetVal;\n    return RetVal+(RetVal == 0);\n  }\n  void update()\n  {\n    if (Shift < PERIOD_BITS && --Count == 0)\n    {\n      Summ += Summ;\n      Count=3 << Shift++;\n    }\n  }\n};\n\n\nclass ModelPPM;\nstruct RARPPM_CONTEXT;\n\nstruct RARPPM_STATE\n{\n  byte Symbol;\n  byte Freq;\n  RARPPM_CONTEXT* Successor;\n};\n\n\nstruct RARPPM_CONTEXT : RARPPM_DEF\n{\n    ushort NumStats;\n\n    struct FreqData\n    {\n      ushort SummFreq;\n      RARPPM_STATE RARPPM_PACK_ATTR * Stats;\n    };\n    \n    union\n    {\n      FreqData U;\n      RARPPM_STATE OneState;\n    };\n\n    RARPPM_CONTEXT* Suffix;\n    inline void encodeBinSymbol(ModelPPM *Model,int symbol);  // MaxOrder:\n    inline void encodeSymbol1(ModelPPM *Model,int symbol);    //  ABCD    context\n    inline void encodeSymbol2(ModelPPM *Model,int symbol);    //   BCD    suffix\n    inline void decodeBinSymbol(ModelPPM *Model);  //   BCDE   successor\n    inline bool decodeSymbol1(ModelPPM *Model);    // other orders:\n    inline bool decodeSymbol2(ModelPPM *Model);    //   BCD    context\n    inline void update1(ModelPPM *Model,RARPPM_STATE* p); //    CD    suffix\n    inline void update2(ModelPPM *Model,RARPPM_STATE* p); //   BCDE   successor\n    void rescale(ModelPPM *Model);\n    inline RARPPM_CONTEXT* createChild(ModelPPM *Model,RARPPM_STATE* pStats,RARPPM_STATE& FirstState);\n    inline RARPPM_SEE2_CONTEXT* makeEscFreq2(ModelPPM *Model,int Diff);\n};\n\n#ifdef ALLOW_MISALIGNED\n#ifdef _AIX\n#pragma pack(pop)\n#else\n#pragma pack()\n#endif\n#endif\n\nclass ModelPPM : RARPPM_DEF\n{\n  private:\n    friend struct RARPPM_CONTEXT;\n    \n    RARPPM_SEE2_CONTEXT SEE2Cont[25][16], DummySEE2Cont;\n    \n    struct RARPPM_CONTEXT *MinContext, *MedContext, *MaxContext;\n    RARPPM_STATE* FoundState;      // found next state transition\n    int NumMasked, InitEsc, OrderFall, MaxOrder, RunLength, InitRL;\n    byte CharMask[256], NS2Indx[256], NS2BSIndx[256], HB2Flag[256];\n    byte EscCount, PrevSuccess, HiBitsFlag;\n    ushort BinSumm[128][64];               // binary SEE-contexts\n\n    RangeCoder Coder;\n    SubAllocator SubAlloc;\n\n    void RestartModelRare();\n    void StartModelRare(int MaxOrder);\n    inline RARPPM_CONTEXT* CreateSuccessors(bool Skip,RARPPM_STATE* p1);\n\n    inline void UpdateModel();\n    inline void ClearMask();\n  public:\n    ModelPPM();\n    void CleanUp(); // reset PPM variables after data error\n    bool DecodeInit(Unpack *UnpackRead,int &EscChar);\n    int DecodeChar();\n};\n\n#endif\n","#define STARTL1  2\nstatic unsigned int DecL1[]={0x8000,0xa000,0xc000,0xd000,0xe000,0xea00,\n                             0xee00,0xf000,0xf200,0xf200,0xffff};\nstatic unsigned int PosL1[]={0,0,0,2,3,5,7,11,16,20,24,32,32};\n\n#define STARTL2  3\nstatic unsigned int DecL2[]={0xa000,0xc000,0xd000,0xe000,0xea00,0xee00,\n                             0xf000,0xf200,0xf240,0xffff};\nstatic unsigned int PosL2[]={0,0,0,0,5,7,9,13,18,22,26,34,36};\n\n#define STARTHF0  4\nstatic unsigned int DecHf0[]={0x8000,0xc000,0xe000,0xf200,0xf200,0xf200,\n                              0xf200,0xf200,0xffff};\nstatic unsigned int PosHf0[]={0,0,0,0,0,8,16,24,33,33,33,33,33};\n\n\n#define STARTHF1  5\nstatic unsigned int DecHf1[]={0x2000,0xc000,0xe000,0xf000,0xf200,0xf200,\n                              0xf7e0,0xffff};\nstatic unsigned int PosHf1[]={0,0,0,0,0,0,4,44,60,76,80,80,127};\n\n\n#define STARTHF2  5\nstatic unsigned int DecHf2[]={0x1000,0x2400,0x8000,0xc000,0xfa00,0xffff,\n                              0xffff,0xffff};\nstatic unsigned int PosHf2[]={0,0,0,0,0,0,2,7,53,117,233,0,0};\n\n\n#define STARTHF3  6\nstatic unsigned int DecHf3[]={0x800,0x2400,0xee00,0xfe80,0xffff,0xffff,\n                              0xffff};\nstatic unsigned int PosHf3[]={0,0,0,0,0,0,0,2,16,218,251,0,0};\n\n\n#define STARTHF4  8\nstatic unsigned int DecHf4[]={0xff00,0xffff,0xffff,0xffff,0xffff,0xffff};\nstatic unsigned int PosHf4[]={0,0,0,0,0,0,0,0,0,255,0,0,0};\n\n\nvoid Unpack::Unpack15(bool Solid)\n{\n  UnpInitData(Solid);\n  UnpInitData15(Solid);\n  UnpReadBuf();\n  if (!Solid)\n  {\n    InitHuff();\n    UnpPtr=0;\n  }\n  else\n    UnpPtr=WrPtr;\n  --DestUnpSize;\n  if (DestUnpSize>=0)\n  {\n    GetFlagsBuf();\n    FlagsCnt=8;\n  }\n\n  while (DestUnpSize>=0)\n  {\n    UnpPtr&=MaxWinMask;\n\n    if (Inp.InAddr>ReadTop-30 && !UnpReadBuf())\n      break;\n    if (((WrPtr-UnpPtr) & MaxWinMask)<270 && WrPtr!=UnpPtr)\n      UnpWriteBuf20();\n    if (StMode)\n    {\n      HuffDecode();\n      continue;\n    }\n\n    if (--FlagsCnt < 0)\n    {\n      GetFlagsBuf();\n      FlagsCnt=7;\n    }\n\n    if (FlagBuf & 0x80)\n    {\n      FlagBuf<<=1;\n      if (Nlzb > Nhfb)\n        LongLZ();\n      else\n        HuffDecode();\n    }\n    else\n    {\n      FlagBuf<<=1;\n      if (--FlagsCnt < 0)\n      {\n        GetFlagsBuf();\n        FlagsCnt=7;\n      }\n      if (FlagBuf & 0x80)\n      {\n        FlagBuf<<=1;\n        if (Nlzb > Nhfb)\n          HuffDecode();\n        else\n          LongLZ();\n      }\n      else\n      {\n        FlagBuf<<=1;\n        ShortLZ();\n      }\n    }\n  }\n  UnpWriteBuf20();\n}\n\n\n#define GetShortLen1(pos) ((pos)==1 ? Buf60+3:ShortLen1[pos])\n#define GetShortLen2(pos) ((pos)==3 ? Buf60+3:ShortLen2[pos])\n\nvoid Unpack::ShortLZ()\n{\n  static unsigned int ShortLen1[]={1,3,4,4,5,6,7,8,8,4,4,5,6,6,4,0};\n  static unsigned int ShortXor1[]={0,0xa0,0xd0,0xe0,0xf0,0xf8,0xfc,0xfe,\n                                   0xff,0xc0,0x80,0x90,0x98,0x9c,0xb0};\n  static unsigned int ShortLen2[]={2,3,3,3,4,4,5,6,6,4,4,5,6,6,4,0};\n  static unsigned int ShortXor2[]={0,0x40,0x60,0xa0,0xd0,0xe0,0xf0,0xf8,\n                                   0xfc,0xc0,0x80,0x90,0x98,0x9c,0xb0};\n\n\n  unsigned int Length,SaveLength;\n  unsigned int LastDistance;\n  unsigned int Distance;\n  int DistancePlace;\n  NumHuf=0;\n\n  unsigned int BitField=Inp.fgetbits();\n  if (LCount==2)\n  {\n    Inp.faddbits(1);\n    if (BitField >= 0x8000)\n    {\n      CopyString15((unsigned int)LastDist,LastLength);\n      return;\n    }\n    BitField <<= 1;\n    LCount=0;\n  }\n\n  BitField>>=8;\n\n//  not thread safe, replaced by GetShortLen1 and GetShortLen2 macro\n//  ShortLen1[1]=ShortLen2[3]=Buf60+3;\n\n  if (AvrLn1<37)\n  {\n    for (Length=0;;Length++)\n      if (((BitField^ShortXor1[Length]) & (~(0xff>>GetShortLen1(Length))))==0)\n        break;\n    Inp.faddbits(GetShortLen1(Length));\n  }\n  else\n  {\n    for (Length=0;;Length++)\n      if (((BitField^ShortXor2[Length]) & (~(0xff>>GetShortLen2(Length))))==0)\n        break;\n    Inp.faddbits(GetShortLen2(Length));\n  }\n\n  if (Length >= 9)\n  {\n    if (Length == 9)\n    {\n      LCount++;\n      CopyString15((unsigned int)LastDist,LastLength);\n      return;\n    }\n    if (Length == 14)\n    {\n      LCount=0;\n      Length=DecodeNum(Inp.fgetbits(),STARTL2,DecL2,PosL2)+5;\n      Distance=(Inp.fgetbits()>>1) | 0x8000;\n      Inp.faddbits(15);\n      LastLength=Length;\n      LastDist=Distance;\n      CopyString15(Distance,Length);\n      return;\n    }\n\n    LCount=0;\n    SaveLength=Length;\n    Distance=OldDist[(OldDistPtr-(Length-9)) & 3];\n    Length=DecodeNum(Inp.fgetbits(),STARTL1,DecL1,PosL1)+2;\n    if (Length==0x101 && SaveLength==10)\n    {\n      Buf60 ^= 1;\n      return;\n    }\n    if (Distance > 256)\n      Length++;\n    if (Distance >= MaxDist3)\n      Length++;\n\n    OldDist[OldDistPtr++]=Distance;\n    OldDistPtr = OldDistPtr & 3;\n    LastLength=Length;\n    LastDist=Distance;\n    CopyString15(Distance,Length);\n    return;\n  }\n\n  LCount=0;\n  AvrLn1 += Length;\n  AvrLn1 -= AvrLn1 >> 4;\n\n  DistancePlace=DecodeNum(Inp.fgetbits(),STARTHF2,DecHf2,PosHf2) & 0xff;\n  Distance=ChSetA[DistancePlace];\n  if (--DistancePlace != -1)\n  {\n    LastDistance=ChSetA[DistancePlace];\n    ChSetA[DistancePlace+1]=LastDistance;\n    ChSetA[DistancePlace]=Distance;\n  }\n  Length+=2;\n  OldDist[OldDistPtr++] = ++Distance;\n  OldDistPtr = OldDistPtr & 3;\n  LastLength=Length;\n  LastDist=Distance;\n  CopyString15(Distance,Length);\n}\n\n\nvoid Unpack::LongLZ()\n{\n  unsigned int Length;\n  unsigned int Distance;\n  unsigned int DistancePlace,NewDistancePlace;\n  unsigned int OldAvr2,OldAvr3;\n\n  NumHuf=0;\n  Nlzb+=16;\n  if (Nlzb > 0xff)\n  {\n    Nlzb=0x90;\n    Nhfb >>= 1;\n  }\n  OldAvr2=AvrLn2;\n\n  unsigned int BitField=Inp.fgetbits();\n  if (AvrLn2 >= 122)\n    Length=DecodeNum(BitField,STARTL2,DecL2,PosL2);\n  else\n    if (AvrLn2 >= 64)\n      Length=DecodeNum(BitField,STARTL1,DecL1,PosL1);\n    else\n      if (BitField < 0x100)\n      {\n        Length=BitField;\n        Inp.faddbits(16);\n      }\n      else\n      {\n        for (Length=0;((BitField<<Length)&0x8000)==0;Length++)\n          ;\n        Inp.faddbits(Length+1);\n      }\n\n  AvrLn2 += Length;\n  AvrLn2 -= AvrLn2 >> 5;\n\n  BitField=Inp.fgetbits();\n  if (AvrPlcB > 0x28ff)\n    DistancePlace=DecodeNum(BitField,STARTHF2,DecHf2,PosHf2);\n  else\n    if (AvrPlcB > 0x6ff)\n      DistancePlace=DecodeNum(BitField,STARTHF1,DecHf1,PosHf1);\n    else\n      DistancePlace=DecodeNum(BitField,STARTHF0,DecHf0,PosHf0);\n\n  AvrPlcB += DistancePlace;\n  AvrPlcB -= AvrPlcB >> 8;\n  while (1)\n  {\n    Distance = ChSetB[DistancePlace & 0xff];\n    NewDistancePlace = NToPlB[Distance++ & 0xff]++;\n    if (!(Distance & 0xff))\n      CorrHuff(ChSetB,NToPlB);\n    else\n      break;\n  }\n\n  ChSetB[DistancePlace]=ChSetB[NewDistancePlace];\n  ChSetB[NewDistancePlace]=Distance;\n\n  Distance=((Distance & 0xff00) | (Inp.fgetbits() >> 8)) >> 1;\n  Inp.faddbits(7);\n\n  OldAvr3=AvrLn3;\n  if (Length!=1 && Length!=4)\n    if (Length==0 && Distance <= MaxDist3)\n    {\n      AvrLn3++;\n      AvrLn3 -= AvrLn3 >> 8;\n    }\n    else\n      if (AvrLn3 > 0)\n        AvrLn3--;\n  Length+=3;\n  if (Distance >= MaxDist3)\n    Length++;\n  if (Distance <= 256)\n    Length+=8;\n  if (OldAvr3 > 0xb0 || AvrPlc >= 0x2a00 && OldAvr2 < 0x40)\n    MaxDist3=0x7f00;\n  else\n    MaxDist3=0x2001;\n  OldDist[OldDistPtr++]=Distance;\n  OldDistPtr = OldDistPtr & 3;\n  LastLength=Length;\n  LastDist=Distance;\n  CopyString15(Distance,Length);\n}\n\n\nvoid Unpack::HuffDecode()\n{\n  unsigned int CurByte,NewBytePlace;\n  unsigned int Length;\n  unsigned int Distance;\n  int BytePlace;\n\n  unsigned int BitField=Inp.fgetbits();\n\n  if (AvrPlc > 0x75ff)\n    BytePlace=DecodeNum(BitField,STARTHF4,DecHf4,PosHf4);\n  else\n    if (AvrPlc > 0x5dff)\n      BytePlace=DecodeNum(BitField,STARTHF3,DecHf3,PosHf3);\n    else\n      if (AvrPlc > 0x35ff)\n        BytePlace=DecodeNum(BitField,STARTHF2,DecHf2,PosHf2);\n      else\n        if (AvrPlc > 0x0dff)\n          BytePlace=DecodeNum(BitField,STARTHF1,DecHf1,PosHf1);\n        else\n          BytePlace=DecodeNum(BitField,STARTHF0,DecHf0,PosHf0);\n  BytePlace&=0xff;\n  if (StMode)\n  {\n    if (BytePlace==0 && BitField > 0xfff)\n      BytePlace=0x100;\n    if (--BytePlace==-1)\n    {\n      BitField=Inp.fgetbits();\n      Inp.faddbits(1);\n      if (BitField & 0x8000)\n      {\n        NumHuf=StMode=0;\n        return;\n      }\n      else\n      {\n        Length = (BitField & 0x4000) ? 4 : 3;\n        Inp.faddbits(1);\n        Distance=DecodeNum(Inp.fgetbits(),STARTHF2,DecHf2,PosHf2);\n        Distance = (Distance << 5) | (Inp.fgetbits() >> 11);\n        Inp.faddbits(5);\n        CopyString15(Distance,Length);\n        return;\n      }\n    }\n  }\n  else\n    if (NumHuf++ >= 16 && FlagsCnt==0)\n      StMode=1;\n  AvrPlc += BytePlace;\n  AvrPlc -= AvrPlc >> 8;\n  Nhfb+=16;\n  if (Nhfb > 0xff)\n  {\n    Nhfb=0x90;\n    Nlzb >>= 1;\n  }\n\n  Window[UnpPtr++]=(byte)(ChSet[BytePlace]>>8);\n  --DestUnpSize;\n\n  while (1)\n  {\n    CurByte=ChSet[BytePlace];\n    NewBytePlace=NToPl[CurByte++ & 0xff]++;\n    if ((CurByte & 0xff) > 0xa1)\n      CorrHuff(ChSet,NToPl);\n    else\n      break;\n  }\n\n  ChSet[BytePlace]=ChSet[NewBytePlace];\n  ChSet[NewBytePlace]=CurByte;\n}\n\n\nvoid Unpack::GetFlagsBuf()\n{\n  unsigned int Flags,NewFlagsPlace;\n  unsigned int FlagsPlace=DecodeNum(Inp.fgetbits(),STARTHF2,DecHf2,PosHf2);\n\n  // Our Huffman table stores 257 items and needs all them in other parts\n  // of code such as when StMode is on, so the first item is control item.\n  // While normally we do not use the last item to code the flags byte here,\n  // we need to check for value 256 when unpacking in case we unpack\n  // a corrupt archive.\n  if (FlagsPlace>=sizeof(ChSetC)/sizeof(ChSetC[0]))\n    return;\n\n  while (1)\n  {\n    Flags=ChSetC[FlagsPlace];\n    FlagBuf=Flags>>8;\n    NewFlagsPlace=NToPlC[Flags++ & 0xff]++;\n    if ((Flags & 0xff) != 0)\n      break;\n    CorrHuff(ChSetC,NToPlC);\n  }\n\n  ChSetC[FlagsPlace]=ChSetC[NewFlagsPlace];\n  ChSetC[NewFlagsPlace]=Flags;\n}\n\n\nvoid Unpack::UnpInitData15(int Solid)\n{\n  if (!Solid)\n  {\n    AvrPlcB=AvrLn1=AvrLn2=AvrLn3=NumHuf=Buf60=0;\n    AvrPlc=0x3500;\n    MaxDist3=0x2001;\n    Nhfb=Nlzb=0x80;\n  }\n  FlagsCnt=0;\n  FlagBuf=0;\n  StMode=0;\n  LCount=0;\n  ReadTop=0;\n}\n\n\nvoid Unpack::InitHuff()\n{\n  for (unsigned int I=0;I<256;I++)\n  {\n    ChSet[I]=ChSetB[I]=I<<8;\n    ChSetA[I]=I;\n    ChSetC[I]=((~I+1) & 0xff)<<8;\n  }\n  memset(NToPl,0,sizeof(NToPl));\n  memset(NToPlB,0,sizeof(NToPlB));\n  memset(NToPlC,0,sizeof(NToPlC));\n  CorrHuff(ChSetB,NToPlB);\n}\n\n\nvoid Unpack::CorrHuff(ushort *CharSet,byte *NumToPlace)\n{\n  int I,J;\n  for (I=7;I>=0;I--)\n    for (J=0;J<32;J++,CharSet++)\n      *CharSet=(*CharSet & ~0xff) | I;\n  memset(NumToPlace,0,sizeof(NToPl));\n  for (I=6;I>=0;I--)\n    NumToPlace[I]=(7-I)*32;\n}\n\n\nvoid Unpack::CopyString15(uint Distance,uint Length)\n{\n  DestUnpSize-=Length;\n  while (Length--)\n  {\n    Window[UnpPtr]=Window[(UnpPtr-Distance) & MaxWinMask];\n    UnpPtr=(UnpPtr+1) & MaxWinMask;\n  }\n}\n\n\nuint Unpack::DecodeNum(uint Num,uint StartPos,uint *DecTab,uint *PosTab)\n{\n  int I;\n  for (Num&=0xfff0,I=0;DecTab[I]<=Num;I++)\n    StartPos++;\n  Inp.faddbits(StartPos);\n  return(((Num-(I ? DecTab[I-1]:0))>>(16-StartPos))+PosTab[StartPos]);\n}\n","#include \"rar.hpp\"\n\n#include \"coder.cpp\"\n#include \"suballoc.cpp\"\n#include \"model.cpp\"\n#include \"unpackinline.cpp\"\n#ifdef RAR_SMP\n#include \"unpack50mt.cpp\"\n#endif\n#ifndef SFX_MODULE\n#include \"unpack15.cpp\"\n#include \"unpack20.cpp\"\n#endif\n#include \"unpack30.cpp\"\n#include \"unpack50.cpp\"\n#include \"unpack50frag.cpp\"\n\nUnpack::Unpack(ComprDataIO *DataIO)\n:Inp(true),VMCodeInp(true)\n{\n  UnpIO=DataIO;\n  Window=NULL;\n  Fragmented=false;\n  Suspended=false;\n  UnpAllBuf=false;\n  UnpSomeRead=false;\n#ifdef RAR_SMP\n  MaxUserThreads=1;\n  UnpThreadPool=CreateThreadPool();\n  ReadBufMT=NULL;\n  UnpThreadData=NULL;\n#endif\n  MaxWinSize=0;\n  MaxWinMask=0;\n\n  // Perform initialization, which should be done only once for all files.\n  // It prevents crash if first DoUnpack call is later made with wrong\n  // (true) 'Solid' value.\n  UnpInitData(false);\n#ifndef SFX_MODULE\n  // RAR 1.5 decompression initialization\n  UnpInitData15(false);\n  InitHuff();\n#endif\n}\n\n\nUnpack::~Unpack()\n{\n  InitFilters30(false);\n\n  if (Window!=NULL)\n    free(Window);\n#ifdef RAR_SMP\n  DestroyThreadPool(UnpThreadPool);\n  delete[] ReadBufMT;\n  delete[] UnpThreadData;\n#endif\n}\n\n\nvoid Unpack::Init(size_t WinSize,bool Solid)\n{\n  // If 32-bit RAR unpacks an archive with 4 GB dictionary, the window size\n  // will be 0 because of size_t overflow. Let's issue the memory error.\n  if (WinSize==0)\n    ErrHandler.MemoryError();\n\n  // Minimum window size must be at least twice more than maximum possible\n  // size of filter block, which is 0x10000 in RAR now. If window size is\n  // smaller, we can have a block with never cleared flt->NextWindow flag\n  // in UnpWriteBuf(). Minimum window size 0x20000 would be enough, but let's\n  // use 0x40000 for extra safety and possible filter area size expansion.\n  const size_t MinAllocSize=0x40000;\n  if (WinSize<MinAllocSize)\n    WinSize=MinAllocSize;\n\n  if (WinSize<=MaxWinSize) // Use the already allocated window.\n    return;\n  if ((WinSize>>16)>0x10000) // Window size must not exceed 4 GB.\n    return;\n\n  // Archiving code guarantees that window size does not grow in the same\n  // solid stream. So if we are here, we are either creating a new window\n  // or increasing the size of non-solid window. So we could safely reject\n  // current window data without copying them to a new window, though being\n  // extra cautious, we still handle the solid window grow case below.\n  bool Grow=Solid && (Window!=NULL || Fragmented);\n\n  // We do not handle growth for existing fragmented window.\n  if (Grow && Fragmented)\n    throw std::bad_alloc();\n\n  byte *NewWindow=Fragmented ? NULL : (byte *)malloc(WinSize);\n\n  if (NewWindow==NULL)\n    if (Grow || WinSize<0x1000000)\n    {\n      // We do not support growth for new fragmented window.\n      // Also exclude RAR4 and small dictionaries.\n      throw std::bad_alloc();\n    }\n    else\n    {\n      if (Window!=NULL) // If allocated by preceding files.\n      {\n        free(Window);\n        Window=NULL;\n      }\n      FragWindow.Init(WinSize);\n      Fragmented=true;\n    }\n\n  if (!Fragmented)\n  {\n    // Clean the window to generate the same output when unpacking corrupt\n    // RAR files, which may access unused areas of sliding dictionary.\n    memset(NewWindow,0,WinSize);\n\n    // If Window is not NULL, it means that window size has grown.\n    // In solid streams we need to copy data to a new window in such case.\n    // RAR archiving code does not allow it in solid streams now,\n    // but let's implement it anyway just in case we'll change it sometimes.\n    if (Grow)\n      for (size_t I=1;I<=MaxWinSize;I++)\n        NewWindow[(UnpPtr-I)&(WinSize-1)]=Window[(UnpPtr-I)&(MaxWinSize-1)];\n\n    if (Window!=NULL)\n      free(Window);\n    Window=NewWindow;\n  }\n\n  MaxWinSize=WinSize;\n  MaxWinMask=MaxWinSize-1;\n}\n\n\nvoid Unpack::DoUnpack(int Method,bool Solid)\n{\n  // Methods <50 will crash in Fragmented mode when accessing NULL Window.\n  // They cannot be called in such mode now, but we check it below anyway\n  // just for extra safety.\n  switch(Method)\n  {\n#ifndef SFX_MODULE\n    case 15: // rar 1.5 compression\n      if (!Fragmented)\n        Unpack15(Solid);\n      break;\n    case 20: // rar 2.x compression\n    case 26: // files larger than 2GB\n      if (!Fragmented)\n        Unpack20(Solid);\n      break;\n#endif\n    case 29: // rar 3.x compression\n      if (!Fragmented)\n        Unpack29(Solid);\n      break;\n    case 50: // RAR 5.0 compression algorithm.\n#ifdef RAR_SMP\n      if (MaxUserThreads>1)\n      {\n//      We do not use the multithreaded unpack routine to repack RAR archives\n//      in 'suspended' mode, because unlike the single threaded code it can\n//      write more than one dictionary for same loop pass. So we would need\n//      larger buffers of unknown size. Also we do not support multithreading\n//      in fragmented window mode.\n          if (!Fragmented)\n          {\n            Unpack5MT(Solid);\n            break;\n          }\n      }\n#endif\n      Unpack5(Solid);\n      break;\n  }\n}\n\n\nvoid Unpack::UnpInitData(bool Solid)\n{\n  if (!Solid)\n  {\n    memset(OldDist,0,sizeof(OldDist));\n    OldDistPtr=0;\n    LastDist=LastLength=0;\n//    memset(Window,0,MaxWinSize);\n    memset(&BlockTables,0,sizeof(BlockTables));\n    UnpPtr=WrPtr=0;\n    WriteBorder=Min(MaxWinSize,UNPACK_MAX_WRITE)&MaxWinMask;\n  }\n  // Filters never share several solid files, so we can safely reset them\n  // even in solid archive.\n  InitFilters();\n\n  Inp.InitBitInput();\n  WrittenFileSize=0;\n  ReadTop=0;\n  ReadBorder=0;\n\n  memset(&BlockHeader,0,sizeof(BlockHeader));\n  BlockHeader.BlockSize=-1;  // '-1' means not defined yet.\n#ifndef SFX_MODULE\n  UnpInitData20(Solid);\n#endif\n  UnpInitData30(Solid);\n}\n\n\n// LengthTable contains the length in bits for every element of alphabet.\n// Dec is the structure to decode Huffman code/\n// Size is size of length table and DecodeNum field in Dec structure,\nvoid Unpack::MakeDecodeTables(byte *LengthTable,DecodeTable *Dec,uint Size)\n{\n  // Size of alphabet and DecodePos array.\n  Dec->MaxNum=Size;\n\n  // Calculate how many entries for every bit length in LengthTable we have.\n  uint LengthCount[16];\n  memset(LengthCount,0,sizeof(LengthCount));\n  for (size_t I=0;I<Size;I++)\n    LengthCount[LengthTable[I] & 0xf]++;\n\n  // We must not calculate the number of zero length codes.\n  LengthCount[0]=0;\n\n  // Set the entire DecodeNum to zero.\n  memset(Dec->DecodeNum,0,Size*sizeof(*Dec->DecodeNum));\n\n  // Initialize not really used entry for zero length code.\n  Dec->DecodePos[0]=0;\n\n  // Start code for bit length 1 is 0.\n  Dec->DecodeLen[0]=0;\n\n  // Right aligned upper limit code for current bit length.\n  uint UpperLimit=0;\n\n  for (size_t I=1;I<16;I++)\n  {\n    // Adjust the upper limit code.\n    UpperLimit+=LengthCount[I];\n\n    // Left aligned upper limit code.\n    uint LeftAligned=UpperLimit<<(16-I);\n\n    // Prepare the upper limit code for next bit length.\n    UpperLimit*=2;\n\n    // Store the left aligned upper limit code.\n    Dec->DecodeLen[I]=(uint)LeftAligned;\n\n    // Every item of this array contains the sum of all preceding items.\n    // So it contains the start position in code list for every bit length. \n    Dec->DecodePos[I]=Dec->DecodePos[I-1]+LengthCount[I-1];\n  }\n\n  // Prepare the copy of DecodePos. We'll modify this copy below,\n  // so we cannot use the original DecodePos.\n  uint CopyDecodePos[16];\n  memcpy(CopyDecodePos,Dec->DecodePos,sizeof(CopyDecodePos));\n\n  // For every bit length in the bit length table and so for every item\n  // of alphabet.\n  for (uint I=0;I<Size;I++)\n  {\n    // Get the current bit length.\n    byte CurBitLength=LengthTable[I] & 0xf;\n\n    if (CurBitLength!=0)\n    {\n      // Last position in code list for current bit length.\n      uint LastPos=CopyDecodePos[CurBitLength];\n\n      // Prepare the decode table, so this position in code list will be\n      // decoded to current alphabet item number.\n      Dec->DecodeNum[LastPos]=(ushort)I;\n\n      // We'll use next position number for this bit length next time.\n      // So we pass through the entire range of positions available\n      // for every bit length.\n      CopyDecodePos[CurBitLength]++;\n    }\n  }\n\n  // Define the number of bits to process in quick mode. We use more bits\n  // for larger alphabets. More bits means that more codes will be processed\n  // in quick mode, but also that more time will be spent to preparation\n  // of tables for quick decode.\n  switch (Size)\n  {\n    case NC:\n    case NC20:\n    case NC30:\n      Dec->QuickBits=MAX_QUICK_DECODE_BITS;\n      break;\n    default:\n      Dec->QuickBits=MAX_QUICK_DECODE_BITS-3;\n      break;\n  }\n\n  // Size of tables for quick mode.\n  uint QuickDataSize=1<<Dec->QuickBits;\n\n  // Bit length for current code, start from 1 bit codes. It is important\n  // to use 1 bit instead of 0 for minimum code length, so we are moving\n  // forward even when processing a corrupt archive.\n  uint CurBitLength=1;\n\n  // For every right aligned bit string which supports the quick decoding.\n  for (uint Code=0;Code<QuickDataSize;Code++)\n  {\n    // Left align the current code, so it will be in usual bit field format.\n    uint BitField=Code<<(16-Dec->QuickBits);\n\n    // Prepare the table for quick decoding of bit lengths.\n  \n    // Find the upper limit for current bit field and adjust the bit length\n    // accordingly if necessary.\n    while (CurBitLength<ASIZE(Dec->DecodeLen) && BitField>=Dec->DecodeLen[CurBitLength])\n      CurBitLength++;\n\n    // Translation of right aligned bit string to bit length.\n    Dec->QuickLen[Code]=CurBitLength;\n\n    // Prepare the table for quick translation of position in code list\n    // to position in alphabet.\n\n    // Calculate the distance from the start code for current bit length.\n    uint Dist=BitField-Dec->DecodeLen[CurBitLength-1];\n\n    // Right align the distance.\n    Dist>>=(16-CurBitLength);\n\n    // Now we can calculate the position in the code list. It is the sum\n    // of first position for current bit length and right aligned distance\n    // between our bit field and start code for current bit length.\n    uint Pos=Dec->DecodePos[CurBitLength]+Dist;\n\n    if (Pos<Size) // Safety check for damaged archives.\n    {\n      // Define the code to alphabet number translation.\n      Dec->QuickNum[Code]=Dec->DecodeNum[Pos];\n    }\n    else\n      Dec->QuickNum[Code]=0;\n  }\n}\n","#include \"rar.hpp\"\n\nvoid Unpack::CopyString20(uint Length,uint Distance)\n{\n  LastDist=OldDist[OldDistPtr++ & 3]=Distance;\n  LastLength=Length;\n  DestUnpSize-=Length;\n  CopyString(Length,Distance);\n}\n\n\nvoid Unpack::Unpack20(bool Solid)\n{\n  static unsigned char LDecode[]={0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224};\n  static unsigned char LBits[]=  {0,0,0,0,0,0,0,0,1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5};\n  static int DDecode[]={0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576,32768U,49152U,65536,98304,131072,196608,262144,327680,393216,458752,524288,589824,655360,720896,786432,851968,917504,983040};\n  static unsigned char DBits[]=  {0,0,0,0,1,1,2, 2, 3, 3, 4, 4, 5, 5,  6,  6,  7,  7,  8,  8,   9,   9,  10,  10,  11,  11,  12,   12,   13,   13,    14,    14,   15,   15,    16,    16,    16,    16,    16,    16,    16,    16,    16,    16,    16,    16,    16,    16};\n  static unsigned char SDDecode[]={0,4,8,16,32,64,128,192};\n  static unsigned char SDBits[]=  {2,2,3, 4, 5, 6,  6,  6};\n  unsigned int Bits;\n\n  if (Suspended)\n    UnpPtr=WrPtr;\n  else\n  {\n    UnpInitData(Solid);\n    if (!UnpReadBuf())\n      return;\n    if (!Solid)\n      if (!ReadTables20())\n        return;\n    --DestUnpSize;\n  }\n\n  while (DestUnpSize>=0)\n  {\n    UnpPtr&=MaxWinMask;\n\n    if (Inp.InAddr>ReadTop-30)\n      if (!UnpReadBuf())\n        break;\n    if (((WrPtr-UnpPtr) & MaxWinMask)<270 && WrPtr!=UnpPtr)\n    {\n      UnpWriteBuf20();\n      if (Suspended)\n        return;\n    }\n    if (UnpAudioBlock)\n    {\n      int AudioNumber=DecodeNumber(Inp,&MD[UnpCurChannel]);\n\n      if (AudioNumber==256)\n      {\n        if (!ReadTables20())\n          break;\n        continue;\n      }\n      Window[UnpPtr++]=DecodeAudio(AudioNumber);\n      if (++UnpCurChannel==UnpChannels)\n        UnpCurChannel=0;\n      --DestUnpSize;\n      continue;\n    }\n\n    int Number=DecodeNumber(Inp,&BlockTables.LD);\n    if (Number<256)\n    {\n      Window[UnpPtr++]=(byte)Number;\n      --DestUnpSize;\n      continue;\n    }\n    if (Number>269)\n    {\n      int Length=LDecode[Number-=270]+3;\n      if ((Bits=LBits[Number])>0)\n      {\n        Length+=Inp.getbits()>>(16-Bits);\n        Inp.addbits(Bits);\n      }\n\n      int DistNumber=DecodeNumber(Inp,&BlockTables.DD);\n      unsigned int Distance=DDecode[DistNumber]+1;\n      if ((Bits=DBits[DistNumber])>0)\n      {\n        Distance+=Inp.getbits()>>(16-Bits);\n        Inp.addbits(Bits);\n      }\n\n      if (Distance>=0x2000)\n      {\n        Length++;\n        if (Distance>=0x40000L)\n          Length++;\n      }\n\n      CopyString20(Length,Distance);\n      continue;\n    }\n    if (Number==269)\n    {\n      if (!ReadTables20())\n        break;\n      continue;\n    }\n    if (Number==256)\n    {\n      CopyString20(LastLength,LastDist);\n      continue;\n    }\n    if (Number<261)\n    {\n      unsigned int Distance=OldDist[(OldDistPtr-(Number-256)) & 3];\n      int LengthNumber=DecodeNumber(Inp,&BlockTables.RD);\n      int Length=LDecode[LengthNumber]+2;\n      if ((Bits=LBits[LengthNumber])>0)\n      {\n        Length+=Inp.getbits()>>(16-Bits);\n        Inp.addbits(Bits);\n      }\n      if (Distance>=0x101)\n      {\n        Length++;\n        if (Distance>=0x2000)\n        {\n          Length++;\n          if (Distance>=0x40000)\n            Length++;\n        }\n      }\n      CopyString20(Length,Distance);\n      continue;\n    }\n    if (Number<270)\n    {\n      unsigned int Distance=SDDecode[Number-=261]+1;\n      if ((Bits=SDBits[Number])>0)\n      {\n        Distance+=Inp.getbits()>>(16-Bits);\n        Inp.addbits(Bits);\n      }\n      CopyString20(2,Distance);\n      continue;\n   }\n  }\n  ReadLastTables();\n  UnpWriteBuf20();\n}\n\n\nvoid Unpack::UnpWriteBuf20()\n{\n  if (UnpPtr!=WrPtr)\n    UnpSomeRead=true;\n  if (UnpPtr<WrPtr)\n  {\n    UnpIO->UnpWrite(&Window[WrPtr],-(int)WrPtr & MaxWinMask);\n    UnpIO->UnpWrite(Window,UnpPtr);\n    UnpAllBuf=true;\n  }\n  else\n    UnpIO->UnpWrite(&Window[WrPtr],UnpPtr-WrPtr);\n  WrPtr=UnpPtr;\n}\n\n\nbool Unpack::ReadTables20()\n{\n  byte BitLength[BC20];\n  byte Table[MC20*4];\n  int TableSize,N,I;\n  if (Inp.InAddr>ReadTop-25)\n    if (!UnpReadBuf())\n      return(false);\n  uint BitField=Inp.getbits();\n  UnpAudioBlock=(BitField & 0x8000);\n\n  if (!(BitField & 0x4000))\n    memset(UnpOldTable20,0,sizeof(UnpOldTable20));\n  Inp.addbits(2);\n\n  if (UnpAudioBlock)\n  {\n    UnpChannels=((BitField>>12) & 3)+1;\n    if (UnpCurChannel>=UnpChannels)\n      UnpCurChannel=0;\n    Inp.addbits(2);\n    TableSize=MC20*UnpChannels;\n  }\n  else\n    TableSize=NC20+DC20+RC20;\n\n  for (I=0;I<BC20;I++)\n  {\n    BitLength[I]=(byte)(Inp.getbits() >> 12);\n    Inp.addbits(4);\n  }\n  MakeDecodeTables(BitLength,&BlockTables.BD,BC20);\n  I=0;\n  while (I<TableSize)\n  {\n    if (Inp.InAddr>ReadTop-5)\n      if (!UnpReadBuf())\n        return false;\n    int Number=DecodeNumber(Inp,&BlockTables.BD);\n    if (Number<16)\n    {\n      Table[I]=(Number+UnpOldTable20[I]) & 0xf;\n      I++;\n    }\n    else\n      if (Number==16)\n      {\n        N=(Inp.getbits() >> 14)+3;\n        Inp.addbits(2);\n        if (I>0)\n          while (N-- > 0 && I<TableSize)\n          {\n            Table[I]=Table[I-1];\n            I++;\n          }\n      }\n      else\n      {\n        if (Number==17)\n        {\n          N=(Inp.getbits() >> 13)+3;\n          Inp.addbits(3);\n        }\n        else\n        {\n          N=(Inp.getbits() >> 9)+11;\n          Inp.addbits(7);\n        }\n        while (N-- > 0 && I<TableSize)\n          Table[I++]=0;\n      }\n  }\n  if (Inp.InAddr>ReadTop)\n    return(true);\n  if (UnpAudioBlock)\n    for (I=0;I<UnpChannels;I++)\n      MakeDecodeTables(&Table[I*MC20],&MD[I],MC20);\n  else\n  {\n    MakeDecodeTables(&Table[0],&BlockTables.LD,NC20);\n    MakeDecodeTables(&Table[NC20],&BlockTables.DD,DC20);\n    MakeDecodeTables(&Table[NC20+DC20],&BlockTables.RD,RC20);\n  }\n  memcpy(UnpOldTable20,Table,sizeof(UnpOldTable20));\n  return(true);\n}\n\n\nvoid Unpack::ReadLastTables()\n{\n  if (ReadTop>=Inp.InAddr+5)\n    if (UnpAudioBlock)\n    {\n      if (DecodeNumber(Inp,&MD[UnpCurChannel])==256)\n        ReadTables20();\n    }\n    else\n      if (DecodeNumber(Inp,&BlockTables.LD)==269)\n        ReadTables20();\n}\n\n\nvoid Unpack::UnpInitData20(int Solid)\n{\n  if (!Solid)\n  {\n    UnpAudioBlock=UnpChannelDelta=UnpCurChannel=0;\n    UnpChannels=1;\n\n    memset(AudV,0,sizeof(AudV));\n    memset(UnpOldTable20,0,sizeof(UnpOldTable20));\n    memset(MD,0,sizeof(MD));\n  }\n}\n\n\nbyte Unpack::DecodeAudio(int Delta)\n{\n  struct AudioVariables *V=&AudV[UnpCurChannel];\n  V->ByteCount++;\n  V->D4=V->D3;\n  V->D3=V->D2;\n  V->D2=V->LastDelta-V->D1;\n  V->D1=V->LastDelta;\n  int PCh=8*V->LastChar+V->K1*V->D1+V->K2*V->D2+V->K3*V->D3+V->K4*V->D4+V->K5*UnpChannelDelta;\n  PCh=(PCh>>3) & 0xFF;\n\n  unsigned int Ch=PCh-Delta;\n\n  int D=((signed char)Delta)<<3;\n\n  V->Dif[0]+=abs(D);\n  V->Dif[1]+=abs(D-V->D1);\n  V->Dif[2]+=abs(D+V->D1);\n  V->Dif[3]+=abs(D-V->D2);\n  V->Dif[4]+=abs(D+V->D2);\n  V->Dif[5]+=abs(D-V->D3);\n  V->Dif[6]+=abs(D+V->D3);\n  V->Dif[7]+=abs(D-V->D4);\n  V->Dif[8]+=abs(D+V->D4);\n  V->Dif[9]+=abs(D-UnpChannelDelta);\n  V->Dif[10]+=abs(D+UnpChannelDelta);\n\n  UnpChannelDelta=V->LastDelta=(signed char)(Ch-V->LastChar);\n  V->LastChar=Ch;\n\n  if ((V->ByteCount & 0x1F)==0)\n  {\n    unsigned int MinDif=V->Dif[0],NumMinDif=0;\n    V->Dif[0]=0;\n    for (int I=1;I<sizeof(V->Dif)/sizeof(V->Dif[0]);I++)\n    {\n      if (V->Dif[I]<MinDif)\n      {\n        MinDif=V->Dif[I];\n        NumMinDif=I;\n      }\n      V->Dif[I]=0;\n    }\n    switch(NumMinDif)\n    {\n      case 1:\n        if (V->K1>=-16)\n          V->K1--;\n        break;\n      case 2:\n        if (V->K1<16)\n          V->K1++;\n        break;\n      case 3:\n        if (V->K2>=-16)\n          V->K2--;\n        break;\n      case 4:\n        if (V->K2<16)\n          V->K2++;\n        break;\n      case 5:\n        if (V->K3>=-16)\n          V->K3--;\n        break;\n      case 6:\n        if (V->K3<16)\n          V->K3++;\n        break;\n      case 7:\n        if (V->K4>=-16)\n          V->K4--;\n        break;\n      case 8:\n        if (V->K4<16)\n          V->K4++;\n        break;\n      case 9:\n        if (V->K5>=-16)\n          V->K5--;\n        break;\n      case 10:\n        if (V->K5<16)\n          V->K5++;\n        break;\n    }\n  }\n  return((byte)Ch);\n}\n","// We use it instead of direct PPM.DecodeChar call to be sure that\n// we reset PPM structures in case of corrupt data. It is important,\n// because these structures can be invalid after PPM.DecodeChar returned -1.\ninline int Unpack::SafePPMDecodeChar()\n{\n  int Ch=PPM.DecodeChar();\n  if (Ch==-1)              // Corrupt PPM data found.\n  {\n    PPM.CleanUp();         // Reset possibly corrupt PPM data structures.\n    UnpBlockType=BLOCK_LZ; // Set faster and more fail proof LZ mode.\n  }\n  return(Ch);\n}\n\n\nvoid Unpack::Unpack29(bool Solid)\n{\n  static unsigned char LDecode[]={0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224};\n  static unsigned char LBits[]=  {0,0,0,0,0,0,0,0,1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5};\n  static int DDecode[DC];\n  static byte DBits[DC];\n  static int DBitLengthCounts[]= {4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,14,0,12};\n  static unsigned char SDDecode[]={0,4,8,16,32,64,128,192};\n  static unsigned char SDBits[]=  {2,2,3, 4, 5, 6,  6,  6};\n  unsigned int Bits;\n\n  if (DDecode[1]==0)\n  {\n    int Dist=0,BitLength=0,Slot=0;\n    for (int I=0;I<ASIZE(DBitLengthCounts);I++,BitLength++)\n      for (int J=0;J<DBitLengthCounts[I];J++,Slot++,Dist+=(1<<BitLength))\n      {\n        DDecode[Slot]=Dist;\n        DBits[Slot]=BitLength;\n      }\n  }\n\n  FileExtracted=true;\n\n  if (!Suspended)\n  {\n    UnpInitData(Solid);\n    if (!UnpReadBuf30())\n      return;\n    if ((!Solid || !TablesRead) && !ReadTables30())\n      return;\n  }\n\n  while (true)\n  {\n    UnpPtr&=MaxWinMask;\n\n    if (Inp.InAddr>ReadBorder)\n    {\n      if (!UnpReadBuf30())\n        break;\n    }\n    if (((WrPtr-UnpPtr) & MaxWinMask)<260 && WrPtr!=UnpPtr)\n    {\n      UnpWriteBuf30();\n      if (WrittenFileSize>DestUnpSize)\n        return;\n      if (Suspended)\n      {\n        FileExtracted=false;\n        return;\n      }\n    }\n    if (UnpBlockType==BLOCK_PPM)\n    {\n      // Here speed is critical, so we do not use SafePPMDecodeChar,\n      // because sometimes even the inline function can introduce\n      // some additional penalty.\n      int Ch=PPM.DecodeChar();\n      if (Ch==-1)              // Corrupt PPM data found.\n      {\n        PPM.CleanUp();         // Reset possibly corrupt PPM data structures.\n        UnpBlockType=BLOCK_LZ; // Set faster and more fail proof LZ mode.\n        break;\n      }\n      if (Ch==PPMEscChar)\n      {\n        int NextCh=SafePPMDecodeChar();\n        if (NextCh==0)  // End of PPM encoding.\n        {\n          if (!ReadTables30())\n            break;\n          continue;\n        }\n        if (NextCh==-1) // Corrupt PPM data found.\n          break;\n        if (NextCh==2)  // End of file in PPM mode.\n          break;\n        if (NextCh==3)  // Read VM code.\n        {\n          if (!ReadVMCodePPM())\n            break;\n          continue;\n        }\n        if (NextCh==4) // LZ inside of PPM.\n        {\n          unsigned int Distance=0,Length;\n          bool Failed=false;\n          for (int I=0;I<4 && !Failed;I++)\n          {\n            int Ch=SafePPMDecodeChar();\n            if (Ch==-1)\n              Failed=true;\n            else\n              if (I==3)\n                Length=(byte)Ch;\n              else\n                Distance=(Distance<<8)+(byte)Ch;\n          }\n          if (Failed)\n            break;\n\n          CopyString(Length+32,Distance+2);\n          continue;\n        }\n        if (NextCh==5) // One byte distance match (RLE) inside of PPM.\n        {\n          int Length=SafePPMDecodeChar();\n          if (Length==-1)\n            break;\n          CopyString(Length+4,1);\n          continue;\n        }\n        // If we are here, NextCh must be 1, what means that current byte\n        // is equal to our 'escape' byte, so we just store it to Window.\n      }\n      Window[UnpPtr++]=Ch;\n      continue;\n    }\n\n    int Number=DecodeNumber(Inp,&BlockTables.LD);\n    if (Number<256)\n    {\n      Window[UnpPtr++]=(byte)Number;\n      continue;\n    }\n    if (Number>=271)\n    {\n      int Length=LDecode[Number-=271]+3;\n      if ((Bits=LBits[Number])>0)\n      {\n        Length+=Inp.getbits()>>(16-Bits);\n        Inp.addbits(Bits);\n      }\n\n      int DistNumber=DecodeNumber(Inp,&BlockTables.DD);\n      unsigned int Distance=DDecode[DistNumber]+1;\n      if ((Bits=DBits[DistNumber])>0)\n      {\n        if (DistNumber>9)\n        {\n          if (Bits>4)\n          {\n            Distance+=((Inp.getbits()>>(20-Bits))<<4);\n            Inp.addbits(Bits-4);\n          }\n          if (LowDistRepCount>0)\n          {\n            LowDistRepCount--;\n            Distance+=PrevLowDist;\n          }\n          else\n          {\n            int LowDist=DecodeNumber(Inp,&BlockTables.LDD);\n            if (LowDist==16)\n            {\n              LowDistRepCount=LOW_DIST_REP_COUNT-1;\n              Distance+=PrevLowDist;\n            }\n            else\n            {\n              Distance+=LowDist;\n              PrevLowDist=LowDist;\n            }\n          }\n        }\n        else\n        {\n          Distance+=Inp.getbits()>>(16-Bits);\n          Inp.addbits(Bits);\n        }\n      }\n\n      if (Distance>=0x2000)\n      {\n        Length++;\n        if (Distance>=0x40000L)\n          Length++;\n      }\n\n      InsertOldDist(Distance);\n      LastLength=Length;\n      CopyString(Length,Distance);\n      continue;\n    }\n    if (Number==256)\n    {\n      if (!ReadEndOfBlock())\n        break;\n      continue;\n    }\n    if (Number==257)\n    {\n      if (!ReadVMCode())\n        break;\n      continue;\n    }\n    if (Number==258)\n    {\n      if (LastLength!=0)\n        CopyString(LastLength,OldDist[0]);\n      continue;\n    }\n    if (Number<263)\n    {\n      int DistNum=Number-259;\n      unsigned int Distance=OldDist[DistNum];\n      for (int I=DistNum;I>0;I--)\n        OldDist[I]=OldDist[I-1];\n      OldDist[0]=Distance;\n\n      int LengthNumber=DecodeNumber(Inp,&BlockTables.RD);\n      int Length=LDecode[LengthNumber]+2;\n      if ((Bits=LBits[LengthNumber])>0)\n      {\n        Length+=Inp.getbits()>>(16-Bits);\n        Inp.addbits(Bits);\n      }\n      LastLength=Length;\n      CopyString(Length,Distance);\n      continue;\n    }\n    if (Number<272)\n    {\n      unsigned int Distance=SDDecode[Number-=263]+1;\n      if ((Bits=SDBits[Number])>0)\n      {\n        Distance+=Inp.getbits()>>(16-Bits);\n        Inp.addbits(Bits);\n      }\n      InsertOldDist(Distance);\n      LastLength=2;\n      CopyString(2,Distance);\n      continue;\n    }\n  }\n  UnpWriteBuf30();\n}\n\n\n// Return 'false' to quit unpacking the current file or 'true' to continue.\nbool Unpack::ReadEndOfBlock()\n{\n  uint BitField=Inp.getbits();\n  bool NewTable,NewFile=false;\n\n  // \"1\"  - no new file, new table just here.\n  // \"00\" - new file,    no new table.\n  // \"01\" - new file,    new table (in beginning of next file).\n  \n  if ((BitField & 0x8000)!=0)\n  {\n    NewTable=true;\n    Inp.addbits(1);\n  }\n  else\n  {\n    NewFile=true;\n    NewTable=(BitField & 0x4000)!=0;\n    Inp.addbits(2);\n  }\n  TablesRead=!NewTable;\n\n  // Quit immediately if \"new file\" flag is set. If \"new table\" flag\n  // is present, we'll read the table in beginning of next file\n  // based on 'TablesRead' 'false' value.\n  if (NewFile)\n    return false;\n  return ReadTables30(); // Quit only if we failed to read tables.\n}\n\n\nbool Unpack::ReadVMCode()\n{\n  // Entire VM code is guaranteed to fully present in block defined \n  // by current Huffman table. Compressor checks that VM code does not cross\n  // Huffman block boundaries.\n  unsigned int FirstByte=Inp.getbits()>>8;\n  Inp.addbits(8);\n  int Length=(FirstByte & 7)+1;\n  if (Length==7)\n  {\n    Length=(Inp.getbits()>>8)+7;\n    Inp.addbits(8);\n  }\n  else\n    if (Length==8)\n    {\n      Length=Inp.getbits();\n      Inp.addbits(16);\n    }\n  Array<byte> VMCode(Length);\n  for (int I=0;I<Length;I++)\n  {\n    // Try to read the new buffer if only one byte is left.\n    // But if we read all bytes except the last, one byte is enough.\n    if (Inp.InAddr>=ReadTop-1 && !UnpReadBuf30() && I<Length-1)\n      return false;\n    VMCode[I]=Inp.getbits()>>8;\n    Inp.addbits(8);\n  }\n  return AddVMCode(FirstByte,&VMCode[0],Length);\n}\n\n\nbool Unpack::ReadVMCodePPM()\n{\n  unsigned int FirstByte=SafePPMDecodeChar();\n  if ((int)FirstByte==-1)\n    return false;\n  int Length=(FirstByte & 7)+1;\n  if (Length==7)\n  {\n    int B1=SafePPMDecodeChar();\n    if (B1==-1)\n      return(false);\n    Length=B1+7;\n  }\n  else\n    if (Length==8)\n    {\n      int B1=SafePPMDecodeChar();\n      if (B1==-1)\n        return false;\n      int B2=SafePPMDecodeChar();\n      if (B2==-1)\n        return false;\n      Length=B1*256+B2;\n    }\n  Array<byte> VMCode(Length);\n  for (int I=0;I<Length;I++)\n  {\n    int Ch=SafePPMDecodeChar();\n    if (Ch==-1)\n      return(false);\n    VMCode[I]=Ch;\n  }\n  return AddVMCode(FirstByte,&VMCode[0],Length);\n}\n\n\nbool Unpack::AddVMCode(uint FirstByte,byte *Code,int CodeSize)\n{\n  VMCodeInp.InitBitInput();\n  memcpy(VMCodeInp.InBuf,Code,Min(BitInput::MAX_SIZE,CodeSize));\n  VM.Init();\n\n  uint FiltPos;\n  if ((FirstByte & 0x80)!=0)\n  {\n    FiltPos=RarVM::ReadData(VMCodeInp);\n    if (FiltPos==0)\n      InitFilters30(false);\n    else\n      FiltPos--;\n  }\n  else\n    FiltPos=LastFilter; // Use the same filter as last time.\n\n  if (FiltPos>Filters30.Size() || FiltPos>OldFilterLengths.Size())\n    return false;\n  LastFilter=FiltPos;\n  bool NewFilter=(FiltPos==Filters30.Size());\n\n  UnpackFilter30 *StackFilter=new UnpackFilter30; // New filter for PrgStack.\n\n  UnpackFilter30 *Filter;\n  if (NewFilter) // New filter code, never used before since VM reset.\n  {\n    if (FiltPos>MAX3_UNPACK_FILTERS)\n    {\n      // Too many different filters, corrupt archive.\n      delete StackFilter;\n      return false;\n    }\n\n    Filters30.Add(1);\n    Filters30[Filters30.Size()-1]=Filter=new UnpackFilter30;\n    StackFilter->ParentFilter=(uint)(Filters30.Size()-1);\n\n    // Reserve one item, where we store the data block length of our new\n    // filter entry. We'll set it to real block length below, after reading\n    // it. But we need to initialize it now, because when processing corrupt\n    // data, we can access this item even before we set it to real value.\n    OldFilterLengths.Push(0);\n    Filter->ExecCount=0;\n  }\n  else  // Filter was used in the past.\n  {\n    Filter=Filters30[FiltPos];\n    StackFilter->ParentFilter=FiltPos;\n    Filter->ExecCount++;\n  }\n\n  int EmptyCount=0;\n  for (uint I=0;I<PrgStack.Size();I++)\n  {\n    PrgStack[I-EmptyCount]=PrgStack[I];\n    if (PrgStack[I]==NULL)\n      EmptyCount++;\n    if (EmptyCount>0)\n      PrgStack[I]=NULL;\n  }\n  if (EmptyCount==0)\n  {\n    if (PrgStack.Size()>MAX3_UNPACK_FILTERS)\n    {\n      delete StackFilter;\n      return false;\n    }\n    PrgStack.Add(1);\n    EmptyCount=1;\n  }\n  int StackPos=(int)(PrgStack.Size()-EmptyCount);\n  PrgStack[StackPos]=StackFilter;\n  StackFilter->ExecCount=Filter->ExecCount;\n \n  uint BlockStart=RarVM::ReadData(VMCodeInp);\n  if ((FirstByte & 0x40)!=0)\n    BlockStart+=258;\n  StackFilter->BlockStart=(uint)((BlockStart+UnpPtr)&MaxWinMask);\n  if ((FirstByte & 0x20)!=0)\n  {\n    StackFilter->BlockLength=RarVM::ReadData(VMCodeInp);\n\n    // Store the last data block length for current filter.\n    OldFilterLengths[FiltPos]=StackFilter->BlockLength;\n  }\n  else\n  {\n    // Set the data block size to same value as the previous block size\n    // for same filter. It is possible on corrupt data to access here a new \n    // and not filled yet item of OldFilterLengths array. This is why above\n    // we set new OldFilterLengths items to zero.\n    StackFilter->BlockLength=FiltPos<OldFilterLengths.Size() ? OldFilterLengths[FiltPos]:0;\n  }\n\n  StackFilter->NextWindow=WrPtr!=UnpPtr && ((WrPtr-UnpPtr)&MaxWinMask)<=BlockStart;\n\n//  DebugLog(\"\\nNextWindow: UnpPtr=%08x WrPtr=%08x BlockStart=%08x\",UnpPtr,WrPtr,BlockStart);\n\n  memset(StackFilter->Prg.InitR,0,sizeof(StackFilter->Prg.InitR));\n  StackFilter->Prg.InitR[3]=VM_GLOBALMEMADDR;\n  StackFilter->Prg.InitR[4]=StackFilter->BlockLength;\n  StackFilter->Prg.InitR[5]=StackFilter->ExecCount;\n\n  if ((FirstByte & 0x10)!=0) // Set registers to optional parameters if any.\n  {\n    uint InitMask=VMCodeInp.fgetbits()>>9;\n    VMCodeInp.faddbits(7);\n    for (int I=0;I<7;I++)\n      if (InitMask & (1<<I))\n        StackFilter->Prg.InitR[I]=RarVM::ReadData(VMCodeInp);\n  }\n\n  if (NewFilter)\n  {\n    uint VMCodeSize=RarVM::ReadData(VMCodeInp);\n    if (VMCodeSize>=0x10000 || VMCodeSize==0)\n      return false;\n    Array<byte> VMCode(VMCodeSize);\n    for (uint I=0;I<VMCodeSize;I++)\n    {\n      if (VMCodeInp.Overflow(3))\n        return false;\n      VMCode[I]=VMCodeInp.fgetbits()>>8;\n      VMCodeInp.faddbits(8);\n    }\n    VM.Prepare(&VMCode[0],VMCodeSize,&Filter->Prg);\n  }\n  StackFilter->Prg.AltCmd=&Filter->Prg.Cmd[0];\n  StackFilter->Prg.CmdCount=Filter->Prg.CmdCount;\n\n  size_t StaticDataSize=Filter->Prg.StaticData.Size();\n  if (StaticDataSize>0 && StaticDataSize<VM_GLOBALMEMSIZE)\n  {\n    // read statically defined data contained in DB commands\n    StackFilter->Prg.StaticData.Add(StaticDataSize);\n    memcpy(&StackFilter->Prg.StaticData[0],&Filter->Prg.StaticData[0],StaticDataSize);\n  }\n\n  if (StackFilter->Prg.GlobalData.Size()<VM_FIXEDGLOBALSIZE)\n  {\n    StackFilter->Prg.GlobalData.Reset();\n    StackFilter->Prg.GlobalData.Add(VM_FIXEDGLOBALSIZE);\n  }\n  byte *GlobalData=&StackFilter->Prg.GlobalData[0];\n  for (int I=0;I<7;I++)\n    VM.SetLowEndianValue((uint *)&GlobalData[I*4],StackFilter->Prg.InitR[I]);\n  VM.SetLowEndianValue((uint *)&GlobalData[0x1c],StackFilter->BlockLength);\n  VM.SetLowEndianValue((uint *)&GlobalData[0x20],0);\n  VM.SetLowEndianValue((uint *)&GlobalData[0x2c],StackFilter->ExecCount);\n  memset(&GlobalData[0x30],0,16);\n\n  if ((FirstByte & 8)!=0) // Put the data block passed as parameter if any.\n  {\n    if (VMCodeInp.Overflow(3))\n      return false;\n    uint DataSize=RarVM::ReadData(VMCodeInp);\n    if (DataSize>VM_GLOBALMEMSIZE-VM_FIXEDGLOBALSIZE)\n      return false;\n    size_t CurSize=StackFilter->Prg.GlobalData.Size();\n    if (CurSize<DataSize+VM_FIXEDGLOBALSIZE)\n      StackFilter->Prg.GlobalData.Add(DataSize+VM_FIXEDGLOBALSIZE-CurSize);\n    byte *GlobalData=&StackFilter->Prg.GlobalData[VM_FIXEDGLOBALSIZE];\n    for (uint I=0;I<DataSize;I++)\n    {\n      if (VMCodeInp.Overflow(3))\n        return false;\n      GlobalData[I]=VMCodeInp.fgetbits()>>8;\n      VMCodeInp.faddbits(8);\n    }\n  }\n  return true;\n}\n\n\nbool Unpack::UnpReadBuf30()\n{\n  int DataSize=ReadTop-Inp.InAddr; // Data left to process.\n  if (DataSize<0)\n    return false;\n  if (Inp.InAddr>BitInput::MAX_SIZE/2)\n  {\n    // If we already processed more than half of buffer, let's move\n    // remaining data into beginning to free more space for new data\n    // and ensure that calling function does not cross the buffer border\n    // even if we did not read anything here. Also it ensures that read size\n    // is not less than CRYPT_BLOCK_SIZE, so we can align it without risk\n    // to make it zero.\n    if (DataSize>0)\n      memmove(Inp.InBuf,Inp.InBuf+Inp.InAddr,DataSize);\n    Inp.InAddr=0;\n    ReadTop=DataSize;\n  }\n  else\n    DataSize=ReadTop;\n  int ReadCode=UnpIO->UnpRead(Inp.InBuf+DataSize,BitInput::MAX_SIZE-DataSize);\n  if (ReadCode>0)\n    ReadTop+=ReadCode;\n  ReadBorder=ReadTop-30;\n  return ReadCode!=-1;\n}\n\n\nvoid Unpack::UnpWriteBuf30()\n{\n  uint WrittenBorder=(uint)WrPtr;\n  uint WriteSize=(uint)((UnpPtr-WrittenBorder)&MaxWinMask);\n  for (size_t I=0;I<PrgStack.Size();I++)\n  {\n    // Here we apply filters to data which we need to write.\n    // We always copy data to virtual machine memory before processing.\n    // We cannot process them just in place in Window buffer, because\n    // these data can be used for future string matches, so we must\n    // preserve them in original form.\n\n    UnpackFilter30 *flt=PrgStack[I];\n    if (flt==NULL)\n      continue;\n    if (flt->NextWindow)\n    {\n      flt->NextWindow=false;\n      continue;\n    }\n    unsigned int BlockStart=flt->BlockStart;\n    unsigned int BlockLength=flt->BlockLength;\n    if (((BlockStart-WrittenBorder)&MaxWinMask)<WriteSize)\n    {\n      if (WrittenBorder!=BlockStart)\n      {\n        UnpWriteArea(WrittenBorder,BlockStart);\n        WrittenBorder=BlockStart;\n        WriteSize=(uint)((UnpPtr-WrittenBorder)&MaxWinMask);\n      }\n      if (BlockLength<=WriteSize)\n      {\n        uint BlockEnd=(BlockStart+BlockLength)&MaxWinMask;\n        if (BlockStart<BlockEnd || BlockEnd==0)\n          VM.SetMemory(0,Window+BlockStart,BlockLength);\n        else\n        {\n          uint FirstPartLength=uint(MaxWinSize-BlockStart);\n          VM.SetMemory(0,Window+BlockStart,FirstPartLength);\n          VM.SetMemory(FirstPartLength,Window,BlockEnd);\n        }\n\n        VM_PreparedProgram *ParentPrg=&Filters30[flt->ParentFilter]->Prg;\n        VM_PreparedProgram *Prg=&flt->Prg;\n\n        if (ParentPrg->GlobalData.Size()>VM_FIXEDGLOBALSIZE)\n        {\n          // Copy global data from previous script execution if any.\n          Prg->GlobalData.Alloc(ParentPrg->GlobalData.Size());\n          memcpy(&Prg->GlobalData[VM_FIXEDGLOBALSIZE],&ParentPrg->GlobalData[VM_FIXEDGLOBALSIZE],ParentPrg->GlobalData.Size()-VM_FIXEDGLOBALSIZE);\n        }\n\n        ExecuteCode(Prg);\n\n        if (Prg->GlobalData.Size()>VM_FIXEDGLOBALSIZE)\n        {\n          // Save global data for next script execution.\n          if (ParentPrg->GlobalData.Size()<Prg->GlobalData.Size())\n            ParentPrg->GlobalData.Alloc(Prg->GlobalData.Size());\n          memcpy(&ParentPrg->GlobalData[VM_FIXEDGLOBALSIZE],&Prg->GlobalData[VM_FIXEDGLOBALSIZE],Prg->GlobalData.Size()-VM_FIXEDGLOBALSIZE);\n        }\n        else\n          ParentPrg->GlobalData.Reset();\n\n        byte *FilteredData=Prg->FilteredData;\n        unsigned int FilteredDataSize=Prg->FilteredDataSize;\n\n        delete PrgStack[I];\n        PrgStack[I]=NULL;\n        while (I+1<PrgStack.Size())\n        {\n          UnpackFilter30 *NextFilter=PrgStack[I+1];\n          // It is required to check NextWindow here.\n          if (NextFilter==NULL || NextFilter->BlockStart!=BlockStart ||\n              NextFilter->BlockLength!=FilteredDataSize || NextFilter->NextWindow)\n            break;\n\n          // Apply several filters to same data block.\n\n          VM.SetMemory(0,FilteredData,FilteredDataSize);\n\n          VM_PreparedProgram *ParentPrg=&Filters30[NextFilter->ParentFilter]->Prg;\n          VM_PreparedProgram *NextPrg=&NextFilter->Prg;\n\n          if (ParentPrg->GlobalData.Size()>VM_FIXEDGLOBALSIZE)\n          {\n            // Copy global data from previous script execution if any.\n            NextPrg->GlobalData.Alloc(ParentPrg->GlobalData.Size());\n            memcpy(&NextPrg->GlobalData[VM_FIXEDGLOBALSIZE],&ParentPrg->GlobalData[VM_FIXEDGLOBALSIZE],ParentPrg->GlobalData.Size()-VM_FIXEDGLOBALSIZE);\n          }\n\n          ExecuteCode(NextPrg);\n\n          if (NextPrg->GlobalData.Size()>VM_FIXEDGLOBALSIZE)\n          {\n            // Save global data for next script execution.\n            if (ParentPrg->GlobalData.Size()<NextPrg->GlobalData.Size())\n              ParentPrg->GlobalData.Alloc(NextPrg->GlobalData.Size());\n            memcpy(&ParentPrg->GlobalData[VM_FIXEDGLOBALSIZE],&NextPrg->GlobalData[VM_FIXEDGLOBALSIZE],NextPrg->GlobalData.Size()-VM_FIXEDGLOBALSIZE);\n          }\n          else\n            ParentPrg->GlobalData.Reset();\n\n          FilteredData=NextPrg->FilteredData;\n          FilteredDataSize=NextPrg->FilteredDataSize;\n          I++;\n          delete PrgStack[I];\n          PrgStack[I]=NULL;\n        }\n        UnpIO->UnpWrite(FilteredData,FilteredDataSize);\n        UnpSomeRead=true;\n        WrittenFileSize+=FilteredDataSize;\n        WrittenBorder=BlockEnd;\n        WriteSize=uint((UnpPtr-WrittenBorder)&MaxWinMask);\n      }\n      else\n      {\n        // Current filter intersects the window write border, so we adjust\n        // the window border to process this filter next time, not now.\n        for (size_t J=I;J<PrgStack.Size();J++)\n        {\n          UnpackFilter30 *flt=PrgStack[J];\n          if (flt!=NULL && flt->NextWindow)\n            flt->NextWindow=false;\n        }\n        WrPtr=WrittenBorder;\n        return;\n      }\n    }\n  }\n      \n  UnpWriteArea(WrittenBorder,UnpPtr);\n  WrPtr=UnpPtr;\n}\n\n\nvoid Unpack::ExecuteCode(VM_PreparedProgram *Prg)\n{\n  if (Prg->GlobalData.Size()>0)\n  {\n    Prg->InitR[6]=(uint)WrittenFileSize;\n    VM.SetLowEndianValue((uint *)&Prg->GlobalData[0x24],(uint)WrittenFileSize);\n    VM.SetLowEndianValue((uint *)&Prg->GlobalData[0x28],(uint)(WrittenFileSize>>32));\n    VM.Execute(Prg);\n  }\n}\n\n\nbool Unpack::ReadTables30()\n{\n  byte BitLength[BC];\n  byte Table[HUFF_TABLE_SIZE30];\n  if (Inp.InAddr>ReadTop-25)\n    if (!UnpReadBuf30())\n      return(false);\n  Inp.faddbits((8-Inp.InBit)&7);\n  uint BitField=Inp.fgetbits();\n  if (BitField & 0x8000)\n  {\n    UnpBlockType=BLOCK_PPM;\n    return(PPM.DecodeInit(this,PPMEscChar));\n  }\n  UnpBlockType=BLOCK_LZ;\n  \n  PrevLowDist=0;\n  LowDistRepCount=0;\n\n  if (!(BitField & 0x4000))\n    memset(UnpOldTable,0,sizeof(UnpOldTable));\n  Inp.faddbits(2);\n\n  for (int I=0;I<BC;I++)\n  {\n    int Length=(byte)(Inp.fgetbits() >> 12);\n    Inp.faddbits(4);\n    if (Length==15)\n    {\n      int ZeroCount=(byte)(Inp.fgetbits() >> 12);\n      Inp.faddbits(4);\n      if (ZeroCount==0)\n        BitLength[I]=15;\n      else\n      {\n        ZeroCount+=2;\n        while (ZeroCount-- > 0 && I<ASIZE(BitLength))\n          BitLength[I++]=0;\n        I--;\n      }\n    }\n    else\n      BitLength[I]=Length;\n  }\n  MakeDecodeTables(BitLength,&BlockTables.BD,BC30);\n\n  const int TableSize=HUFF_TABLE_SIZE30;\n  for (int I=0;I<TableSize;)\n  {\n    if (Inp.InAddr>ReadTop-5)\n      if (!UnpReadBuf30())\n        return(false);\n    int Number=DecodeNumber(Inp,&BlockTables.BD);\n    if (Number<16)\n    {\n      Table[I]=(Number+UnpOldTable[I]) & 0xf;\n      I++;\n    }\n    else\n      if (Number<18)\n      {\n        int N;\n        if (Number==16)\n        {\n          N=(Inp.fgetbits() >> 13)+3;\n          Inp.faddbits(3);\n        }\n        else\n        {\n          N=(Inp.fgetbits() >> 9)+11;\n          Inp.faddbits(7);\n        }\n        if (I>0)\n          while (N-- > 0 && I<TableSize)\n          {\n            Table[I]=Table[I-1];\n            I++;\n          }\n      }\n      else\n      {\n        int N;\n        if (Number==18)\n        {\n          N=(Inp.fgetbits() >> 13)+3;\n          Inp.faddbits(3);\n        }\n        else\n        {\n          N=(Inp.fgetbits() >> 9)+11;\n          Inp.faddbits(7);\n        }\n        while (N-- > 0 && I<TableSize)\n          Table[I++]=0;\n      }\n  }\n  TablesRead=true;\n  if (Inp.InAddr>ReadTop)\n    return false;\n  MakeDecodeTables(&Table[0],&BlockTables.LD,NC30);\n  MakeDecodeTables(&Table[NC30],&BlockTables.DD,DC30);\n  MakeDecodeTables(&Table[NC30+DC30],&BlockTables.LDD,LDC30);\n  MakeDecodeTables(&Table[NC30+DC30+LDC30],&BlockTables.RD,RC30);\n  memcpy(UnpOldTable,Table,sizeof(UnpOldTable));\n  return true;\n}\n\n\nvoid Unpack::UnpInitData30(bool Solid)\n{\n  if (!Solid)\n  {\n    TablesRead=false;\n    memset(UnpOldTable,0,sizeof(UnpOldTable));\n    PPMEscChar=2;\n    UnpBlockType=BLOCK_LZ;\n  }\n  InitFilters30(Solid);\n}\n\n\nvoid Unpack::InitFilters30(bool Solid)\n{\n  if (!Solid)\n  {\n    OldFilterLengths.SoftReset();\n    LastFilter=0;\n\n    for (size_t I=0;I<Filters30.Size();I++)\n      delete Filters30[I];\n    Filters30.SoftReset();\n  }\n  for (size_t I=0;I<PrgStack.Size();I++)\n    delete PrgStack[I];\n  PrgStack.SoftReset();\n}\n","#ifndef _RAR_VM_\n#define _RAR_VM_\n\n#define VM_STANDARDFILTERS\n#define NORARVM\n\n#define VM_MEMSIZE                  0x40000\n#define VM_MEMMASK           (VM_MEMSIZE-1)\n#define VM_GLOBALMEMADDR            0x3C000\n#define VM_GLOBALMEMSIZE             0x2000\n#define VM_FIXEDGLOBALSIZE               64\n\nenum VM_Commands\n{\n  VM_MOV,  VM_CMP,  VM_ADD,  VM_SUB,  VM_JZ,   VM_JNZ,  VM_INC,  VM_DEC,\n  VM_JMP,  VM_XOR,  VM_AND,  VM_OR,   VM_TEST, VM_JS,   VM_JNS,  VM_JB,\n  VM_JBE,  VM_JA,   VM_JAE,  VM_PUSH, VM_POP,  VM_CALL, VM_RET,  VM_NOT,\n  VM_SHL,  VM_SHR,  VM_SAR,  VM_NEG,  VM_PUSHA,VM_POPA, VM_PUSHF,VM_POPF,\n  VM_MOVZX,VM_MOVSX,VM_XCHG, VM_MUL,  VM_DIV,  VM_ADC,  VM_SBB,  VM_PRINT,\n\n#ifdef VM_OPTIMIZE\n  VM_MOVB, VM_MOVD, VM_CMPB, VM_CMPD,\n\n  VM_ADDB, VM_ADDD, VM_SUBB, VM_SUBD, VM_INCB, VM_INCD, VM_DECB, VM_DECD,\n  VM_NEGB, VM_NEGD,\n#endif\n\n  VM_STANDARD\n};\n\nenum VM_StandardFilters {\n  VMSF_NONE, VMSF_E8, VMSF_E8E9, VMSF_ITANIUM, VMSF_RGB, VMSF_AUDIO, \n  VMSF_DELTA\n};\n\nenum VM_Flags {VM_FC=1,VM_FZ=2,VM_FS=0x80000000};\n\nenum VM_OpType {VM_OPREG,VM_OPINT,VM_OPREGMEM,VM_OPNONE};\n\nstruct VM_PreparedOperand\n{\n  VM_OpType Type;\n  uint Data;\n  uint Base;\n  uint *Addr;\n};\n\nstruct VM_PreparedCommand\n{\n  VM_Commands OpCode;\n  bool ByteMode;\n  VM_PreparedOperand Op1,Op2;\n};\n\n\nstruct VM_PreparedProgram\n{\n  VM_PreparedProgram() \n  {\n    AltCmd=NULL;\n    FilteredDataSize=0;\n    CmdCount=0;\n  }\n\n  Array<VM_PreparedCommand> Cmd;\n  VM_PreparedCommand *AltCmd;\n  int CmdCount;\n\n  Array<byte> GlobalData;\n  Array<byte> StaticData; // static data contained in DB operators\n  uint InitR[7];\n\n  byte *FilteredData;\n  uint FilteredDataSize;\n};\n\nclass RarVM:private BitInput\n{\n  private:\n    inline uint GetValue(bool ByteMode,uint *Addr);\n    inline void SetValue(bool ByteMode,uint *Addr,uint Value);\n    inline uint* GetOperand(VM_PreparedOperand *CmdOp);\n    void DecodeArg(VM_PreparedOperand &Op,bool ByteMode);\n#ifdef VM_OPTIMIZE\n    void Optimize(VM_PreparedProgram *Prg);\n#endif\n    bool ExecuteCode(VM_PreparedCommand *PreparedCode,uint CodeSize);\n#ifdef VM_STANDARDFILTERS\n    VM_StandardFilters IsStandardFilter(byte *Code,uint CodeSize);\n    void ExecuteStandardFilter(VM_StandardFilters FilterType);\n    uint FilterItanium_GetBits(byte *Data,int BitPos,int BitCount);\n    void FilterItanium_SetBits(byte *Data,uint BitField,int BitPos,int BitCount);\n#endif\n\n    byte *Mem;\n    uint R[8];\n    uint Flags;\n  public:\n    RarVM();\n    ~RarVM();\n    void Init();\n    void Prepare(byte *Code,uint CodeSize,VM_PreparedProgram *Prg);\n    void Execute(VM_PreparedProgram *Prg);\n    void SetLowEndianValue(uint *Addr,uint Value);\n    void SetMemory(size_t Pos,byte *Data,size_t DataSize);\n    static uint ReadData(BitInput &Inp);\n};\n\n#endif\n","_forceinline void Unpack::InsertOldDist(uint Distance)\n{\n  OldDist[3]=OldDist[2];\n  OldDist[2]=OldDist[1];\n  OldDist[1]=OldDist[0];\n  OldDist[0]=Distance;\n}\n\n#ifdef _MSC_VER\n#define FAST_MEMCPY\n#endif\n\n_forceinline void Unpack::CopyString(uint Length,uint Distance)\n{\n  size_t SrcPtr=UnpPtr-Distance;\n  if (SrcPtr<MaxWinSize-MAX_LZ_MATCH && UnpPtr<MaxWinSize-MAX_LZ_MATCH)\n  {\n    // If we are not close to end of window, we do not need to waste time\n    // to \"& MaxWinMask\" pointer protection.\n\n    byte *Src=Window+SrcPtr;\n    byte *Dest=Window+UnpPtr;\n    UnpPtr+=Length;\n\n#ifdef FAST_MEMCPY\n    if (Distance<Length) // Overlapping strings\n#endif\n      while (Length>=8)\n      {\n        Dest[0]=Src[0];\n        Dest[1]=Src[1];\n        Dest[2]=Src[2];\n        Dest[3]=Src[3];\n        Dest[4]=Src[4];\n        Dest[5]=Src[5];\n        Dest[6]=Src[6];\n        Dest[7]=Src[7];\n\n        Src+=8;\n        Dest+=8;\n        Length-=8;\n      }\n#ifdef FAST_MEMCPY\n    else\n      while (Length>=8)\n      {\n        // In theory we still could overlap here.\n        // Supposing Distance == MaxWinSize - 1 we have memcpy(Src, Src + 1, 8).\n        // But for real RAR archives Distance <= MaxWinSize - MAX_LZ_MATCH\n        // always, so overlap here is impossible.\n\n        // This memcpy expanded inline by MSVC. We could also use uint64\n        // assignment, which seems to provide about the same speed.\n        memcpy(Dest,Src,8); \n\n        Src+=8;\n        Dest+=8;\n        Length-=8;\n      }\n#endif\n\n    // Unroll the loop for 0 - 7 bytes left. Note that we use nested \"if\"s.\n    if (Length>0) { Dest[0]=Src[0];\n    if (Length>1) { Dest[1]=Src[1];\n    if (Length>2) { Dest[2]=Src[2];\n    if (Length>3) { Dest[3]=Src[3];\n    if (Length>4) { Dest[4]=Src[4];\n    if (Length>5) { Dest[5]=Src[5];\n    if (Length>6) { Dest[6]=Src[6]; } } } } } } } // Close all nested \"if\"s.\n  }\n  else\n    while (Length-- > 0) // Slow copying with all possible precautions.\n    {\n      Window[UnpPtr]=Window[SrcPtr++ & MaxWinMask];\n      // We need to have masked UnpPtr after quit from loop, so it must not\n      // be replaced with 'Window[UnpPtr++ & MaxWinMask]'\n      UnpPtr=(UnpPtr+1) & MaxWinMask;\n    }\n}\n\n\n_forceinline uint Unpack::DecodeNumber(BitInput &Inp,DecodeTable *Dec)\n{\n  // Left aligned 15 bit length raw bit field.\n  uint BitField=Inp.getbits() & 0xfffe;\n\n  if (BitField<Dec->DecodeLen[Dec->QuickBits])\n  {\n    uint Code=BitField>>(16-Dec->QuickBits);\n    Inp.addbits(Dec->QuickLen[Code]);\n    return Dec->QuickNum[Code];\n  }\n\n  // Detect the real bit length for current code.\n  uint Bits=15;\n  for (uint I=Dec->QuickBits+1;I<15;I++)\n    if (BitField<Dec->DecodeLen[I])\n    {\n      Bits=I;\n      break;\n    }\n\n  Inp.addbits(Bits);\n  \n  // Calculate the distance from the start code for current bit length.\n  uint Dist=BitField-Dec->DecodeLen[Bits-1];\n\n  // Start codes are left aligned, but we need the normal right aligned\n  // number. So we shift the distance to the right.\n  Dist>>=(16-Bits);\n\n  // Now we can calculate the position in the code list. It is the sum\n  // of first position for current bit length and right aligned distance\n  // between our bit field and start code for current bit length.\n  uint Pos=Dec->DecodePos[Bits]+Dist;\n\n  // Out of bounds safety check required for damaged archives.\n  if (Pos>=Dec->MaxNum)\n    Pos=0;\n\n  // Convert the position in the code list to position in alphabet\n  // and return it.\n  return(Dec->DecodeNum[Pos]);\n}\n\n\n_forceinline uint Unpack::SlotToLength(BitInput &Inp,uint Slot)\n{\n  uint LBits,Length=2;\n  if (Slot<8)\n  {\n    LBits=0;\n    Length+=Slot;\n  }\n  else\n  {\n    LBits=Slot/4-1;\n    Length+=(4 | (Slot & 3)) << LBits;\n  }\n\n  if (LBits>0)\n  {\n    Length+=Inp.getbits()>>(16-LBits);\n    Inp.addbits(LBits);\n  }\n  return Length;\n}\n","FragmentedWindow::FragmentedWindow()\n{\n  memset(Mem,0,sizeof(Mem));\n  memset(MemSize,0,sizeof(MemSize));\n}\n\n\nFragmentedWindow::~FragmentedWindow()\n{\n  Reset();\n}\n\n\nvoid FragmentedWindow::Reset()\n{\n  for (uint I=0;I<ASIZE(Mem);I++)\n    if (Mem[I]!=NULL)\n    {\n      free(Mem[I]);\n      Mem[I]=NULL;\n    }\n}\n\n\nvoid FragmentedWindow::Init(size_t WinSize)\n{\n  Reset();\n\n  uint BlockNum=0;\n  size_t TotalSize=0; // Already allocated.\n  while (TotalSize<WinSize && BlockNum<ASIZE(Mem))\n  {\n    size_t Size=WinSize-TotalSize; // Size needed to allocate.\n\n    // Minimum still acceptable block size. Next allocations cannot be larger\n    // than current, so we do not need blocks if they are smaller than\n    // \"size left / attempts left\". Also we do not waste time to blocks\n    // smaller than some arbitrary constant.\n    size_t MinSize=Max(Size/(ASIZE(Mem)-BlockNum), 0x400000);\n\n    byte *NewMem=NULL;\n    while (Size>=MinSize)\n    {\n      NewMem=(byte *)malloc(Size);\n      if (NewMem!=NULL)\n        break;\n      Size-=Size/32;\n    }\n    if (NewMem==NULL)\n      throw std::bad_alloc();\n    \n    // Clean the window to generate the same output when unpacking corrupt\n    // RAR files, which may access to unused areas of sliding dictionary.\n    memset(NewMem,0,Size);\n\n    Mem[BlockNum]=NewMem;\n    TotalSize+=Size;\n    MemSize[BlockNum]=TotalSize;\n    BlockNum++;\n  }\n  if (TotalSize<WinSize) // Not found enough free blocks.\n    throw std::bad_alloc();\n}\n\n\nbyte& FragmentedWindow::operator [](size_t Item)\n{\n  if (Item<MemSize[0])\n    return Mem[0][Item];\n  for (uint I=1;I<ASIZE(MemSize);I++)\n    if (Item<MemSize[I])\n      return Mem[I][Item-MemSize[I-1]];\n  return Mem[0][0]; // Must never happen;\n}\n\n\nvoid FragmentedWindow::CopyString(uint Length,uint Distance,size_t &UnpPtr,size_t MaxWinMask)\n{\n  size_t SrcPtr=UnpPtr-Distance;\n  while (Length-- > 0)\n  {\n    (*this)[UnpPtr]=(*this)[SrcPtr++ & MaxWinMask];\n    // We need to have masked UnpPtr after quit from loop, so it must not\n    // be replaced with '(*this)[UnpPtr++ & MaxWinMask]'\n    UnpPtr=(UnpPtr+1) & MaxWinMask;\n  }\n}\n\n\nvoid FragmentedWindow::CopyData(byte *Dest,size_t WinPos,size_t Size)\n{\n  for (size_t I=0;I<Size;I++)\n    Dest[I]=(*this)[WinPos+I];\n}\n\n\nsize_t FragmentedWindow::GetBlockSize(size_t StartPos,size_t RequiredSize)\n{\n  for (uint I=0;I<ASIZE(MemSize);I++)\n    if (StartPos<MemSize[I])\n      return Min(MemSize[I]-StartPos,RequiredSize);\n  return 0; // Must never be here.\n}\n","#include \"rar.hpp\"\n\nvoid FileHeader::Reset(size_t SubDataSize)\n{\n  SubData.Alloc(SubDataSize);\n  BaseBlock::Reset();\n#ifndef SHELL_EXT\n  FileHash.Init(HASH_NONE);\n#endif\n  mtime.Reset();\n  atime.Reset();\n  ctime.Reset();\n  SplitBefore=false;\n  SplitAfter=false;\n\n  UnknownUnpSize=0;\n\n  SubFlags=0; // Important for RAR 3.0 subhead.\n  \n  CryptMethod=CRYPT_NONE;\n  Encrypted=false;\n  SaltSet=false;\n  UsePswCheck=false;\n  UseHashKey=false;\n  Lg2Count=0;\n\n  Solid=false;\n  Dir=false;\n  WinSize=0;\n  Inherited=false;\n  SubBlock=false;\n  CommentInHeader=false;\n  Version=false;\n  LargeFile=false;\n\n  RedirType=FSREDIR_NONE;\n  UnixOwnerSet=false;\n}\n\n\nFileHeader& FileHeader::operator = (FileHeader &hd)\n{\n  SubData.Reset();\n  memcpy(this,&hd,sizeof(*this));\n  SubData.CleanData();\n  SubData=hd.SubData;\n  return *this;\n}\n\n\nvoid MainHeader::Reset()\n{\n  HighPosAV=0;\n  PosAV=0;\n  CommentInHeader=false;\n  PackComment=false;\n  Locator=false;\n  QOpenOffset=0;\n  QOpenMaxSize=0;\n  RROffset=0;\n  RRMaxSize=0;\n}\n","#include \"rar.hpp\"\n\nCommandData::CommandData()\n{\n  Init();\n}\n\n\nvoid CommandData::Init()\n{\n  RAROptions::Init();\n\n  *Command=0;\n  *ArcName=0;\n  FileLists=false;\n\n  ListMode=RCLM_AUTO;\n\n  BareOutput=false;\n\n\n  FileArgs.Reset();\n  ExclArgs.Reset();\n  InclArgs.Reset();\n  StoreArgs.Reset();\n  ArcNames.Reset();\n  NextVolSizes.Reset();\n}\n\n\n// Return the pointer to next position in the string and store dynamically\n// allocated command line parameter in Par.\nstatic const wchar *AllocCmdParam(const wchar *CmdLine,wchar **Par)\n{\n  const wchar *NextCmd=GetCmdParam(CmdLine,NULL,0);\n  if (NextCmd==NULL)\n    return NULL;\n  size_t ParSize=NextCmd-CmdLine+2; // Parameter size including the trailing zero.\n  *Par=(wchar *)malloc(ParSize*sizeof(wchar));\n  if (*Par==NULL)\n    return NULL;\n  return GetCmdParam(CmdLine,*Par,ParSize);\n}\n\n\n#if !defined(SFX_MODULE) && !defined(_ANDROID)\nvoid CommandData::ParseCommandLine(bool Preprocess,int argc, char *argv[])\n{\n  *Command=0;\n  NoMoreSwitches=false;\n#ifdef CUSTOM_CMDLINE_PARSER\n  // In Windows we may prefer to implement our own command line parser\n  // to avoid replacing \\\" by \" in standard parser. Such replacing corrupts\n  // destination paths like \"dest path\\\" in extraction commands.\n  // Also our own parser is Unicode compatible.\n  const wchar *CmdLine=GetCommandLine();\n\n  wchar *Par;\n  for (bool FirstParam=true;;FirstParam=false)\n  {\n    if ((CmdLine=AllocCmdParam(CmdLine,&Par))==NULL)\n      break;\n    if (!FirstParam) // First parameter is the executable name.\n      if (Preprocess)\n        PreprocessArg(Par);\n      else\n        ParseArg(Par);\n    free(Par);\n  }\n#else\n  Array<wchar> Arg;\n  for (int I=1;I<argc;I++)\n  {\n    Arg.Alloc(strlen(argv[I])+1);\n    CharToWide(argv[I],&Arg[0],Arg.Size());\n    if (Preprocess)\n      PreprocessArg(&Arg[0]);\n    else\n      ParseArg(&Arg[0]);\n  }\n#endif\n  if (!Preprocess)\n    ParseDone();\n}\n#endif\n\n\n#if !defined(SFX_MODULE) && !defined(_ANDROID)\nvoid CommandData::ParseArg(wchar *Arg)\n{\n  if (IsSwitch(*Arg) && !NoMoreSwitches)\n    if (Arg[1]=='-' && Arg[2]==0)\n      NoMoreSwitches=true;\n    else\n      ProcessSwitch(Arg+1);\n  else\n    if (*Command==0)\n    {\n      wcsncpy(Command,Arg,ASIZE(Command));\n\n\n#ifndef GUI\n      *Command=toupperw(*Command);\n      // 'I' and 'S' commands can contain case sensitive strings after\n      // the first character, so we must not modify their case.\n      // 'S' can contain SFX name, which case is important in Unix.\n      if (*Command!='I' && *Command!='S')\n        wcsupper(Command);\n#endif\n    }\n    else\n      if (*ArcName==0)\n        wcsncpyz(ArcName,Arg,ASIZE(ArcName));\n      else\n      {\n        // Check if last character is the path separator.\n        size_t Length=wcslen(Arg);\n        wchar EndChar=Length==0 ? 0:Arg[Length-1];\n        bool EndSeparator=IsDriveDiv(EndChar) || IsPathDiv(EndChar);\n\n        wchar CmdChar=toupperw(*Command);\n        bool Add=wcschr(L\"AFUM\",CmdChar)!=NULL;\n        bool Extract=CmdChar=='X' || CmdChar=='E';\n        if (EndSeparator && !Add)\n          wcsncpyz(ExtrPath,Arg,ASIZE(ExtrPath));\n        else\n          if ((Add || CmdChar=='T') && (*Arg!='@' || ListMode==RCLM_REJECT_LISTS))\n            FileArgs.AddString(Arg);\n          else\n          {\n            FindData FileData;\n            bool Found=FindFile::FastFind(Arg,&FileData);\n            if ((!Found || ListMode==RCLM_ACCEPT_LISTS) && \n                ListMode!=RCLM_REJECT_LISTS && *Arg=='@' && !IsWildcard(Arg))\n            {\n              FileLists=true;\n\n              RAR_CHARSET Charset=FilelistCharset;\n\n#if defined(_WIN_ALL) && !defined(GUI)\n              // for compatibility reasons we use OEM encoding\n              // in Win32 console version by default\n\n//              if (Charset==RCH_DEFAULT)\n//                Charset=RCH_OEM;\n#endif\n\n              ReadTextFile(Arg+1,&FileArgs,false,true,Charset,true,true,true);\n\n            }\n            else\n              if (Found && FileData.IsDir && Extract && *ExtrPath==0)\n              {\n                wcsncpyz(ExtrPath,Arg,ASIZE(ExtrPath));\n                AddEndSlash(ExtrPath,ASIZE(ExtrPath));\n              }\n              else\n                FileArgs.AddString(Arg);\n          }\n      }\n}\n#endif\n\n\nvoid CommandData::ParseDone()\n{\n  if (FileArgs.ItemsCount()==0 && !FileLists)\n    FileArgs.AddString(MASKALL);\n  wchar CmdChar=toupperw(Command[0]);\n  bool Extract=CmdChar=='X' || CmdChar=='E' || CmdChar=='P';\n  if (Test && Extract)\n    Test=false;        // Switch '-t' is senseless for 'X', 'E', 'P' commands.\n\n  // Suppress the copyright message and final end of line for 'lb' and 'vb'.\n  if ((CmdChar=='L' || CmdChar=='V') && Command[1]=='B')\n    BareOutput=true;\n}\n\n\n#if !defined(SFX_MODULE) && !defined(_ANDROID)\nvoid CommandData::ParseEnvVar()\n{\n  char *EnvStr=getenv(\"RAR\");\n  if (EnvStr!=NULL)\n  {\n    Array<wchar> EnvStrW(strlen(EnvStr)+1);\n    CharToWide(EnvStr,&EnvStrW[0],EnvStrW.Size());\n    ProcessSwitchesString(&EnvStrW[0]);\n  }\n}\n#endif\n\n\n\n#if !defined(SFX_MODULE) && !defined(_ANDROID)\n// Preprocess those parameters, which must be processed before the rest of\n// command line. Return 'false' to stop further processing.\nvoid CommandData::PreprocessArg(const wchar *Arg)\n{\n  if (IsSwitch(Arg[0]) && !NoMoreSwitches)\n  {\n    Arg++;\n    if (Arg[0]=='-' && Arg[1]==0) // Switch \"--\".\n      NoMoreSwitches=true;\n    if (wcsicomp(Arg,L\"cfg-\")==0)\n      ConfigDisabled=true;\n#ifndef GUI\n    if (wcsnicomp(Arg,L\"ilog\",4)==0)\n    {\n      // Ensure that correct log file name is already set\n      // if we need to report an error when processing the command line.\n      ProcessSwitch(Arg);\n      InitLogOptions(LogName,ErrlogCharset);\n    }\n#endif\n    if (wcsnicomp(Arg,L\"sc\",2)==0)\n    {\n      // Process -sc before reading any file lists.\n      ProcessSwitch(Arg);\n#ifndef GUI\n      if (*LogName!=0)\n        InitLogOptions(LogName,ErrlogCharset);\n#endif\n    }\n  }\n  else\n    if (*Command==0)\n      wcsncpy(Command,Arg,ASIZE(Command)); // Need for rar.ini.\n}\n#endif\n\n\n#if !defined(GUI) && !defined(SFX_MODULE) && !defined(_ANDROID)\nvoid CommandData::ReadConfig()\n{\n  StringList List;\n  if (ReadTextFile(DefConfigName,&List,true))\n  {\n    wchar *Str;\n    while ((Str=List.GetString())!=NULL)\n    {\n      while (IsSpace(*Str))\n        Str++;\n      if (wcsnicomp(Str,L\"switches=\",9)==0)\n        ProcessSwitchesString(Str+9);\n      if (*Command!=0)\n      {\n        wchar Cmd[16];\n        wcsncpyz(Cmd,Command,ASIZE(Cmd));\n        wchar C0=toupperw(Cmd[0]);\n        wchar C1=toupperw(Cmd[1]);\n        if (C0=='I' || C0=='L' || C0=='M' || C0=='S' || C0=='V')\n          Cmd[1]=0;\n        if (C0=='R' && (C1=='R' || C1=='V'))\n          Cmd[2]=0;\n        wchar SwName[16+ASIZE(Cmd)];\n        swprintf(SwName,ASIZE(SwName),L\"switches_%s=\",Cmd);\n        size_t Length=wcslen(SwName);\n        if (wcsnicomp(Str,SwName,Length)==0)\n          ProcessSwitchesString(Str+Length);\n      }\n    }\n  }\n}\n#endif\n\n\n#if !defined(SFX_MODULE) && !defined(_ANDROID)\nvoid CommandData::ProcessSwitchesString(const wchar *Str)\n{\n  wchar *Par;\n  while ((Str=AllocCmdParam(Str,&Par))!=NULL)\n  {\n    if (IsSwitch(*Par))\n      ProcessSwitch(Par+1);\n    free(Par);\n  }\n}\n#endif\n\n\n#if !defined(SFX_MODULE) && !defined(_ANDROID)\nvoid CommandData::ProcessSwitch(const wchar *Switch)\n{\n\n  switch(toupperw(Switch[0]))\n  {\n    case '@':\n      ListMode=Switch[1]=='+' ? RCLM_ACCEPT_LISTS:RCLM_REJECT_LISTS;\n      break;\n    case 'A':\n      switch(toupperw(Switch[1]))\n      {\n        case 'C':\n          ClearArc=true;\n          break;\n        case 'D':\n          AppendArcNameToPath=true;\n          break;\n#ifndef SFX_MODULE\n        case 'G':\n          if (Switch[2]=='-' && Switch[3]==0)\n            GenerateArcName=0;\n          else\n          {\n            GenerateArcName=true;\n            wcsncpyz(GenerateMask,Switch+2,ASIZE(GenerateMask));\n          }\n          break;\n#endif\n        case 'I':\n          IgnoreGeneralAttr=true;\n          break;\n        case 'N': // Reserved for archive name.\n          break;\n        case 'O':\n          AddArcOnly=true;\n          break;\n        case 'P':\n          wcscpy(ArcPath,Switch+2);\n          break;\n        case 'S':\n          SyncFiles=true;\n          break;\n        default:\n          BadSwitch(Switch);\n          break;\n      }\n      break;\n    case 'C':\n      if (Switch[2]==0)\n        switch(toupperw(Switch[1]))\n        {\n          case '-':\n            DisableComment=true;\n            break;\n          case 'U':\n            ConvertNames=NAMES_UPPERCASE;\n            break;\n          case 'L':\n            ConvertNames=NAMES_LOWERCASE;\n            break;\n        }\n      break;\n    case 'D':\n      if (Switch[2]==0)\n        switch(toupperw(Switch[1]))\n        {\n          case 'S':\n            DisableSortSolid=true;\n            break;\n          case 'H':\n            OpenShared=true;\n            break;\n          case 'F':\n            DeleteFiles=true;\n            break;\n        }\n      break;\n    case 'E':\n      switch(toupperw(Switch[1]))\n      {\n        case 'P':\n          switch(Switch[2])\n          {\n            case 0:\n              ExclPath=EXCL_SKIPWHOLEPATH;\n              break;\n            case '1':\n              ExclPath=EXCL_BASEPATH;\n              break;\n            case '2':\n              ExclPath=EXCL_SAVEFULLPATH;\n              break;\n            case '3':\n              ExclPath=EXCL_ABSPATH;\n              break;\n          }\n          break;\n        default:\n          if (Switch[1]=='+')\n          {\n            InclFileAttr|=GetExclAttr(Switch+2);\n            InclAttrSet=true;\n          }\n          else\n            ExclFileAttr|=GetExclAttr(Switch+1);\n          break;\n      }\n      break;\n    case 'F':\n      if (Switch[1]==0)\n        FreshFiles=true;\n      else\n        BadSwitch(Switch);\n      break;\n    case 'H':\n      switch (toupperw(Switch[1]))\n      {\n        case 'P':\n          EncryptHeaders=true;\n          if (Switch[2]!=0)\n          {\n            Password.Set(Switch+2);\n            cleandata((void *)Switch,wcslen(Switch)*sizeof(Switch[0]));\n          }\n          else\n            if (!Password.IsSet())\n            {\n              uiGetPassword(UIPASSWORD_GLOBAL,NULL,&Password);\n              eprintf(L\"\\n\");\n            }\n          break;\n        default :\n          BadSwitch(Switch);\n          break;\n      }\n      break;\n    case 'I':\n      if (wcsnicomp(Switch+1,L\"LOG\",3)==0)\n      {\n        wcsncpyz(LogName,Switch[4]!=0 ? Switch+4:DefLogName,ASIZE(LogName));\n        break;\n      }\n      if (wcsicomp(Switch+1,L\"SND\")==0)\n      {\n        Sound=true;\n        break;\n      }\n      if (wcsicomp(Switch+1,L\"ERR\")==0)\n      {\n        MsgStream=MSG_STDERR;\n        break;\n      }\n      if (wcsnicomp(Switch+1,L\"EML\",3)==0)\n      {\n        wcsncpyz(EmailTo,Switch[4]!=0 ? Switch+4:L\"@\",ASIZE(EmailTo));\n        break;\n      }\n      if (wcsicomp(Switch+1,L\"NUL\")==0)\n      {\n        MsgStream=MSG_NULL;\n        break;\n      }\n      if (toupperw(Switch[1])=='D')\n      {\n        for (uint I=2;Switch[I]!=0;I++)\n          switch(toupperw(Switch[I]))\n          {\n            case 'Q':\n              MsgStream=MSG_ERRONLY;\n              break;\n            case 'C':\n              DisableCopyright=true;\n              break;\n            case 'D':\n              DisableDone=true;\n              break;\n            case 'P':\n              DisablePercentage=true;\n              break;\n          }\n        break;\n      }\n      if (wcsicomp(Switch+1,L\"OFF\")==0)\n      {\n        Shutdown=true;\n        break;\n      }\n      if (wcsicomp(Switch+1,L\"VER\")==0)\n      {\n        PrintVersion=true;\n        break;\n      }\n      break;\n    case 'K':\n      switch(toupperw(Switch[1]))\n      {\n        case 'B':\n          KeepBroken=true;\n          break;\n        case 0:\n          Lock=true;\n          break;\n      }\n      break;\n    case 'M':\n      switch(toupperw(Switch[1]))\n      {\n        case 'C':\n          {\n            const wchar *Str=Switch+2;\n            if (*Str=='-')\n              for (uint I=0;I<ASIZE(FilterModes);I++)\n                FilterModes[I].State=FILTER_DISABLE;\n            else\n              while (*Str!=0)\n              {\n                int Param1=0,Param2=0;\n                FilterState State=FILTER_AUTO;\n                FilterType Type=FILTER_NONE;\n                if (IsDigit(*Str))\n                {\n                  Param1=atoiw(Str);\n                  while (IsDigit(*Str))\n                    Str++;\n                }\n                if (*Str==':' && IsDigit(Str[1]))\n                {\n                  Param2=atoiw(++Str);\n                  while (IsDigit(*Str))\n                    Str++;\n                }\n                switch(toupperw(*(Str++)))\n                {\n                  case 'T': Type=FILTER_PPM;         break;\n                  case 'E': Type=FILTER_E8;          break;\n                  case 'D': Type=FILTER_DELTA;       break;\n                  case 'A': Type=FILTER_AUDIO;       break;\n                  case 'C': Type=FILTER_RGB;         break;\n                  case 'I': Type=FILTER_ITANIUM;     break;\n                  case 'R': Type=FILTER_ARM;         break;\n                }\n                if (*Str=='+' || *Str=='-')\n                  State=*(Str++)=='+' ? FILTER_FORCE:FILTER_DISABLE;\n                FilterModes[Type].State=State;\n                FilterModes[Type].Param1=Param1;\n                FilterModes[Type].Param2=Param2;\n              }\n            }\n          break;\n        case 'M':\n          break;\n        case 'D':\n          break;\n        case 'S':\n          {\n            wchar StoreNames[1024];\n            wcsncpyz(StoreNames,(Switch[2]==0 ? DefaultStoreList:Switch+2),ASIZE(StoreNames));\n            wchar *Names=StoreNames;\n            while (*Names!=0)\n            {\n              wchar *End=wcschr(Names,';');\n              if (End!=NULL)\n                *End=0;\n              if (*Names=='.')\n                Names++;\n              wchar Mask[NM];\n              if (wcspbrk(Names,L\"*?.\")==NULL)\n                swprintf(Mask,ASIZE(Mask),L\"*.%ls\",Names);\n              else\n                wcsncpyz(Mask,Names,ASIZE(Mask));\n              StoreArgs.AddString(Mask);\n              if (End==NULL)\n                break;\n              Names=End+1;\n            }\n          }\n          break;\n#ifdef RAR_SMP\n        case 'T':\n          Threads=atoiw(Switch+2);\n          if (Threads>MaxPoolThreads || Threads<1)\n            BadSwitch(Switch);\n          else\n          {\n          }\n          break;\n#endif\n        default:\n          Method=Switch[1]-'0';\n          if (Method>5 || Method<0)\n            BadSwitch(Switch);\n          break;\n      }\n      break;\n    case 'N':\n    case 'X':\n      if (Switch[1]!=0)\n      {\n        StringList *Args=toupperw(Switch[0])=='N' ? &InclArgs:&ExclArgs;\n        if (Switch[1]=='@' && !IsWildcard(Switch))\n        {\n          RAR_CHARSET Charset=FilelistCharset;\n\n#if defined(_WIN_ALL) && !defined(GUI)\n          // for compatibility reasons we use OEM encoding\n          // in Win32 console version by default\n\n//          if (Charset==RCH_DEFAULT)\n//            Charset=RCH_OEM;\n#endif\n\n          ReadTextFile(Switch+2,Args,false,true,Charset,true,true,true);\n        }\n        else\n          Args->AddString(Switch+1);\n      }\n      break;\n    case 'O':\n      switch(toupperw(Switch[1]))\n      {\n        case '+':\n          Overwrite=OVERWRITE_ALL;\n          break;\n        case '-':\n          Overwrite=OVERWRITE_NONE;\n          break;\n        case 0:\n          Overwrite=OVERWRITE_FORCE_ASK;\n          break;\n#ifdef _WIN_ALL\n        case 'C':\n          SetCompressedAttr=true;\n          break;\n#endif\n        case 'H':\n          SaveHardLinks=true;\n          break;\n\n\n#ifdef SAVE_LINKS\n        case 'L':\n          SaveSymLinks=true;\n          if (toupperw(Switch[2])=='A')\n            AbsoluteLinks=true;\n          break;\n#endif\n#ifdef _WIN_ALL\n        case 'N':\n          if (toupperw(Switch[2])=='I')\n            AllowIncompatNames=true;\n          break;\n#endif\n        case 'R':\n          Overwrite=OVERWRITE_AUTORENAME;\n          break;\n#ifdef _WIN_ALL\n        case 'S':\n          SaveStreams=true;\n          break;\n#endif\n        case 'W':\n          ProcessOwners=true;\n          break;\n        default :\n          BadSwitch(Switch);\n          break;\n      }\n      break;\n    case 'P':\n      if (Switch[1]==0)\n      {\n        uiGetPassword(UIPASSWORD_GLOBAL,NULL,&Password);\n        eprintf(L\"\\n\");\n      }\n      else\n      {\n        Password.Set(Switch+1);\n        cleandata((void *)Switch,wcslen(Switch)*sizeof(Switch[0]));\n      }\n      break;\n#ifndef SFX_MODULE\n    case 'Q':\n      if (toupperw(Switch[1])=='O')\n        switch(toupperw(Switch[2]))\n        {\n          case 0:\n            QOpenMode=QOPEN_AUTO;\n            break;\n          case '-':\n            QOpenMode=QOPEN_NONE;\n            break;\n          case '+':\n            QOpenMode=QOPEN_ALWAYS;\n            break;\n          default:\n            BadSwitch(Switch);\n            break;\n        }\n      else\n        BadSwitch(Switch);\n      break;\n#endif\n    case 'R':\n      switch(toupperw(Switch[1]))\n      {\n        case 0:\n          Recurse=RECURSE_ALWAYS;\n          break;\n        case '-':\n          Recurse=RECURSE_DISABLE;\n          break;\n        case '0':\n          Recurse=RECURSE_WILDCARDS;\n          break;\n        case 'I':\n          {\n            Priority=atoiw(Switch+2);\n            if (Priority<0 || Priority>15)\n              BadSwitch(Switch);\n            const wchar *ChPtr=wcschr(Switch+2,':');\n            if (ChPtr!=NULL)\n            {\n              SleepTime=atoiw(ChPtr+1);\n              if (SleepTime>1000)\n                BadSwitch(Switch);\n              InitSystemOptions(SleepTime);\n            }\n            SetPriority(Priority);\n          }\n          break;\n      }\n      break;\n    case 'S':\n      if (IsDigit(Switch[1]))\n      {\n        Solid|=SOLID_COUNT;\n        SolidCount=atoiw(&Switch[1]);\n      }\n      else\n        switch(toupperw(Switch[1]))\n        {\n          case 0:\n            Solid|=SOLID_NORMAL;\n            break;\n          case '-':\n            Solid=SOLID_NONE;\n            break;\n          case 'E':\n            Solid|=SOLID_FILEEXT;\n            break;\n          case 'V':\n            Solid|=Switch[2]=='-' ? SOLID_VOLUME_DEPENDENT:SOLID_VOLUME_INDEPENDENT;\n            break;\n          case 'D':\n            Solid|=SOLID_VOLUME_DEPENDENT;\n            break;\n          case 'L':\n            if (IsDigit(Switch[2]))\n              FileSizeLess=atoilw(Switch+2);\n            break;\n          case 'M':\n            if (IsDigit(Switch[2]))\n              FileSizeMore=atoilw(Switch+2);\n            break;\n          case 'C':\n            {\n              bool AlreadyBad=false; // Avoid reporting \"bad switch\" several times.\n\n              RAR_CHARSET rch=RCH_DEFAULT;\n              switch(toupperw(Switch[2]))\n              {\n                case 'A':\n                  rch=RCH_ANSI;\n                  break;\n                case 'O':\n                  rch=RCH_OEM;\n                  break;\n                case 'U':\n                  rch=RCH_UNICODE;\n                  break;\n                default :\n                  BadSwitch(Switch);\n                  AlreadyBad=true;\n                  break;\n              };\n              if (!AlreadyBad)\n                if (Switch[3]==0)\n                  CommentCharset=FilelistCharset=ErrlogCharset=rch;\n                else\n                  for (uint I=3;Switch[I]!=0 && !AlreadyBad;I++)\n                    switch(toupperw(Switch[I]))\n                    {\n                      case 'C':\n                        CommentCharset=rch;\n                        break;\n                      case 'L':\n                        FilelistCharset=rch;\n                        break;\n                      case 'R':\n                        RedirectCharset=rch;\n                        break;\n                      default:\n                        BadSwitch(Switch);\n                        AlreadyBad=true;\n                        break;\n                    }\n            }\n            break;\n\n        }\n      break;\n    case 'T':\n      switch(toupperw(Switch[1]))\n      {\n        case 'K':\n          ArcTime=ARCTIME_KEEP;\n          break;\n        case 'L':\n          ArcTime=ARCTIME_LATEST;\n          break;\n        case 'O':\n          FileTimeBefore.SetAgeText(Switch+2);\n          break;\n        case 'N':\n          FileTimeAfter.SetAgeText(Switch+2);\n          break;\n        case 'B':\n          FileTimeBefore.SetIsoText(Switch+2);\n          break;\n        case 'A':\n          FileTimeAfter.SetIsoText(Switch+2);\n          break;\n        case 'S':\n          {\n            EXTTIME_MODE Mode=EXTTIME_HIGH3;\n            bool CommonMode=Switch[2]>='0' && Switch[2]<='4';\n            if (CommonMode)\n              Mode=(EXTTIME_MODE)(Switch[2]-'0');\n            if (Switch[2]=='-')\n              Mode=EXTTIME_NONE;\n            if (CommonMode || Switch[2]=='-' || Switch[2]=='+' || Switch[2]==0)\n              xmtime=xctime=xatime=Mode;\n            else\n            {\n              if (Switch[3]>='0' && Switch[3]<='4')\n                Mode=(EXTTIME_MODE)(Switch[3]-'0');\n              if (Switch[3]=='-')\n                Mode=EXTTIME_NONE;\n              switch(toupperw(Switch[2]))\n              {\n                case 'M':\n                  xmtime=Mode;\n                  break;\n                case 'C':\n                  xctime=Mode;\n                  break;\n                case 'A':\n                  xatime=Mode;\n                  break;\n              }\n            }\n          }\n          break;\n        case '-':\n          Test=false;\n          break;\n        case 0:\n          Test=true;\n          break;\n        default:\n          BadSwitch(Switch);\n          break;\n      }\n      break;\n    case 'U':\n      if (Switch[1]==0)\n        UpdateFiles=true;\n      else\n        BadSwitch(Switch);\n      break;\n    case 'V':\n      switch(toupperw(Switch[1]))\n      {\n        case 'P':\n          VolumePause=true;\n          break;\n        case 'E':\n          if (toupperw(Switch[2])=='R')\n            VersionControl=atoiw(Switch+3)+1;\n          break;\n        case '-':\n          VolSize=0;\n          break;\n        default:\n          VolSize=VOLSIZE_AUTO; // UnRAR -v switch for list command.\n          break;\n      }\n      break;\n    case 'W':\n      wcsncpyz(TempPath,Switch+1,ASIZE(TempPath));\n      AddEndSlash(TempPath,ASIZE(TempPath));\n      break;\n    case 'Y':\n      AllYes=true;\n      break;\n    case 'Z':\n      if (Switch[1]==0)\n      {\n#ifndef GUI // stdin is not supported by WinRAR.\n        // If comment file is not specified, we read data from stdin.\n        wcscpy(CommentFile,L\"stdin\");\n#endif\n      }\n      else\n        wcsncpyz(CommentFile,Switch+1,ASIZE(CommentFile));\n      break;\n#ifndef GUI\n    case '?' :\n      OutHelp(RARX_SUCCESS);\n      break;\n#endif\n    default :\n      BadSwitch(Switch);\n      break;\n  }\n}\n#endif\n\n\n#if !defined(SFX_MODULE) && !defined(_ANDROID)\nvoid CommandData::BadSwitch(const wchar *Switch)\n{\n  mprintf(St(MUnknownOption),Switch);\n  ErrHandler.Exit(RARX_USERERROR);\n}\n#endif\n\n\n#ifndef GUI\nvoid CommandData::OutTitle()\n{\n  if (BareOutput || DisableCopyright)\n    return;\n#if defined(__GNUC__) && defined(SFX_MODULE)\n  mprintf(St(MCopyrightS));\n#else\n#ifndef SILENT\n  static bool TitleShown=false;\n  if (TitleShown)\n    return;\n  TitleShown=true;\n\n  wchar Version[80];\n  if (RARVER_BETA!=0)\n    swprintf(Version,ASIZE(Version),L\"%d.%02d %ls %d\",RARVER_MAJOR,RARVER_MINOR,St(MBeta),RARVER_BETA);\n  else\n    swprintf(Version,ASIZE(Version),L\"%d.%02d\",RARVER_MAJOR,RARVER_MINOR);\n#if defined(_WIN_32) || defined(_WIN_64)\n  wcsncatz(Version,L\" \",ASIZE(Version));\n#endif\n#ifdef _WIN_32\n  wcsncatz(Version,St(Mx86),ASIZE(Version));\n#endif\n#ifdef _WIN_64\n  wcsncatz(Version,St(Mx64),ASIZE(Version));\n#endif\n  if (PrintVersion)\n  {\n    mprintf(L\"%s\",Version);\n    exit(0);\n  }\n#ifdef UNRAR\n  mprintf(St(MUCopyright),Version,RARVER_YEAR);\n#else\n#endif\n#endif\n#endif\n}\n#endif\n\n\ninline bool CmpMSGID(MSGID i1,MSGID i2)\n{\n#ifdef MSGID_INT\n  return i1==i2;\n#else\n  // If MSGID is const char*, we cannot compare pointers only.\n  // Pointers to different instances of same string can differ,\n  // so we need to compare complete strings.\n  return wcscmp(i1,i2)==0;\n#endif\n}\n\nvoid CommandData::OutHelp(RAR_EXIT ExitCode)\n{\n#if !defined(GUI) && !defined(SILENT)\n  OutTitle();\n  static MSGID Help[]={\n#ifdef SFX_MODULE\n    // Console SFX switches definition.\n    MCHelpCmd,MSHelpCmdE,MSHelpCmdT,MSHelpCmdV\n#elif defined(UNRAR)\n    // UnRAR switches definition.\n    MUNRARTitle1,MRARTitle2,MCHelpCmd,MCHelpCmdE,MCHelpCmdL,\n    MCHelpCmdP,MCHelpCmdT,MCHelpCmdV,MCHelpCmdX,MCHelpSw,MCHelpSwm,\n    MCHelpSwAT,MCHelpSwAC,MCHelpSwAD,MCHelpSwAG,MCHelpSwAI,MCHelpSwAP,\n    MCHelpSwCm,MCHelpSwCFGm,MCHelpSwCL,MCHelpSwCU,\n    MCHelpSwDH,MCHelpSwEP,MCHelpSwEP3,MCHelpSwF,MCHelpSwIDP,MCHelpSwIERR,\n    MCHelpSwINUL,MCHelpSwIOFF,MCHelpSwKB,MCHelpSwN,MCHelpSwNa,MCHelpSwNal,\n    MCHelpSwO,MCHelpSwOC,MCHelpSwOL,MCHelpSwOR,MCHelpSwOW,MCHelpSwP,\n    MCHelpSwPm,MCHelpSwR,MCHelpSwRI,MCHelpSwSC,MCHelpSwSL,MCHelpSwSM,\n    MCHelpSwTA,MCHelpSwTB,MCHelpSwTN,MCHelpSwTO,MCHelpSwTS,MCHelpSwU,\n    MCHelpSwVUnr,MCHelpSwVER,MCHelpSwVP,MCHelpSwX,MCHelpSwXa,MCHelpSwXal,\n    MCHelpSwY\n#else\n#endif\n  };\n\n  for (uint I=0;I<ASIZE(Help);I++)\n  {\n#ifndef SFX_MODULE\n    if (CmpMSGID(Help[I],MCHelpSwV))\n      continue;\n#ifndef _WIN_ALL\n    static MSGID Win32Only[]={\n      MCHelpSwIEML,MCHelpSwVD,MCHelpSwAO,MCHelpSwOS,MCHelpSwIOFF,\n      MCHelpSwEP2,MCHelpSwOC,MCHelpSwONI,MCHelpSwDR,MCHelpSwRI\n    };\n    bool Found=false;\n    for (int J=0;J<sizeof(Win32Only)/sizeof(Win32Only[0]);J++)\n      if (CmpMSGID(Help[I],Win32Only[J]))\n      {\n        Found=true;\n        break;\n      }\n    if (Found)\n      continue;\n#endif\n#if !defined(_UNIX) && !defined(_WIN_ALL)\n    if (CmpMSGID(Help[I],MCHelpSwOW))\n      continue;\n#endif\n#if !defined(_WIN_ALL) && !defined(_EMX)\n    if (CmpMSGID(Help[I],MCHelpSwAC))\n      continue;\n#endif\n#ifndef SAVE_LINKS\n    if (CmpMSGID(Help[I],MCHelpSwOL))\n      continue;\n#endif\n#ifndef RAR_SMP\n    if (CmpMSGID(Help[I],MCHelpSwMT))\n      continue;\n#endif\n#endif\n    mprintf(St(Help[I]));\n  }\n  mprintf(L\"\\n\");\n  ErrHandler.Exit(ExitCode);\n#endif\n}\n\n\n// Return 'true' if we need to exclude the file from processing as result\n// of -x switch. If CheckInclList is true, we also check the file against\n// the include list created with -n switch.\nbool CommandData::ExclCheck(const wchar *CheckName,bool Dir,bool CheckFullPath,bool CheckInclList)\n{\n  if (CheckArgs(&ExclArgs,Dir,CheckName,CheckFullPath,MATCH_WILDSUBPATH))\n    return true;\n  if (!CheckInclList || InclArgs.ItemsCount()==0)\n    return false;\n  if (CheckArgs(&InclArgs,Dir,CheckName,CheckFullPath,MATCH_WILDSUBPATH))\n    return false;\n  return true;\n}\n\n\nbool CommandData::CheckArgs(StringList *Args,bool Dir,const wchar *CheckName,bool CheckFullPath,int MatchMode)\n{\n  wchar *Name=ConvertPath(CheckName,NULL);\n  wchar FullName[NM];\n  wchar CurMask[NM];\n  *FullName=0;\n  Args->Rewind();\n  while (Args->GetString(CurMask,ASIZE(CurMask)))\n  {\n    wchar *LastMaskChar=PointToLastChar(CurMask);\n    bool DirMask=IsPathDiv(*LastMaskChar); // Mask for directories only.\n\n    if (Dir)\n    {\n      // CheckName is a directory.\n      if (DirMask)\n      {\n        // We process the directory and have the directory exclusion mask.\n        // So let's convert \"mask\\\" to \"mask\" and process it normally.\n        \n        *LastMaskChar=0;\n      }\n      else\n      {\n        // REMOVED, we want -npath\\* to match empty folders too.\n        // If mask has wildcards in name part and does not have the trailing\n        // '\\' character, we cannot use it for directories.\n      \n        // if (IsWildcard(PointToName(CurMask)))\n        //  continue;\n      }\n    }\n    else\n    {\n      // If we process a file inside of directory excluded by \"dirmask\\\".\n      // we want to exclude such file too. So we convert \"dirmask\\\" to\n      // \"dirmask\\*\". It is important for operations other than archiving\n      // with -x. When archiving with -x, directory matched by \"dirmask\\\"\n      // is excluded from further scanning.\n\n      if (DirMask)\n        wcsncatz(CurMask,L\"*\",ASIZE(CurMask));\n    }\n\n#ifndef SFX_MODULE\n    if (CheckFullPath && IsFullPath(CurMask))\n    {\n      // We do not need to do the special \"*\\\" processing here, because\n      // unlike the \"else\" part of this \"if\", now we convert names to full\n      // format, so they all include the path, which is matched by \"*\\\"\n      // correctly. Moreover, removing \"*\\\" from mask would break\n      // the comparison, because now all names have the path.\n\n      if (*FullName==0)\n        ConvertNameToFull(CheckName,FullName,ASIZE(FullName));\n      if (CmpName(CurMask,FullName,MatchMode))\n        return true;\n    }\n    else\n#endif\n    {\n      wchar NewName[NM+2],*CurName=Name;\n\n      // Important to convert before \"*\\\" check below, so masks like\n      // d:*\\something are processed properly.\n      wchar *CmpMask=ConvertPath(CurMask,NULL);\n\n      if (CmpMask[0]=='*' && IsPathDiv(CmpMask[1]))\n      {\n        // We want \"*\\name\" to match 'name' not only in subdirectories,\n        // but also in the current directory. We convert the name\n        // from 'name' to '.\\name' to be matched by \"*\\\" part even if it is\n        // in current directory.\n        NewName[0]='.';\n        NewName[1]=CPATHDIVIDER;\n        wcsncpyz(NewName+2,Name,ASIZE(NewName)-2);\n        CurName=NewName;\n      }\n\n      if (CmpName(CmpMask,CurName,MatchMode))\n        return true;\n    }\n  }\n  return false;\n}\n\n\n#ifndef SFX_MODULE\n// Now this function performs only one task and only in Windows version:\n// it skips symlinks to directories if -e1024 switch is specified.\n// Symlinks are skipped in ScanTree class, so their entire contents\n// is skipped too. Without this function we would check the attribute\n// only directly before archiving, so we would skip the symlink record,\n// but not the contents of symlinked directory.\nbool CommandData::ExclDirByAttr(uint FileAttr)\n{\n#ifdef _WIN_ALL\n  if ((FileAttr & FILE_ATTRIBUTE_REPARSE_POINT)!=0 &&\n      (ExclFileAttr & FILE_ATTRIBUTE_REPARSE_POINT)!=0)\n    return true;\n#endif\n  return false;\n}\n#endif\n\n\n\n\n#ifndef SFX_MODULE\n// Return 'true' if we need to exclude the file from processing.\nbool CommandData::TimeCheck(RarTime &ft)\n{\n  if (FileTimeBefore.IsSet() && ft>=FileTimeBefore)\n    return true;\n  if (FileTimeAfter.IsSet() && ft<=FileTimeAfter)\n    return true;\n  return false;\n}\n#endif\n\n\n#ifndef SFX_MODULE\n// Return 'true' if we need to exclude the file from processing.\nbool CommandData::SizeCheck(int64 Size)\n{\n  if (FileSizeLess!=INT64NDF && Size>=FileSizeLess)\n    return(true);\n  if (FileSizeMore!=INT64NDF && Size<=FileSizeMore)\n    return(true);\n  return(false);\n}\n#endif\n\n\n\n\nint CommandData::IsProcessFile(FileHeader &FileHead,bool *ExactMatch,int MatchType,\n                               wchar *MatchedArg,uint MatchedArgSize)\n{\n  if (MatchedArg!=NULL && MatchedArgSize>0)\n    *MatchedArg=0;\n  if (wcslen(FileHead.FileName)>=NM)\n    return 0;\n  bool Dir=FileHead.Dir;\n  if (ExclCheck(FileHead.FileName,Dir,false,true))\n    return 0;\n#ifndef SFX_MODULE\n  if (TimeCheck(FileHead.mtime))\n    return 0;\n  if ((FileHead.FileAttr & ExclFileAttr)!=0 || InclAttrSet && (FileHead.FileAttr & InclFileAttr)==0)\n    return 0;\n  if (!Dir && SizeCheck(FileHead.UnpSize))\n    return 0;\n#endif\n  wchar *ArgName;\n  FileArgs.Rewind();\n  for (int StringCount=1;(ArgName=FileArgs.GetString())!=NULL;StringCount++)\n    if (CmpName(ArgName,FileHead.FileName,MatchType))\n    {\n      if (ExactMatch!=NULL)\n        *ExactMatch=wcsicompc(ArgName,FileHead.FileName)==0;\n      if (MatchedArg!=NULL)\n        wcsncpyz(MatchedArg,ArgName,MatchedArgSize);\n      return StringCount;\n    }\n  return 0;\n}\n\n\n#ifndef GUI\nvoid CommandData::ProcessCommand()\n{\n#ifndef SFX_MODULE\n\n  const wchar *SingleCharCommands=L\"FUADPXETK\";\n  if (Command[0]!=0 && Command[1]!=0 && wcschr(SingleCharCommands,Command[0])!=NULL || *ArcName==0)\n    OutHelp(*Command==0 ? RARX_SUCCESS:RARX_USERERROR); // Return 'success' for 'rar' without parameters.\n\n  const wchar *ArcExt=GetExt(ArcName);\n#ifdef _UNIX\n  if (ArcExt==NULL && (!FileExist(ArcName) || IsDir(GetFileAttr(ArcName))))\n    wcsncatz(ArcName,L\".rar\",ASIZE(ArcName));\n#else\n  if (ArcExt==NULL)\n    wcsncatz(ArcName,L\".rar\",ASIZE(ArcName));\n#endif\n  // Treat arcname.part1 as arcname.part1.rar.\n  if (ArcExt!=NULL && wcsnicomp(ArcExt,L\".part\",5)==0 && IsDigit(ArcExt[5]) &&\n      !FileExist(ArcName))\n  {\n    wchar Name[NM];\n    wcsncpyz(Name,ArcName,ASIZE(Name));\n    wcsncatz(Name,L\".rar\",ASIZE(Name));\n    if (FileExist(Name))\n      wcsncpyz(ArcName,Name,ASIZE(ArcName));\n  }\n\n  if (wcschr(L\"AFUMD\",*Command)==NULL)\n  {\n    if (GenerateArcName)\n      GenerateArchiveName(ArcName,ASIZE(ArcName),GenerateMask,false);\n\n    StringList ArcMasks;\n    ArcMasks.AddString(ArcName);\n    ScanTree Scan(&ArcMasks,Recurse,SaveSymLinks,SCAN_SKIPDIRS);\n    FindData FindData;\n    while (Scan.GetNext(&FindData)==SCAN_SUCCESS)\n      AddArcName(FindData.Name);\n  }\n  else\n    AddArcName(ArcName);\n#endif\n\n  switch(Command[0])\n  {\n    case 'P':\n    case 'X':\n    case 'E':\n    case 'T':\n    case 'I':\n      {\n        CmdExtract Extract(this);\n        Extract.DoExtract();\n      }\n      break;\n#ifndef SILENT\n    case 'V':\n    case 'L':\n      ListArchive(this);\n      break;\n    default:\n      OutHelp(RARX_USERERROR);\n#endif\n  }\n  if (!BareOutput)\n    mprintf(L\"\\n\");\n}\n#endif\n\n\nvoid CommandData::AddArcName(const wchar *Name)\n{\n  ArcNames.AddString(Name);\n}\n\n\nbool CommandData::GetArcName(wchar *Name,int MaxSize)\n{\n  return ArcNames.GetString(Name,MaxSize);\n}\n\n\nbool CommandData::IsSwitch(int Ch)\n{\n#if defined(_WIN_ALL) || defined(_EMX)\n  return(Ch=='-' || Ch=='/');\n#else\n  return(Ch=='-');\n#endif\n}\n\n\n#ifndef SFX_MODULE\nuint CommandData::GetExclAttr(const wchar *Str)\n{\n  if (IsDigit(*Str))\n    return(wcstol(Str,NULL,0));\n\n  uint Attr=0;\n  while (*Str!=0)\n  {\n    switch(toupperw(*Str))\n    {\n#ifdef _UNIX\n      case 'D':\n        Attr|=S_IFDIR;\n        break;\n      case 'V':\n        Attr|=S_IFCHR;\n        break;\n#elif defined(_WIN_ALL) || defined(_EMX)\n      case 'R':\n        Attr|=0x1;\n        break;\n      case 'H':\n        Attr|=0x2;\n        break;\n      case 'S':\n        Attr|=0x4;\n        break;\n      case 'D':\n        Attr|=0x10;\n        break;\n      case 'A':\n        Attr|=0x20;\n        break;\n#endif\n    }\n    Str++;\n  }\n  return Attr;\n}\n#endif\n\n\n\n\n#ifndef SFX_MODULE\nbool CommandData::CheckWinSize()\n{\n  // Define 0x100000000 as macro to avoid troubles with older compilers.\n  const uint64 MaxDictSize=INT32TO64(1,0);\n  // Limit the dictionary size to 4 GB.\n  for (uint64 I=0x10000;I<=MaxDictSize;I*=2)\n    if (WinSize==I)\n      return true;\n  WinSize=0x400000;\n  return false;\n}\n#endif\n\n\n#ifndef SFX_MODULE\nvoid CommandData::ReportWrongSwitches(RARFORMAT Format)\n{\n  if (Format==RARFMT15)\n  {\n    if (HashType!=HASH_CRC32)\n      uiMsg(UIERROR_INCOMPATSWITCH,L\"-ht\",4);\n#ifdef _WIN_ALL\n    if (SaveSymLinks)\n      uiMsg(UIERROR_INCOMPATSWITCH,L\"-ol\",4);\n#endif\n    if (SaveHardLinks)\n      uiMsg(UIERROR_INCOMPATSWITCH,L\"-oh\",4);\n\n#ifdef _WIN_ALL\n    // Do not report a wrong dictionary size here, because we are not sure\n    // yet about archive format. We can switch to RAR5 mode later\n    // if we update RAR5 archive.\n\n\n#endif\n    if (QOpenMode!=QOPEN_AUTO)\n      uiMsg(UIERROR_INCOMPATSWITCH,L\"-qo\",4);\n  }\n  if (Format==RARFMT50)\n  {\n  }\n}\n#endif\n","static bool uiSoundEnabled;\n\nvoid uiInit(bool Sound)\n{\n  uiSoundEnabled = Sound;\n}\n\n\n// Additionally to handling user input, it analyzes and sets command options.\n// Returns only 'replace', 'skip' and 'cancel' codes.\nUIASKREP_RESULT uiAskReplaceEx(RAROptions *Cmd,wchar *Name,size_t MaxNameSize,int64 FileSize,RarTime *FileTime,uint Flags)\n{\n  if (Cmd->Overwrite==OVERWRITE_NONE)\n    return UIASKREP_R_SKIP;\n\n#if !defined(SFX_MODULE) && !defined(SILENT)\n  // Must be before Cmd->AllYes check or -y switch would override -or.\n  if (Cmd->Overwrite==OVERWRITE_AUTORENAME && GetAutoRenamedName(Name,MaxNameSize))\n    return UIASKREP_R_REPLACE;\n#endif\n\n  // This check must be after OVERWRITE_AUTORENAME processing or -y switch\n  // would override -or.\n  if (Cmd->AllYes || Cmd->Overwrite==OVERWRITE_ALL)\n  {\n    PrepareToDelete(Name);\n    return UIASKREP_R_REPLACE;\n  }\n\n  wchar NewName[NM];\n  wcsncpyz(NewName,Name,ASIZE(NewName));\n  UIASKREP_RESULT Choice=uiAskReplace(NewName,ASIZE(NewName),FileSize,FileTime,Flags);\n\n  if (Choice==UIASKREP_R_REPLACE || Choice==UIASKREP_R_REPLACEALL)\n    PrepareToDelete(Name);\n\n  if (Choice==UIASKREP_R_REPLACEALL)\n  {\n    Cmd->Overwrite=OVERWRITE_ALL;\n    return UIASKREP_R_REPLACE;\n  }\n  if (Choice==UIASKREP_R_SKIPALL)\n  {\n    Cmd->Overwrite=OVERWRITE_NONE;\n    return UIASKREP_R_SKIP;\n  }\n  if (Choice==UIASKREP_R_RENAME)\n  {\n    if (PointToName(NewName)==NewName)\n      SetName(Name,NewName,MaxNameSize);\n    else\n      wcsncpyz(Name,NewName,MaxNameSize);\n    if (FileExist(Name))\n      return uiAskReplaceEx(Cmd,Name,MaxNameSize,FileSize,FileTime,Flags);\n    return UIASKREP_R_REPLACE;\n  }\n#if !defined(SFX_MODULE) && !defined(SILENT)\n  if (Choice==UIASKREP_R_RENAMEAUTO && GetAutoRenamedName(Name,MaxNameSize))\n  {\n    Cmd->Overwrite=OVERWRITE_AUTORENAME;\n    return UIASKREP_R_REPLACE;\n  }\n#endif\n  return Choice;\n}\n","// Purely user interface function. Gets and returns user input.\nUIASKREP_RESULT uiAskReplace(wchar *Name,size_t MaxNameSize,int64 FileSize,RarTime *FileTime,uint Flags)\n{\n  return UIASKREP_R_REPLACE;\n}\n\n\n\n\nvoid uiStartArchiveExtract(bool Extract,const wchar *ArcName)\n{\n}\n\n\nbool uiStartFileExtract(const wchar *FileName,bool Extract,bool Test,bool Skip)\n{\n  return true;\n}\n\n\nvoid uiExtractProgress(int64 CurFileSize,int64 TotalFileSize,int64 CurSize,int64 TotalSize)\n{\n}\n\n\nvoid uiProcessProgress(const char *Command,int64 CurSize,int64 TotalSize)\n{\n}\n\n\nvoid uiMsgStore::Msg()\n{\n}\n\n\nbool uiGetPassword(UIPASSWORD_TYPE Type,const wchar *FileName,SecPassword *Password)\n{\n  return false;\n}\n\n\nvoid uiAlarm(UIALARM_TYPE Type)\n{\n}\n\n\nbool uiIsAborted()\n{\n  return false;\n}\n\n\nvoid uiGiveTick()\n{\n}\n\n\n#ifndef SFX_MODULE\nconst wchar *uiGetMonthName(int Month)\n{\n  return L\"\";\n}\n#endif\n","#include \"../unrar/rar.hpp\"\n#include \"../unrar/dll.hpp\"\n#include <emscripten.h>\n#include <emscripten/bind.h>\n#include <string>\n// #include <wstring>\n#include <vector>\n#include <locale.h>\n\nusing namespace std;\nusing namespace emscripten;\n\nchar callbackPassword[MAXPASSWORD] = \"\";\n\nint listCallback(UINT msg, LPARAM UserData, LPARAM P1, LPARAM P2)\n{\n  if (msg == UCM_NEEDPASSWORD)\n  {\n    strcpy((char *)P1, callbackPassword);\n  }\n  return 1;\n};\n\nstruct State\n{\n  unsigned int errCode;\n  string errType;\n};\n\nstruct ArcHeader\n{\n  State state;\n  wstring comment;\n  // unsigned int commentState;\n  unsigned int flags;\n};\n\nstruct ArcFileHeader\n{\n  State state;\n  wstring name;\n  unsigned int flags;\n  double packSize;\n  double unpSize;\n  unsigned int hostOS;\n  unsigned int crc;\n  unsigned int time;\n  unsigned int unpVer;\n  unsigned int method;\n  unsigned int fileAttr;\n};\n\nclass RarArchive\n{\npublic:\n  RarArchive() : hArcData(NULL)\n  {\n    setlocale(LC_ALL, \"C.UTF-8\");\n  }\n  ~RarArchive()\n  {\n    if (hArcData)\n    {\n      RARCloseArchive(hArcData);\n    }\n    hArcData = NULL;\n  }\n\n  ArcHeader open(const wstring &filepath, const wstring &password, bool forList)\n  {\n    char CmtBuf[16384];\n    struct RAROpenArchiveDataEx OpenArchiveData;\n    memset(&OpenArchiveData, 0, sizeof(OpenArchiveData));\n    OpenArchiveData.ArcNameW = (wchar_t *)filepath.c_str();\n    OpenArchiveData.CmtBuf = CmtBuf;\n    OpenArchiveData.CmtBufSize = sizeof(CmtBuf);\n    OpenArchiveData.OpenMode = forList ? RAR_OM_LIST : RAR_OM_EXTRACT;\n    OpenArchiveData.Callback = listCallback;\n    // OpenArchiveData.UserData = (LPARAM)password.c_str();\n    OpenArchiveData.UserData = NULL;\n    WideToUtf(password.c_str(), callbackPassword, MAXPASSWORD);\n\n    hArcData = RAROpenArchiveEx(&OpenArchiveData);\n\n    ArcHeader header;\n\n    header.state.errType = \"ERR_OPEN\";\n\n    if (OpenArchiveData.OpenResult != 0)\n    {\n      header.state.errCode = OpenArchiveData.OpenResult;\n      return header;\n    }\n\n    header.state.errCode = ERAR_SUCCESS;\n\n    header.flags = OpenArchiveData.Flags;\n    if (OpenArchiveData.CmtState == 1)\n    {\n      Array<wchar_t> WcmtBuf(OpenArchiveData.CmtSize);\n      CharToWide(CmtBuf, &WcmtBuf[0], WcmtBuf.Size() * sizeof(wchar_t));\n      header.comment = &WcmtBuf[0];\n    }\n    return header;\n  }\n\n  ArcFileHeader getFileHeader()\n  {\n    struct RARHeaderDataEx HeaderData;\n    memset(&HeaderData, 0, sizeof(HeaderData));\n    int RHCode = RARReadHeaderEx(hArcData, &HeaderData);\n\n    ArcFileHeader header;\n\n    header.state.errCode = RHCode;\n    header.state.errType = \"ERR_READ\";\n\n    if (RHCode == 0)\n    {\n      header.name = HeaderData.FileNameW;\n      header.flags = HeaderData.Flags;\n      header.packSize = (double)HeaderData.PackSize + (double)HeaderData.PackSizeHigh * 4294967296.0;\n      header.unpSize = (double)HeaderData.UnpSize + (double)HeaderData.UnpSizeHigh * 4294967296.0;\n      header.hostOS = HeaderData.HostOS;\n      header.crc = HeaderData.FileCRC;\n      header.time = HeaderData.FileTime;\n      header.unpVer = HeaderData.UnpVer;\n      header.method = HeaderData.Method;\n      header.fileAttr = HeaderData.FileAttr;\n    }\n    return header;\n  }\n\n  State readFile(bool skip)\n  {\n    State state;\n    state.errCode = RARProcessFile(hArcData, skip ? RAR_SKIP : RAR_EXTRACT, NULL, NULL);\n    state.errType = \"ERR_PROCESS\";\n    return state;\n  }\n\nprivate:\n  HANDLE hArcData;\n};\n\nEMSCRIPTEN_BINDINGS(stl_wrappers)\n{\n  class_<RarArchive>(\"RarArchive\")\n    .constructor< >()\n    .function(\"open\" , &RarArchive::open)\n    .function(\"getFileHeader\" , &RarArchive::getFileHeader)\n    .function(\"readFile\" , &RarArchive::readFile)\n    ;\n\n  value_object<State>(\"State\")\n      .field(\"errCode\", &State::errCode)\n      .field(\"errType\", &State::errType)\n      ;\n\n  value_object<ArcHeader>(\"ArcHeader\")\n      .field(\"state\", &ArcHeader::state)\n      .field(\"comment\", &ArcHeader::comment)\n      .field(\"flags\", &ArcHeader::flags);\n\n  value_object<ArcFileHeader>(\"ArcFileHeader\")\n      .field(\"state\", &ArcFileHeader::state)\n      .field(\"name\", &ArcFileHeader::name)\n      .field(\"flags\", &ArcFileHeader::flags)\n      .field(\"packSize\", &ArcFileHeader::packSize)\n      .field(\"unpSize\", &ArcFileHeader::unpSize)\n      .field(\"hostOS\", &ArcFileHeader::hostOS)\n      .field(\"crc\", &ArcFileHeader::crc)\n      .field(\"time\", &ArcFileHeader::time)\n      .field(\"unpVer\", &ArcFileHeader::unpVer)\n      .field(\"method\", &ArcFileHeader::method)\n      .field(\"fileAttr\", &ArcFileHeader::fileAttr);\n}\n","#pragma once\n\n#if __cplusplus < 201103L\n#error Including <emscripten/bind.h> requires building with -std=c++11 or newer!\n#else\n\n#include <stddef.h>\n#include <assert.h>\n#include <string>\n#include <functional>\n#include <vector>\n#include <map>\n#include <type_traits>\n#include <emscripten/val.h>\n#include <emscripten/wire.h>\n\nnamespace emscripten {\n    enum class sharing_policy {\n        NONE = 0,\n        INTRUSIVE = 1,\n        BY_EMVAL = 2,\n    };\n\n    namespace internal {\n        typedef long GenericEnumValue;\n\n        typedef void* GenericFunction;\n        typedef void (*VoidFunctionPtr)(void);\n\n        // Implemented in JavaScript.  Don't call these directly.\n        extern \"C\" {\n            void _embind_fatal_error(\n                const char* name,\n                const char* payload) __attribute__((noreturn));\n\n            void _embind_register_void(\n                TYPEID voidType,\n                const char* name);\n\n            void _embind_register_bool(\n                TYPEID boolType,\n                const char* name,\n                size_t size,\n                bool trueValue,\n                bool falseValue);\n\n            void _embind_register_integer(\n                TYPEID integerType,\n                const char* name,\n                size_t size,\n                long minRange,\n                unsigned long maxRange);\n\n            void _embind_register_float(\n                TYPEID floatType,\n                const char* name,\n                size_t size);\n            \n            void _embind_register_std_string(\n                TYPEID stringType,\n                const char* name);\n\n            void _embind_register_std_wstring(\n                TYPEID stringType,\n                size_t charSize,\n                const char* name);\n\n            void _embind_register_emval(\n                TYPEID emvalType,\n                const char* name);\n\n            void _embind_register_memory_view(\n                TYPEID memoryViewType,\n                unsigned typedArrayIndex,\n                const char* name);\n\n            void _embind_register_function(\n                const char* name,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* signature,\n                GenericFunction invoker,\n                GenericFunction function);\n\n            void _embind_register_value_array(\n                TYPEID tupleType,\n                const char* name,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* destructorSignature,\n                GenericFunction destructor);\n            \n            void _embind_register_value_array_element(\n                TYPEID tupleType,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_finalize_value_array(TYPEID tupleType);\n\n            void _embind_register_value_object(\n                TYPEID structType,\n                const char* fieldName,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* destructorSignature,\n                GenericFunction destructor);\n            \n            void _embind_register_value_object_field(\n                TYPEID structType,\n                const char* fieldName,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_finalize_value_object(TYPEID structType);\n\n            void _embind_register_class(\n                TYPEID classType,\n                TYPEID pointerType,\n                TYPEID constPointerType,\n                TYPEID baseClassType,\n                const char* getActualTypeSignature,\n                GenericFunction getActualType,\n                const char* upcastSignature,\n                GenericFunction upcast,\n                const char* downcastSignature,\n                GenericFunction downcast,\n                const char* className,\n                const char* destructorSignature,\n                GenericFunction destructor);\n\n            void _embind_register_class_constructor(\n                TYPEID classType,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                GenericFunction constructor);\n\n            void _embind_register_class_function(\n                TYPEID classType,\n                const char* methodName,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                void* context,\n                unsigned isPureVirtual);\n\n            void _embind_register_class_property(\n                TYPEID classType,\n                const char* fieldName,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_register_class_class_function(\n                TYPEID classType,\n                const char* methodName,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                GenericFunction method);\n\n            void _embind_register_class_class_property(\n                TYPEID classType,\n                const char* fieldName,\n                TYPEID fieldType,\n                const void* fieldContext,\n                const char* getterSignature,\n                GenericFunction getter,\n                const char* setterSignature,\n                GenericFunction setter);\n\n            EM_VAL _embind_create_inheriting_constructor(\n                const char* constructorName,\n                TYPEID wrapperType,\n                EM_VAL properties);\n\n            void _embind_register_enum(\n                TYPEID enumType,\n                const char* name,\n                size_t size,\n                bool isSigned);\n\n            void _embind_register_smart_ptr(\n                TYPEID pointerType,\n                TYPEID pointeeType,\n                const char* pointerName,\n                sharing_policy sharingPolicy,\n                const char* getPointeeSignature,\n                GenericFunction getPointee,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* shareSignature,\n                GenericFunction share,\n                const char* destructorSignature,\n                GenericFunction destructor);\n\n            void _embind_register_enum_value(\n                TYPEID enumType,\n                const char* valueName,\n                GenericEnumValue value);\n\n            void _embind_register_constant(\n                const char* name,\n                TYPEID constantType,\n                uintptr_t value);\n        }\n    }\n}\n\nnamespace emscripten {\n    ////////////////////////////////////////////////////////////////////////////////\n    // POLICIES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<int Index>\n    struct arg {\n        static constexpr int index = Index + 1;\n    };\n\n    struct ret_val {\n        static constexpr int index = 0;\n    };\n\n    /*\n    template<typename Slot>\n    struct allow_raw_pointer {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef typename std::conditional<\n                Index == Slot::index,\n                internal::AllowedRawPointer<typename std::remove_pointer<InputType>::type>,\n                InputType\n            >::type type;\n        };\n    };\n    */\n\n    // whitelist all raw pointers\n    struct allow_raw_pointers {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef typename std::conditional<\n                std::is_pointer<InputType>::value,\n                internal::AllowedRawPointer<typename std::remove_pointer<InputType>::type>,\n                InputType\n            >::type type;\n        };\n    };\n\n    // this is temporary until arg policies are reworked\n    template<typename Slot>\n    struct allow_raw_pointer : public allow_raw_pointers {\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // select_overload and select_const\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename Signature>\n    Signature* select_overload(Signature* fn) {\n        return fn;\n    }\n\n    template<typename Signature, typename ClassType>\n    auto select_overload(Signature (ClassType::*fn)) -> decltype(fn) {\n        return fn;\n    }\n\n    template<typename ClassType, typename ReturnType, typename... Args>\n    auto select_const(ReturnType (ClassType::*method)(Args...) const) -> decltype(method) {\n        return method;\n    }\n\n    namespace internal {        \n        // this should be in <type_traits>, but alas, it's not\n        template<typename T> struct remove_class;\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...)> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) const> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) volatile> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) const volatile> { using type = R(A...); };\n\n        template<typename LambdaType>\n        using LambdaSignature = typename remove_class<\n            decltype(&LambdaType::operator())\n        >::type;\n    }\n\n    // requires captureless lambda because implicitly coerces to function pointer\n    template<typename LambdaType>\n    internal::LambdaSignature<LambdaType>* optional_override(const LambdaType& fp) {\n        return fp;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Invoker\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename ReturnType, typename... Args>\n        struct Invoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                ReturnType (*fn)(Args...),\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    fn(\n                        internal::BindingType<Args>::fromWireType(args)...\n                    )\n                );\n            }\n        };\n\n        template<typename... Args>\n        struct Invoker<void, Args...> {\n            static void invoke(\n                void (*fn)(Args...),\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return fn(\n                    internal::BindingType<Args>::fromWireType(args)...\n                );\n            }\n        };\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // SignatureCode, SignatureString\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename T>\n        struct SignatureCode {};\n\n        template<>\n        struct SignatureCode<int> {\n            static constexpr char get() {\n                return 'i';\n            }\n        };\n\n        template<>\n        struct SignatureCode<void> {\n            static constexpr char get() {\n                return 'v';\n            }\n        };\n\n        template<>\n        struct SignatureCode<float> {\n            static constexpr char get() {\n                return 'f';\n            }\n        };\n\n        template<>\n        struct SignatureCode<double> {\n            static constexpr char get() {\n                return 'd';\n            }\n        };\n\n        template<typename... Args>\n        const char* getGenericSignature() {\n            static constexpr char signature[] = { SignatureCode<Args>::get()..., 0 };\n            return signature;\n        }\n\n        template<typename T> struct SignatureTranslator { using type = int; };\n        template<> struct SignatureTranslator<void> { using type = void; };\n        template<> struct SignatureTranslator<float> { using type = float; };\n        template<> struct SignatureTranslator<double> { using type = double; };\n\n        template<typename... Args>\n        EMSCRIPTEN_ALWAYS_INLINE const char* getSpecificSignature() {\n            return getGenericSignature<typename SignatureTranslator<Args>::type...>();\n        }\n\n        template<typename Return, typename... Args>\n        EMSCRIPTEN_ALWAYS_INLINE const char* getSignature(Return (*)(Args...)) {\n            return getSpecificSignature<Return, Args...>();\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // FUNCTIONS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    extern \"C\" {\n        void* __getDynamicPointerType(void* p);\n    }\n\n    template<typename ReturnType, typename... Args, typename... Policies>\n    void function(const char* name, ReturnType (*fn)(Args...), Policies...) {\n        using namespace internal;\n        typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, Args...> args;\n        auto invoker = &Invoker<ReturnType, Args...>::invoke;\n        _embind_register_function(\n            name,\n            args.getCount(),\n            args.getTypes(),\n            getSignature(invoker),\n            reinterpret_cast<GenericFunction>(invoker),\n            reinterpret_cast<GenericFunction>(fn));\n    }\n\n    namespace internal {\n        template<typename ClassType, typename... Args>\n        ClassType* operator_new(Args&&... args) {\n            return new ClassType(std::forward<Args>(args)...);\n        }\n\n        template<typename WrapperType, typename ClassType, typename... Args>\n        WrapperType wrapped_new(Args&&... args) {\n            return WrapperType(new ClassType(std::forward<Args>(args)...));\n        }\n\n        template<typename ClassType, typename... Args>\n        ClassType* raw_constructor(\n            typename internal::BindingType<Args>::WireType... args\n        ) {\n            return new ClassType(\n                internal::BindingType<Args>::fromWireType(args)...\n            );\n        }\n\n        template<typename ClassType>\n        void raw_destructor(ClassType* ptr) {\n            delete ptr;\n        }\n\n        template<typename FunctionPointerType, typename ReturnType, typename ThisType, typename... Args>\n        struct FunctionInvoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                FunctionPointerType* function,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    (*function)(\n                        internal::BindingType<ThisType>::fromWireType(wireThis),\n                        internal::BindingType<Args>::fromWireType(args)...)\n                );\n            }\n        };\n\n        template<typename FunctionPointerType, typename ThisType, typename... Args>\n        struct FunctionInvoker<FunctionPointerType, void, ThisType, Args...> {\n            static void invoke(\n                FunctionPointerType* function,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                (*function)(\n                    internal::BindingType<ThisType>::fromWireType(wireThis),\n                    internal::BindingType<Args>::fromWireType(args)...);\n            }\n        };\n\n        template<typename MemberPointer,\n                 typename ReturnType,\n                 typename ThisType,\n                 typename... Args>\n        struct MethodInvoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                const MemberPointer& method,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    (internal::BindingType<ThisType>::fromWireType(wireThis)->*method)(\n                        internal::BindingType<Args>::fromWireType(args)...\n                    )\n                );\n            }\n        };\n\n        template<typename MemberPointer,\n                 typename ThisType,\n                 typename... Args>\n        struct MethodInvoker<MemberPointer, void, ThisType, Args...> {\n            static void invoke(\n                const MemberPointer& method,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return (internal::BindingType<ThisType>::fromWireType(wireThis)->*method)(\n                    internal::BindingType<Args>::fromWireType(args)...\n                );\n            }\n        };\n\n        template<typename InstanceType, typename MemberType>\n        struct MemberAccess {\n            typedef MemberType InstanceType::*MemberPointer;\n            typedef internal::BindingType<MemberType> MemberBinding;\n            typedef typename MemberBinding::WireType WireType;\n            \n            template<typename ClassType>\n            static WireType getWire(\n                const MemberPointer& field,\n                const ClassType& ptr\n            ) {\n                return MemberBinding::toWireType(ptr.*field);\n            }\n            \n            template<typename ClassType>\n            static void setWire(\n                const MemberPointer& field,\n                ClassType& ptr,\n                WireType value\n            ) {\n                ptr.*field = MemberBinding::fromWireType(value);\n            }\n        };\n\n        template<typename FieldType>\n        struct GlobalAccess {\n            typedef internal::BindingType<FieldType> MemberBinding;\n            typedef typename MemberBinding::WireType WireType;\n\n            static WireType get(FieldType* context) {\n                return MemberBinding::toWireType(*context);\n            }\n\n            static void set(FieldType* context, WireType value) {\n                *context = MemberBinding::fromWireType(value);\n            }\n        };\n\n        // TODO: This could do a reinterpret-cast if sizeof(T) === sizeof(void*)\n        template<typename T>\n        inline T* getContext(const T& t) {\n            // not a leak because this is called once per binding\n            return new T(t);\n        }\n\n        template<typename T>\n        struct GetterPolicy;\n\n        template<typename GetterReturnType, typename GetterThisType>\n        struct GetterPolicy<GetterReturnType (GetterThisType::*)() const> {\n            typedef GetterReturnType ReturnType;\n            typedef GetterReturnType (GetterThisType::*Context)() const;\n\n            typedef internal::BindingType<ReturnType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static WireType get(const Context& context, const ClassType& ptr) {\n                return Binding::toWireType((ptr.*context)());\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename GetterReturnType, typename GetterThisType>\n        struct GetterPolicy<GetterReturnType (*)(const GetterThisType&)> {\n            typedef GetterReturnType ReturnType;\n            typedef GetterReturnType (*Context)(const GetterThisType&);\n\n            typedef internal::BindingType<ReturnType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static WireType get(const Context& context, const ClassType& ptr) {\n                return Binding::toWireType(context(ptr));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename T>\n        struct SetterPolicy;\n\n        template<typename SetterThisType, typename SetterArgumentType>\n        struct SetterPolicy<void (SetterThisType::*)(SetterArgumentType)> {\n            typedef SetterArgumentType ArgumentType;\n            typedef void (SetterThisType::*Context)(SetterArgumentType);\n\n            typedef internal::BindingType<SetterArgumentType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static void set(const Context& context, ClassType& ptr, WireType wt) {\n                (ptr.*context)(Binding::fromWireType(wt));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename SetterThisType, typename SetterArgumentType>\n        struct SetterPolicy<void (*)(SetterThisType&, SetterArgumentType)> {\n            typedef SetterArgumentType ArgumentType;\n            typedef void (*Context)(SetterThisType&, SetterArgumentType);\n\n            typedef internal::BindingType<SetterArgumentType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static void set(const Context& context, ClassType& ptr, WireType wt) {\n                context(ptr, Binding::fromWireType(wt));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        class noncopyable {\n        protected:\n            noncopyable() {}\n            ~noncopyable() {}\n        private:\n            noncopyable(const noncopyable&) = delete;\n            const noncopyable& operator=(const noncopyable&) = delete;\n        };\n\n        template<typename ClassType, typename ElementType>\n        typename BindingType<ElementType>::WireType get_by_index(int index, ClassType& ptr) {\n            return BindingType<ElementType>::toWireType(ptr[index]);\n        }\n\n        template<typename ClassType, typename ElementType>\n        void set_by_index(int index, ClassType& ptr, typename BindingType<ElementType>::WireType wt) {\n            ptr[index] = BindingType<ElementType>::fromWireType(wt);\n        }\n    }\n\n    template<int Index>\n    struct index {\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VALUE TUPLES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename ClassType>\n    class value_array : public internal::noncopyable {\n    public:\n        typedef ClassType class_type;\n\n        value_array(const char* name) {\n            using namespace internal;\n\n            auto constructor = &raw_constructor<ClassType>;\n            auto destructor = &raw_destructor<ClassType>;\n            _embind_register_value_array(\n                TypeID<ClassType>::get(),\n                name,\n                getSignature(constructor),\n                reinterpret_cast<GenericFunction>(constructor),\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n        }\n\n        ~value_array() {\n            using namespace internal;\n            _embind_finalize_value_array(TypeID<ClassType>::get());\n        }\n\n        template<typename InstanceType, typename ElementType>\n        value_array& element(ElementType InstanceType::*field) {\n            using namespace internal;\n\n            auto getter = &MemberAccess<InstanceType, ElementType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, ElementType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        value_array& element(Getter getter, Setter setter) {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto g = &GP::template get<ClassType>;\n            auto s = &SP::template set<ClassType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(g),\n                reinterpret_cast<GenericFunction>(g),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(s),\n                reinterpret_cast<GenericFunction>(s),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<int Index>\n        value_array& element(index<Index>) {\n            using namespace internal;\n            ClassType* null = 0;\n            typedef typename std::remove_reference<decltype((*null)[Index])>::type ElementType;\n            auto getter = &internal::get_by_index<ClassType, ElementType>;\n            auto setter = &internal::set_by_index<ClassType, ElementType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                reinterpret_cast<void*>(Index),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                reinterpret_cast<void*>(Index));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VALUE STRUCTS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename ClassType>\n    class value_object : public internal::noncopyable {\n    public:\n        typedef ClassType class_type;\n\n        value_object(const char* name) {\n            using namespace internal;\n\n            auto ctor = &raw_constructor<ClassType>;\n            auto dtor = &raw_destructor<ClassType>;\n\n            _embind_register_value_object(\n                TypeID<ClassType>::get(),\n                name,\n                getSignature(ctor),\n                reinterpret_cast<GenericFunction>(ctor),\n                getSignature(dtor),\n                reinterpret_cast<GenericFunction>(dtor));\n        }\n\n        ~value_object() {\n            using namespace internal;\n            _embind_finalize_value_object(internal::TypeID<ClassType>::get());\n        }\n\n        template<typename InstanceType, typename FieldType>\n        value_object& field(const char* fieldName, FieldType InstanceType::*field) {\n            using namespace internal;\n\n            auto getter = &MemberAccess<InstanceType, FieldType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, FieldType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename InstanceType, typename ElementType, int N>\n        value_object& field(const char* fieldName, ElementType (InstanceType::*field)[N]) {\n            using namespace internal;\n\n            typedef std::array<ElementType, N> FieldType;\n            static_assert(sizeof(FieldType) == sizeof(ElementType[N]));\n\n            auto getter = &MemberAccess<InstanceType, FieldType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, FieldType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        value_object& field(\n            const char* fieldName,\n            Getter getter,\n            Setter setter\n        ) {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto g = &GP::template get<ClassType>;\n            auto s = &SP::template set<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(g),\n                reinterpret_cast<GenericFunction>(g),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(s),\n                reinterpret_cast<GenericFunction>(s),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<int Index>\n        value_object& field(const char* fieldName, index<Index>) {\n            using namespace internal;\n            ClassType* null = 0;\n            typedef typename std::remove_reference<decltype((*null)[Index])>::type ElementType;\n\n            auto getter = &internal::get_by_index<ClassType, ElementType>;\n            auto setter = &internal::set_by_index<ClassType, ElementType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                reinterpret_cast<void*>(Index),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                reinterpret_cast<void*>(Index));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // SMART POINTERS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename PointerType>\n    struct default_smart_ptr_trait {\n        static sharing_policy get_sharing_policy() {\n            return sharing_policy::NONE;\n        }\n\n        static void* share(void* v) {\n            return 0; // no sharing\n        }\n\n        static PointerType* construct_null() {\n            return new PointerType;\n        }\n    };\n\n    // specialize if you have a different pointer type\n    template<typename PointerType>\n    struct smart_ptr_trait : public default_smart_ptr_trait<PointerType> {\n        typedef typename PointerType::element_type element_type;\n\n        static element_type* get(const PointerType& ptr) {\n            return ptr.get();\n        }\n    };\n\n    template<typename PointeeType>\n    struct smart_ptr_trait<std::shared_ptr<PointeeType>> {\n        typedef std::shared_ptr<PointeeType> PointerType;\n        typedef typename PointerType::element_type element_type;\n\n        static element_type* get(const PointerType& ptr) {\n            return ptr.get();\n        }\n\n        static sharing_policy get_sharing_policy() {\n            return sharing_policy::BY_EMVAL;\n        }\n\n        static std::shared_ptr<PointeeType>* share(PointeeType* p, internal::EM_VAL v) {\n            return new std::shared_ptr<PointeeType>(\n                p,\n                val_deleter(val::take_ownership(v)));\n        }\n\n        static PointerType* construct_null() {\n            return new PointerType;\n        }\n\n    private:\n        class val_deleter {\n        public:\n            val_deleter() = delete;\n            explicit val_deleter(val v)\n                : v(v)\n            {}\n            void operator()(void const*) {\n                v();\n                // eventually we'll need to support emptied out val\n                v = val::undefined();\n            }\n        private:\n            val v;\n        };\n    };\n\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // CLASSES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        class WrapperBase {\n        public:\n            void setNotifyJSOnDestruction(bool notify) {\n                notifyJSOnDestruction = notify;\n            }\n\n        protected:\n            bool notifyJSOnDestruction = false;\n        };\n    }\n\n    // abstract classes\n    template<typename T>\n    class wrapper : public T, public internal::WrapperBase {\n    public:\n        typedef T class_type;\n\n        template<typename... Args>\n        explicit wrapper(val&& wrapped, Args&&... args)\n            : T(std::forward<Args>(args)...)\n            , wrapped(std::forward<val>(wrapped))\n        {}\n\n        ~wrapper() {\n            if (notifyJSOnDestruction) {\n                call<void>(\"__destruct\");\n            }\n        }\n\n        template<typename ReturnType, typename... Args>\n        ReturnType call(const char* name, Args&&... args) const {\n            return wrapped.call<ReturnType>(name, std::forward<Args>(args)...);\n        }\n\n    private:\n        val wrapped;\n    };\n\n#define EMSCRIPTEN_WRAPPER(T)                                           \\\n    template<typename... Args>                                          \\\n    T(::emscripten::val&& v, Args&&... args)                            \\\n        : wrapper(std::forward<::emscripten::val>(v), std::forward<Args>(args)...) \\\n    {}\n\n    namespace internal {\n        struct NoBaseClass {\n            template<typename ClassType>\n            static void verify() {\n            }\n\n            static TYPEID get() {\n                return nullptr;\n            }\n\n            template<typename ClassType>\n            static VoidFunctionPtr getUpcaster() {\n                return nullptr;\n            }\n\n            template<typename ClassType>\n            static VoidFunctionPtr getDowncaster() {\n                return nullptr;\n            }\n        };\n\n        // NOTE: this returns the class type, not the pointer type\n        template<typename T>\n        inline TYPEID getActualType(T* ptr) {\n            return getLightTypeID(*ptr);\n        };\n    }\n\n    template<typename BaseClass>\n    struct base {\n        typedef BaseClass class_type;\n\n        template<typename ClassType>\n        static void verify() {\n            static_assert(!std::is_same<ClassType, BaseClass>::value, \"Base must not have same type as class\");\n            static_assert(std::is_base_of<BaseClass, ClassType>::value, \"Derived class must derive from base\");\n        }\n\n        static internal::TYPEID get() {\n            return internal::TypeID<BaseClass>::get();\n        }\n        \n        template<typename ClassType>\n        using Upcaster = BaseClass* (*)(ClassType*);\n\n        template<typename ClassType>\n        using Downcaster = ClassType* (*)(BaseClass*);\n        \n        template<typename ClassType>\n        static Upcaster<ClassType> getUpcaster() {\n            return &convertPointer<ClassType, BaseClass>;\n        }\n        \n        template<typename ClassType>\n        static Downcaster<ClassType> getDowncaster() {\n            return &convertPointer<BaseClass, ClassType>;\n        }\n\n        template<typename From, typename To>\n        static To* convertPointer(From* ptr) {\n            return static_cast<To*>(ptr);\n        }\n    };\n\n    namespace internal {\n        template<typename WrapperType>\n        val wrapped_extend(const std::string& name, const val& properties) {\n            return val::take_ownership(_embind_create_inheriting_constructor(\n                name.c_str(),\n                TypeID<WrapperType>::get(),\n                properties.__get_handle()));\n        }\n    };\n\n    struct pure_virtual {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef InputType type;\n        };\n    };\n\n    namespace internal {\n        template<typename... Policies>\n        struct isPureVirtual;\n\n        template<typename... Rest>\n        struct isPureVirtual<pure_virtual, Rest...> {\n            static constexpr bool value = true;\n        };\n\n        template<typename T, typename... Rest>\n        struct isPureVirtual<T, Rest...> {\n            static constexpr bool value = isPureVirtual<Rest...>::value;\n        };\n\n        template<>\n        struct isPureVirtual<> {\n            static constexpr bool value = false;\n        };\n    }\n\n    template<typename... ConstructorArgs>\n    struct constructor {\n    };\n\n    template<typename ClassType, typename BaseSpecifier = internal::NoBaseClass>\n    class class_ {\n    public:\n        typedef ClassType class_type;\n        typedef BaseSpecifier base_specifier;\n\n        class_() = delete;\n\n        EMSCRIPTEN_ALWAYS_INLINE explicit class_(const char* name) {\n            using namespace internal;\n\n            BaseSpecifier::template verify<ClassType>();\n\n            auto _getActualType = &getActualType<ClassType>;\n            auto upcast   = BaseSpecifier::template getUpcaster<ClassType>();\n            auto downcast = BaseSpecifier::template getDowncaster<ClassType>();\n            auto destructor = &raw_destructor<ClassType>;\n\n            _embind_register_class(\n                TypeID<ClassType>::get(),\n                TypeID<AllowedRawPointer<ClassType>>::get(),\n                TypeID<AllowedRawPointer<const ClassType>>::get(),\n                BaseSpecifier::get(),\n                getSignature(_getActualType),\n                reinterpret_cast<GenericFunction>(_getActualType),\n                getSignature(upcast),\n                reinterpret_cast<GenericFunction>(upcast),\n                getSignature(downcast),\n                reinterpret_cast<GenericFunction>(downcast),\n                name,\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n        }\n\n        template<typename PointerType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& smart_ptr(const char* name) const {\n            using namespace internal;\n\n            typedef smart_ptr_trait<PointerType> PointerTrait;\n            typedef typename PointerTrait::element_type PointeeType;\n            \n            static_assert(std::is_same<ClassType, typename std::remove_cv<PointeeType>::type>::value, \"smart pointer must point to this class\");\n\n            auto get = &PointerTrait::get;\n            auto construct_null = &PointerTrait::construct_null;\n            auto share = &PointerTrait::share;\n            auto destructor = &raw_destructor<PointerType>;\n\n            _embind_register_smart_ptr(\n                TypeID<PointerType>::get(),\n                TypeID<PointeeType>::get(),\n                name,\n                PointerTrait::get_sharing_policy(),\n                getSignature(get),\n                reinterpret_cast<GenericFunction>(get),\n                getSignature(construct_null),\n                reinterpret_cast<GenericFunction>(construct_null),\n                getSignature(share),\n                reinterpret_cast<GenericFunction>(share),\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n            return *this;\n        };\n\n        template<typename... ConstructorArgs, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& constructor(Policies... policies) const {\n            return constructor(\n                &internal::operator_new<ClassType, ConstructorArgs...>,\n                policies...);\n        }\n\n        template<typename... Args, typename ReturnType, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& constructor(ReturnType (*factory)(Args...), Policies...) const {\n            using namespace internal;\n\n            // TODO: allows all raw pointers... policies need a rethink\n            typename WithPolicies<allow_raw_pointers, Policies...>::template ArgTypeList<ReturnType, Args...> args;\n            auto invoke = &Invoker<ReturnType, Args...>::invoke;\n            _embind_register_class_constructor(\n                TypeID<ClassType>::get(),\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(factory));\n            return *this;\n        }\n\n        template<typename SmartPtr, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& smart_ptr_constructor(const char* smartPtrName, SmartPtr (*factory)(Args...), Policies...) const {\n            using namespace internal;\n\n            smart_ptr<SmartPtr>(smartPtrName);\n\n            typename WithPolicies<Policies...>::template ArgTypeList<SmartPtr, Args...> args;\n            auto invoke = &Invoker<SmartPtr, Args...>::invoke;\n            _embind_register_class_constructor(\n                TypeID<ClassType>::get(),\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(factory));\n            return *this;\n        }\n\n        template<typename WrapperType, typename... ConstructorArgs>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& allow_subclass(\n            const char* wrapperClassName,\n            ::emscripten::constructor<ConstructorArgs...> = ::emscripten::constructor<>()\n        ) const {\n            using namespace internal;\n\n            auto cls = class_<WrapperType, base<ClassType>>(wrapperClassName)\n                .function(\"notifyOnDestruction\", select_overload<void(WrapperType&)>([](WrapperType& wrapper) {\n                    wrapper.setNotifyJSOnDestruction(true);\n                }))\n                ;\n\n            return\n                class_function(\n                    \"implement\",\n                    &wrapped_new<WrapperType*, WrapperType, val, ConstructorArgs...>,\n                    allow_raw_pointer<ret_val>())\n                .class_function(\n                    \"extend\",\n                    &wrapped_extend<WrapperType>)\n                ;\n        }\n\n        template<typename WrapperType, typename PointerType, typename... ConstructorArgs>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& allow_subclass(\n            const char* wrapperClassName,\n            const char* pointerName,\n            ::emscripten::constructor<ConstructorArgs...> = ::emscripten::constructor<>()\n        ) const {\n            using namespace internal;\n\n            auto cls = class_<WrapperType, base<ClassType>>(wrapperClassName)\n                .function(\"notifyOnDestruction\", select_overload<void(WrapperType&)>([](WrapperType& wrapper) {\n                    wrapper.setNotifyJSOnDestruction(true);\n                }))\n                .template smart_ptr<PointerType>(pointerName)\n                ;\n\n            return\n                class_function(\n                    \"implement\",\n                    &wrapped_new<PointerType, WrapperType, val, ConstructorArgs...>,\n                    allow_raw_pointer<ret_val>())\n                .class_function(\n                    \"extend\",\n                    &wrapped_extend<WrapperType>)\n                ;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (ClassType::*memberFunction)(Args...), Policies...) const {\n            using namespace internal;\n\n            auto invoker = &MethodInvoker<decltype(memberFunction), ReturnType, ClassType*, Args...>::invoke;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, AllowedRawPointer<ClassType>, Args...> args;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoker),\n                reinterpret_cast<GenericFunction>(invoker),\n                getContext(memberFunction),\n                isPureVirtual<Policies...>::value);\n            return *this;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (ClassType::*memberFunction)(Args...) const, Policies...) const {\n            using namespace internal;\n\n            auto invoker = &MethodInvoker<decltype(memberFunction), ReturnType, const ClassType*, Args...>::invoke;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, AllowedRawPointer<const ClassType>, Args...> args;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoker),\n                reinterpret_cast<GenericFunction>(invoker),\n                getContext(memberFunction),\n                isPureVirtual<Policies...>::value);\n            return *this;\n        }\n\n        template<typename ReturnType, typename ThisType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (*function)(ThisType, Args...), Policies...) const {\n            using namespace internal;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, ThisType, Args...> args;\n            auto invoke = &FunctionInvoker<decltype(function), ReturnType, ThisType, Args...>::invoke;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                getContext(function),\n                false);\n            return *this;\n        }\n\n        template<typename FieldType, typename = typename std::enable_if<!std::is_function<FieldType>::value>::type>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, const FieldType ClassType::*field) const {\n            using namespace internal;\n            \n            auto getter = &MemberAccess<ClassType, FieldType>::template getWire<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                0,\n                0,\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename FieldType, typename = typename std::enable_if<!std::is_function<FieldType>::value>::type>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, FieldType ClassType::*field) const {\n            using namespace internal;\n\n            auto getter = &MemberAccess<ClassType, FieldType>::template getWire<ClassType>;\n            auto setter = &MemberAccess<ClassType, FieldType>::template setWire<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, Getter getter) const {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            auto gter = &GP::template get<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(gter),\n                reinterpret_cast<GenericFunction>(gter),\n                GP::getContext(getter),\n                0,\n                0,\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, Getter getter, Setter setter) const {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto gter = &GP::template get<ClassType>;\n            auto ster = &SP::template set<ClassType>;\n\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(gter),\n                reinterpret_cast<GenericFunction>(gter),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(ster),\n                reinterpret_cast<GenericFunction>(ster),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_function(const char* methodName, ReturnType (*classMethod)(Args...), Policies...) const {\n            using namespace internal;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, Args...> args;\n            auto invoke = &internal::Invoker<ReturnType, Args...>::invoke;\n            _embind_register_class_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(classMethod));\n            return *this;\n        }\n\n        template<typename FieldType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_property(const char* name, const FieldType* field) const {\n            using namespace internal;\n\n            auto getter = &GlobalAccess<FieldType>::get;\n            _embind_register_class_class_property(\n                TypeID<ClassType>::get(),\n                name,\n                TypeID<FieldType>::get(),\n                field,\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename FieldType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_property(const char* name, FieldType* field) const {\n            using namespace internal;\n\n            auto getter = &GlobalAccess<FieldType>::get;\n            auto setter = &GlobalAccess<FieldType>::set;\n            _embind_register_class_class_property(\n                TypeID<ClassType>::get(),\n                name,\n                TypeID<FieldType>::get(),\n                field,\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VECTORS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename VectorType>\n        struct VectorAccess {\n            static val get(\n                const VectorType& v,\n                typename VectorType::size_type index\n            ) {\n                if (index < v.size()) {\n                    return val(v[index]);\n                } else {\n                    return val::undefined();\n                }\n            }\n\n            static bool set(\n                VectorType& v,\n                typename VectorType::size_type index,\n                const typename VectorType::value_type& value\n            ) {\n                v[index] = value;\n                return true;\n            }\n        };\n    }\n\n    template<typename T>\n    class_<std::vector<T>> register_vector(const char* name) {\n        typedef std::vector<T> VecType;\n\n        void (VecType::*push_back)(const T&) = &VecType::push_back;\n        void (VecType::*resize)(const size_t, const T&) = &VecType::resize;\n        return class_<std::vector<T>>(name)\n            .template constructor<>()\n            .function(\"push_back\", push_back)\n            .function(\"resize\", resize)\n            .function(\"size\", &VecType::size)\n            .function(\"get\", &internal::VectorAccess<VecType>::get)\n            .function(\"set\", &internal::VectorAccess<VecType>::set)\n            ;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // MAPS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename MapType>\n        struct MapAccess {\n            static val get(\n                const MapType& m,\n                const typename MapType::key_type& k\n            ) {\n                auto i = m.find(k);\n                if (i == m.end()) {\n                    return val::undefined();\n                } else {\n                    return val(i->second);\n                }\n            }\n\n            static void set(\n                MapType& m,\n                const typename MapType::key_type& k,\n                const typename MapType::mapped_type& v\n            ) {\n                m[k] = v;\n            }\n        };\n    }\n\n    template<typename K, typename V>\n    class_<std::map<K, V>> register_map(const char* name) {\n        typedef std::map<K,V> MapType;\n\n        return class_<MapType>(name)\n            .template constructor<>()\n            .function(\"size\", &MapType::size)\n            .function(\"get\", internal::MapAccess<MapType>::get)\n            .function(\"set\", internal::MapAccess<MapType>::set)\n            ;\n    }\n\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // ENUMS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename EnumType>\n    class enum_ {\n    public:\n        typedef EnumType enum_type;\n\n        enum_(const char* name) {\n            using namespace internal;\n            _embind_register_enum(\n                internal::TypeID<EnumType>::get(),\n                name,\n                sizeof(EnumType),\n                std::is_signed<typename std::underlying_type<EnumType>::type>::value);\n        }\n\n        enum_& value(const char* name, EnumType value) {\n            using namespace internal;\n            // TODO: there's still an issue here.\n            // if EnumType is an unsigned long, then JS may receive it as a signed long\n            static_assert(sizeof(value) <= sizeof(internal::GenericEnumValue), \"enum type must fit in a GenericEnumValue\");\n\n            _embind_register_enum_value(\n                internal::TypeID<EnumType>::get(),\n                name,\n                static_cast<internal::GenericEnumValue>(value));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // CONSTANTS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename T>\n        uintptr_t asGenericValue(T t) {\n            return static_cast<uintptr_t>(t);\n        }\n\n        template<typename T>\n        uintptr_t asGenericValue(T* p) {\n            return reinterpret_cast<uintptr_t>(p);\n        }\n    }\n\n    template<typename ConstantType>\n    void constant(const char* name, const ConstantType& v) {\n        using namespace internal;\n        typedef BindingType<const ConstantType&> BT;\n        _embind_register_constant(\n            name,\n            TypeID<const ConstantType&>::get(),\n            asGenericValue(BT::toWireType(v)));\n    }\n}\n\n#define EMSCRIPTEN_BINDINGS(name)                                       \\\n    static struct EmscriptenBindingInitializer_##name {                 \\\n        EmscriptenBindingInitializer_##name();                          \\\n    } EmscriptenBindingInitializer_##name##_instance;                   \\\n    EmscriptenBindingInitializer_##name::EmscriptenBindingInitializer_##name()\n\n#endif // ~C++11 version check\n","#pragma once\n\n#if __cplusplus < 201103L\n#error Including <emscripten/wire.h> requires building with -std=c++11 or newer!\n#else\n\n// A value moving between JavaScript and C++ has three representations:\n// - The original JS value: a String\n// - The native on-the-wire value: a stack-allocated char*, say\n// - The C++ value: std::string\n//\n// We'll call the on-the-wire type WireType.\n\n#include <stdio.h>\n#include <cstdlib>\n#include <memory>\n#include <string>\n\n#define EMSCRIPTEN_ALWAYS_INLINE __attribute__((always_inline))\n\nnamespace emscripten {\n    #ifndef EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES\n    #define EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES 1\n    #endif\n\n\n    #if EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES\n    constexpr bool has_unbound_type_names = true;\n    #else\n    constexpr bool has_unbound_type_names = false;\n    #endif\n\n    namespace internal {\n        typedef const void* TYPEID;\n\n        // We don't need the full std::type_info implementation.  We\n        // just need a unique identifier per type and polymorphic type\n        // identification.\n        \n        template<typename T>\n        struct CanonicalizedID {\n            static char c;\n            static constexpr TYPEID get() {\n                return &c;\n            }\n        };\n\n        template<typename T>\n        char CanonicalizedID<T>::c;\n\n        template<typename T>\n        struct Canonicalized {\n            typedef typename std::remove_cv<typename std::remove_reference<T>::type>::type type;\n        };\n\n        template<typename T>\n        struct LightTypeID {\n            static constexpr TYPEID get() {\n                typedef typename Canonicalized<T>::type C;\n                if(has_unbound_type_names || std::is_polymorphic<C>::value) {\n#if __has_feature(cxx_rtti)\n                    return &typeid(T);\n#else\n                    static_assert(!has_unbound_type_names,\n                        \"Unbound type names are illegal with RTTI disabled. \"\n                        \"Either add -DEMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES=0 to or remove -fno-rtti \"\n                        \"from the compiler arguments\");\n                    static_assert(!std::is_polymorphic<C>::value,\n                        \"Canonicalized<T>::type being polymorphic is illegal with RTTI disabled\");\n#endif\n                }\n\n                return CanonicalizedID<C>::get();\n            }\n        };\n\n        template<typename T>\n        constexpr TYPEID getLightTypeID(const T& value) {\n            typedef typename Canonicalized<T>::type C;\n            if(has_unbound_type_names || std::is_polymorphic<C>::value) {\n#if __has_feature(cxx_rtti)\n                return &typeid(value);\n#else\n                static_assert(!has_unbound_type_names,\n                    \"Unbound type names are illegal with RTTI disabled. \"\n                    \"Either add -DEMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES=0 to or remove -fno-rtti \"\n                    \"from the compiler arguments\");\n                static_assert(!std::is_polymorphic<C>::value,\n                    \"Canonicalized<T>::type being polymorphic is illegal with RTTI disabled\");\n#endif\n            }\n            return LightTypeID<T>::get();\n        }\n\n        template<typename T>\n        struct TypeID {\n            static constexpr TYPEID get() {\n                return LightTypeID<T>::get();\n            }\n        };\n\n        template<typename T>\n        struct TypeID<std::unique_ptr<T>> {\n            static constexpr TYPEID get() {\n                return TypeID<T>::get();\n            }\n        };\n\n        template<typename T>\n        struct TypeID<T*> {\n            static_assert(!std::is_pointer<T*>::value, \"Implicitly binding raw pointers is illegal.  Specify allow_raw_pointer<arg<?>>\");\n        };\n\n        template<typename T>\n        struct AllowedRawPointer {\n        };\n\n        template<typename T>\n        struct TypeID<AllowedRawPointer<T>> {\n            static constexpr TYPEID get() {\n                return LightTypeID<T*>::get();\n            }\n        };\n        \n        // ExecutePolicies<>\n\n        template<typename... Policies>\n        struct ExecutePolicies;\n\n        template<>\n        struct ExecutePolicies<> {\n            template<typename T, int Index>\n            struct With {\n                typedef T type;\n            };\n        };\n        \n        template<typename Policy, typename... Remaining>\n        struct ExecutePolicies<Policy, Remaining...> {\n            template<typename T, int Index>\n            struct With {\n                typedef typename Policy::template Transform<\n                    typename ExecutePolicies<Remaining...>::template With<T, Index>::type,\n                    Index\n                >::type type;\n            };\n        };\n\n        // TypeList<>\n\n        template<typename...>\n        struct TypeList {};\n\n        // Cons :: T, TypeList<types...> -> Cons<T, types...>\n\n        template<typename First, typename TypeList>\n        struct Cons;\n\n        template<typename First, typename... Rest>\n        struct Cons<First, TypeList<Rest...>> {\n            typedef TypeList<First, Rest...> type;\n        };\n\n        // Apply :: T, TypeList<types...> -> T<types...>\n\n        template<template<typename...> class Output, typename TypeList>\n        struct Apply;\n\n        template<template<typename...> class Output, typename... Types>\n        struct Apply<Output, TypeList<Types...>> {\n            typedef Output<Types...> type;\n        };\n\n        // MapWithIndex_\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex, typename... Args>\n        struct MapWithIndex_;\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex, typename First, typename... Rest>\n        struct MapWithIndex_<Mapper, CurrentIndex, First, Rest...> {\n            typedef typename Cons<\n                typename Mapper<CurrentIndex, First>::type,\n                typename MapWithIndex_<Mapper, CurrentIndex + 1, Rest...>::type\n                >::type type;\n        };\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex>\n        struct MapWithIndex_<Mapper, CurrentIndex> {\n            typedef TypeList<> type;\n        };\n\n        template<template<typename...> class Output, template<size_t, typename> class Mapper, typename... Args>\n        struct MapWithIndex {\n            typedef typename internal::Apply<\n                Output,\n                typename MapWithIndex_<Mapper, 0, Args...>::type\n            >::type type;\n        };\n\n\n        template<typename ArgList>\n        struct ArgArrayGetter;\n\n        template<typename... Args>\n        struct ArgArrayGetter<TypeList<Args...>> {\n            static const TYPEID* get() {\n                static constexpr TYPEID types[] = { TypeID<Args>::get()... };\n                return types;\n            }\n        };\n\n        // WithPolicies<...>::ArgTypeList<...>\n\n        template<typename... Policies>\n        struct WithPolicies {\n            template<size_t Index, typename T>\n            struct MapWithPolicies {\n                typedef typename ExecutePolicies<Policies...>::template With<T, Index>::type type;\n            };\n\n            template<typename... Args>\n            struct ArgTypeList {\n                unsigned getCount() const {\n                    return sizeof...(Args);\n                }\n\n                const TYPEID* getTypes() const {\n                    return ArgArrayGetter<\n                        typename MapWithIndex<TypeList, MapWithPolicies, Args...>::type\n                    >::get();\n                }\n            };\n        };\n\n        // BindingType<T>\n\n        template<typename T>\n        struct BindingType;\n\n#define EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(type)                 \\\n        template<>                                                  \\\n        struct BindingType<type> {                                  \\\n            typedef type WireType;                                  \\\n            constexpr static WireType toWireType(const type& v) {   \\\n                return v;                                           \\\n            }                                                       \\\n            constexpr static type fromWireType(WireType v) {        \\\n                return v;                                           \\\n            }                                                       \\\n        }\n\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed short);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned short);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed int);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned int);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed long);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned long);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(float);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(double);\n\n        template<>\n        struct BindingType<void> {\n            typedef void WireType;\n        };\n\n        template<>\n        struct BindingType<bool> {\n            typedef bool WireType;\n            static WireType toWireType(bool b) {\n                return b;\n            }\n            static bool fromWireType(WireType wt) {\n                return wt;\n            }\n        };\n\n        template<>\n        struct BindingType<std::string> {\n            typedef struct {\n                size_t length;\n                char data[1]; // trailing data\n            }* WireType;\n            static WireType toWireType(const std::string& v) {\n                WireType wt = (WireType)malloc(sizeof(size_t) + v.length());\n                wt->length = v.length();\n                memcpy(wt->data, v.data(), v.length());\n                return wt;\n            }\n            static std::string fromWireType(WireType v) {\n                return std::string(v->data, v->length);\n            }\n        };\n\n        template<>\n        struct BindingType<std::wstring> {\n            typedef struct {\n                size_t length;\n                wchar_t data[1]; // trailing data\n            }* WireType;\n            static WireType toWireType(const std::wstring& v) {\n                WireType wt = (WireType)malloc(sizeof(size_t) + v.length() * sizeof(wchar_t));\n                wt->length = v.length();\n                wmemcpy(wt->data, v.data(), v.length());\n                return wt;\n            }\n            static std::wstring fromWireType(WireType v) {\n                return std::wstring(v->data, v->length);\n            }\n        };\n\n        template<typename T>\n        struct BindingType<const T> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<T&> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<const T&> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<T&&> {\n            typedef typename BindingType<T>::WireType WireType;\n            static WireType toWireType(const T& v) {\n                return BindingType<T>::toWireType(v);\n            }\n            static T fromWireType(WireType wt) {\n                return BindingType<T>::fromWireType(wt);\n            }\n        };\n\n        template<typename T>\n        struct BindingType<T*> {\n            typedef T* WireType;\n            static WireType toWireType(T* p) {\n                return p;\n            }\n            static T* fromWireType(WireType wt) {\n                return wt;\n            }\n        };\n\n        template<typename T>\n        struct GenericBindingType {\n            typedef typename std::remove_reference<T>::type ActualT;\n            typedef ActualT* WireType;\n\n            static WireType toWireType(const T& v) {\n                return new T(v);\n            }\n\n            static WireType toWireType(T&& v) {\n                return new T(std::forward<T>(v));\n            }\n\n            static ActualT& fromWireType(WireType p) {\n                return *p;\n            }\n        };\n\n        template<typename T>\n        struct GenericBindingType<std::unique_ptr<T>> {\n            typedef typename BindingType<T*>::WireType WireType;\n\n            static WireType toWireType(std::unique_ptr<T> p) {\n                return BindingType<T*>::toWireType(p.release());\n            }\n\n            static std::unique_ptr<T> fromWireType(WireType wt) {\n                return std::unique_ptr<T>(BindingType<T*>::fromWireType(wt));\n            }\n        };\n\n        template<typename Enum>\n        struct EnumBindingType {\n            typedef Enum WireType;\n\n            static WireType toWireType(Enum v) {\n                return v;\n            }\n            static Enum fromWireType(WireType v) {\n                return v;\n            }\n        };\n\n        // catch-all generic binding\n        template<typename T>\n        struct BindingType : std::conditional<\n            std::is_enum<T>::value,\n            EnumBindingType<T>,\n            GenericBindingType<T> >::type\n        {};\n\n        template<typename T>\n        auto toWireType(T&& v) -> typename BindingType<T>::WireType {\n            return BindingType<T>::toWireType(std::forward<T>(v));\n        }\n\n        template<typename T>\n        constexpr bool typeSupportsMemoryView() {\n            return (std::is_floating_point<T>::value &&\n                        (sizeof(T) == 4 || sizeof(T) == 8)) ||\n                    (std::is_integral<T>::value &&\n                        (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4));\n        }\n    }\n\n    template<typename ElementType>\n    struct memory_view {\n        memory_view() = delete;\n        explicit memory_view(size_t size, const ElementType* data)\n            : size(size)\n            , data(data)\n        {}\n\n        const size_t size; // in elements, not bytes\n        const void* const data;\n    };\n\n    // Note that 'data' is marked const just so it can accept both\n    // const and nonconst pointers.  It is certainly possible for\n    // JavaScript to modify the C heap through the typed array given,\n    // as it merely aliases the C heap.\n    template<typename T>\n    inline memory_view<T> typed_memory_view(size_t size, const T* data) {\n        static_assert(internal::typeSupportsMemoryView<T>(),\n            \"type of typed_memory_view is invalid\");\n        return memory_view<T>(size, data);\n    }\n\n    namespace internal {\n        template<typename ElementType>\n        struct BindingType<memory_view<ElementType>> {\n            // This non-word-sized WireType only works because I\n            // happen to know that clang will pass aggregates as\n            // pointers to stack elements and we never support\n            // converting JavaScript typed arrays back into\n            // memory_view.  (That is, fromWireType is not implemented\n            // on the C++ side, nor is toWireType implemented in\n            // JavaScript.)\n            typedef memory_view<ElementType> WireType;\n            static WireType toWireType(const memory_view<ElementType>& mv) {\n                return mv;\n            }\n        };\n    }\n}\n\n#endif // ~C++11 version check\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const basic_string& str, size_type pos, size_type n,\n                 const Allocator& a = Allocator());\n    template<class T>\n        basic_string(const T& t, size_type pos, size_type n, const Allocator& a = Allocator()); // C++17\n    explicit basic_string(const basic_string_view<charT, traits> sv, const Allocator& a = Allocator());\n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    operator basic_string_view<charT, traits>() const noexcept;\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string_view<charT, traits> sv);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value ); // C++17\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(basic_string_view<charT, traits> sv);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(basic_string_view<charT, traits> sv);\n    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14\n    template <class T>\n        basic_string& append(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string_view<charT, traits> sv);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14\n    template <class T>\n        basic_string& assign(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, basic_string_view<charT, traits> sv);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    template <class T>\n        basic_string& insert(size_type pos1, const T& t, size_type pos2, size_type n); // C++17\n    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, basic_string_view<charT, traits> sv);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2=npos); // C++14\n    template <class T>\n        basic_string& replace(size_type pos1, size_type n1, const T& t,\n                              size_type pos2, size_type n); // C++17\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, basic_string_view<charT, traits> sv);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n          value_type* data()       noexcept;   // C++17\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type ffind(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(basic_string_view<charT, traits> sv) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, basic_string_view<charT, traits> sv) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2=npos) const; // C++14\n    template <class T>\n        int compare(size_type pos1, size_type n1, const T& t,\n                    size_type pos2, size_type n2=npos) const; // C++17\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <string_view>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TEMPLATE_VIS fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\ntemplate <bool>\nclass _LIBCPP_TEMPLATE_VIS __basic_string_common\n{\nprotected:\n    _LIBCPP_NORETURN void __throw_length_error() const;\n    _LIBCPP_NORETURN void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n    _VSTD::__throw_length_error(\"basic_string\");\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n    _VSTD::__throw_out_of_range(\"basic_string\");\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __basic_string_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\n#ifdef _LIBCPP_NO_EXCEPTIONS\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public true_type {};\n#elif defined(_LIBCPP_HAS_NO_NOEXCEPT)\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public false_type {};\n#else\ntemplate <class _Iter, bool = __is_forward_iterator<_Iter>::value>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public _LIBCPP_BOOL_CONSTANT((\n    noexcept(++(declval<_Iter&>())) && \n    is_nothrow_assignable<_Iter&, _Iter>::value && \n    noexcept(declval<_Iter>() == declval<_Iter>()) && \n    noexcept(*declval<_Iter>())\n)) {};\n\ntemplate <class _Iter> \nstruct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false> : public false_type {};\n#endif\n\n\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value) {};\n\ntemplate <class _CharT, class _Traits, class _Tp>\nstruct __can_be_converted_to_string_view : public _LIBCPP_BOOL_CONSTANT(\n\t( is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&\n     !is_convertible<const _Tp&, const _CharT*>::value)) {};\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef basic_string_view<_CharT, _Traits>           __self_view;\n    typedef _Traits                                      traits_type;\n    typedef typename traits_type::char_type              value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert(is_pod<value_type>::value, \"Character type of basic_string must be a POD\");\n    static_assert((is_same<_CharT, value_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c, const allocator_type& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                 const allocator_type& __a = allocator_type());\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const basic_string& __str, size_type __pos,\n                 const allocator_type& __a = allocator_type());\n    template<class _Tp>\n        basic_string(const _Tp& __t, size_type __pos, size_type __n, \n                     const allocator_type& __a = allocator_type(),\n                     typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type* = 0);\n    _LIBCPP_INLINE_VISIBILITY explicit\n    basic_string(__self_view __sv);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(__self_view __sv, const allocator_type& __a);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    inline ~basic_string();\n\n    _LIBCPP_INLINE_VISIBILITY\n    operator __self_view() const _NOEXCEPT { return __self_view(data(), size()); }\n\n    basic_string& operator=(const basic_string& __str);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class = void>\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(__self_view __sv)  {return assign(__sv);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap()\n                             : static_cast<size_type>(__min_cap)) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos)       _NOEXCEPT;\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(__self_view __sv)          {return append(__sv);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)     {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(__self_view __sv) { return append(__sv.data(), __sv.size()); }\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  append(const _Tp& __t, size_type __pos, size_type __n=npos);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template <class _ForwardIterator>\n    inline basic_string& __append_forward_unsafe(_ForwardIterator, _ForwardIterator);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_InputIterator __first, _InputIterator __last) {\n      const basic_string __temp (__first, __last, __alloc());\n      append(__temp.data(), __temp.size());\n      return *this;\n    }\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_ForwardIterator __first, _ForwardIterator __last) {\n      return __append_forward_unsafe(__first, __last);\n    }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(__self_view __sv) { return assign(__sv.data(), __sv.size()); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str) { return *this = __str; }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n        {*this = _VSTD::move(str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  assign(const _Tp & __t, size_type pos, size_type n=npos);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, __self_view __sv) { return insert(__pos1, __sv.data(), __sv.size()); }\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, __self_view __sv) { return replace(__pos1, __n1, __sv.data(), __sv.size()); }\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, __self_view __sv) { return replace(__i1 - begin(), __i2 - __i1, __sv); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG;\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    value_type* data()             _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(__self_view __sv) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, __self_view __sv) const;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;\n    template <class _Tp>\n    inline _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            int\n        >::type\n        compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return (__s + (__a-1)) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? static_cast<size_type>(__min_cap) :\n                 __align_it<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(const value_type* __s, size_type __sz);\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    typename enable_if\n    <\n        __is_exactly_input_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() != __str.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __alloc() = __str.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n: __r_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,\n                                                       size_type __sz,\n                                                       size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    else\n    {\n        __r_.first().__r = __str.__r_.first().__r;\n        __str.__zero();\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, __str_sz - __pos);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n             const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a,\n\t\t\t typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type *)\n    : __r_(__a)\n{\n\t__self_view __sv = __self_view(__t).substr(__pos, __n);\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\t\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv)\n{\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_exactly_input_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, (void) ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign received nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str.data(), __str.size());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n#endif\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_exactly_input_iterator <_InputIterator>::value\n          || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    const basic_string __temp(__first, __last, __alloc());\n    assign(__temp.data(), __temp.size());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign received nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append received nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _Tp>\nbool __ptr_in_range (const _Tp* __p, const _Tp* __first, const _Tp* __last)\n{\n    return __first <= __p && __p < __last;\n}\n\ntemplate <class _Tp1, class _Tp2>\nbool __ptr_in_range (const _Tp1*, const _Tp2*, const _Tp2*)\n{\n    return false;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::__append_forward_unsafe(\n    _ForwardIterator __first, _ForwardIterator __last)\n{\n    static_assert(__is_forward_iterator<_ForwardIterator>::value,\n                  \"function requires a ForwardIterator\");\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_ref = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_ref), data(), data() + size()))\n        {\n            const basic_string __temp (__first, __last, __alloc());\n            append(__temp.data(), __temp.size());\n        }\n        else \n        {\n            if (__cap - __sz < __n)\n                __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n            pointer __p = __get_pointer() + __sz;\n            for (; __first != __last; ++__p, ++__first)\n                traits_type::assign(*__p, *__first);\n            traits_type::assign(*__p, value_type());\n            __set_size(__sz + __n);\n        }\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\n    typename enable_if\n    <\n        __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n        basic_string<_CharT, _Traits, _Allocator>&\n    >::type\nbasic_string<_CharT, _Traits, _Allocator>::append(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n   __is_exactly_input_iterator<_InputIterator>::value\n        || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n   typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    const basic_string __temp(__first, __last, __alloc());\n    return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n        && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_char = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_char), data(), data() + size()))\n        {\n            const basic_string __temp(__first, __last, __alloc());\n            return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n        }\n\n        size_type __sz = size();\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t,\n                                                  size_type __pos2, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __sv.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert received nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    const basic_string __temp(__j1, __j2, __alloc());\n    return this->replace(__i1, __i2, __temp);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n\t__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const _Tp& __t,\n                                                   size_type __pos2, size_type __n2)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __sv.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace received nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#if _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _LIBCPP_ASSERT(\n        __alloc_traits::propagate_on_container_swap::value ||\n        __alloc_traits::is_always_equal::value ||\n        __alloc() == __str.__alloc(), \"swapping non-equal allocators\");\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_allocator(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(__self_view __sv) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __sv.size();\n    int __result = traits_type::compare(data(), __sv.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    return compare(__self_view(__str));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): received nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   __self_view __sv) const\n{\n    return compare(__pos1, __n1, __sv.data(), __sv.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n\t__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tint\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const _Tp& __t,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    __self_view __sv = __t;\n    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n        return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__lhs != nullptr, \"operator==(char*, basic_string): received nullptr\");\n    size_t __lhs_len = _Traits::length(__lhs);\n    if (__lhs_len != __rhs.size()) return false;\n    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__rhs != nullptr, \"operator==(basic_string, char*): received nullptr\");\n    size_t __rhs_len = _Traits::length(__rhs);\n    if (__rhs_len != __lhs.size()) return false;\n    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TEMPLATE_VIS hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STRING\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n    typedef Alloc::is_always_equal\n          | is_empty                     is_always_equal;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\ntemplate <class T> T* addressof(const T&& r) noexcept = delete;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class T>\nvoid destroy_at(T* location);\n\ntemplate <class ForwardIterator>\n void destroy(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator destroy_n(ForwardIterator first, Size n);\n\ntemplate <class InputIterator, class ForwardIterator>\n ForwardIterator uninitialized_move(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\n pair<InputIterator,ForwardIterator> uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator>\n void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);\n\ntemplate <class ForwardIterator>\n void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n    typedef weak_ptr<T> weak_type; // C++17\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <stdexcept>\n#include <cstring>\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_relaxed_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_RELAXED) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_RELAXED);\n#else\n    return *__value;\n#endif\n}\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_acquire_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_ACQUIRE) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_ACQUIRE);\n#else\n    return *__value;\n#endif\n}\n\n// addressof moved to <type_traits>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_CXX03_LANG\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\ntemplate <class _From, class _To>\nstruct __rebind_pointer {\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_From>::template rebind<_To>        type;\n#else\n    typedef typename pointer_traits<_From>::template rebind<_To>::other type;\n#endif\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp>\nstruct __has_is_always_equal\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_always_equal* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>\nstruct __is_always_equal\n{\n    typedef typename _VSTD::is_empty<_Alloc>::type type;\n};\n\ntemplate <class _Alloc>\nstruct __is_always_equal<_Alloc, true>\n{\n    typedef typename _Alloc::is_always_equal type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TEMPLATE_VIS allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n    typedef typename __is_always_equal<allocator_type>::type\n                     is_always_equal;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_CXX03_LANG\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Iter, class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), *__begin1);\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_range_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            typedef typename remove_const<_Tp>::type _Vp;\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            if (_Np > 0)\n                _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max() / sizeof(value_type);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\ntemplate <class _Traits, class _Tp>\nstruct __rebind_alloc_helper\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Traits::template rebind_alloc<_Tp>        type;\n#else\n    typedef typename _Traits::template rebind_alloc<_Tp>::other type;\n#endif\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n        }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n    {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<const T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n    }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(_Tp&& __element)\n        {::new(&*__x_) _Tp(_VSTD::move(__element)); return *this;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY _OutputIterator base() const { return __x_; } \n#endif\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n                                       && !__libcpp_is_final<_T1>::value,\n                                bool = is_empty<_T2>::value\n                                       && !__libcpp_is_final<_T2>::value\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_(), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __first_(), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_() {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||\n                                           is_same<_Ptr1, _Ptr2>::value ||\n                                           __has_element_type<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete\n{\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete void type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TEMPLATE_VIS unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        !is_array<_Up>::value &&\n        is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n        is_assignable<deleter_type&, _Ep&>::value,\n        unique_ptr&\n    >::type\n    operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TEMPLATE_VIS unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p,\n            typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat()) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d,\n                                       typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p,\n                                         typename remove_reference<deleter_type>::type&& __d,\n                                         typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, void>::type\n    reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t = nullptr) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Dp>::value,\n    void\n>::type\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\nstruct _PairT {\n  size_t first;\n  size_t second;\n};\n\n_LIBCPP_INLINE_VISIBILITY\ninline size_t __hash_combine(size_t __lhs, size_t __rhs) _NOEXCEPT {\n    typedef __scalar_hash<_PairT> _HashT;\n    const _PairT __p = {__lhs, __rhs};\n    return _HashT()(__p);\n}\n\ntemplate<class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, (void) ++__r)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy_at(_Tp* __loc) {\n    _LIBCPP_ASSERT(__loc, \"null pointer given to destroy_at\");\n    __loc->~_Tp();\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy(_ForwardIterator __first, _ForwardIterator __last) {\n    for (; __first != __last; ++__first)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {\n    for (; __n > 0; (void)++__first, --__n)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _InputIt, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIt uninitialized_move(_InputIt __first, _InputIt __last, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __first != __last; (void)++__idx, ++__first)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _InputIt, class _Size, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIt, _ForwardIt>\nuninitialized_move_n(_InputIt __first, _Size __n, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; ++__idx, (void)++__first, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return {__first, __idx};\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\n\n#endif // _LIBCPP_STD_VER > 14\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_weak_ptr()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_weak_ptr();\n#else\n    _VSTD::abort();\n#endif\n}\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {\n        return __libcpp_relaxed_load(&__shared_owners_) + 1;\n    }\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? _VSTD::addressof(__data_.first().second()) : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n\n    _Al __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n    _Al __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS shared_ptr\n{\npublic:\n    typedef _Tp element_type;\n\n#if _LIBCPP_STD_VER > 14\n    typedef weak_ptr<_Tp> weak_type;\n#endif\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp>\n        explicit shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp>\n        shared_ptr(_Yp* __p, _Dp __d,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp, class _Alloc>\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY  shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#else\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp> __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp, class _OrigPtr>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e,\n                           _OrigPtr* __ptr) _NOEXCEPT\n        {\n            typedef typename remove_cv<_Yp>::type _RawYp;\n            if (__e && __e->__weak_this_.expired())\n            {\n                __e->__weak_this_ = shared_ptr<_RawYp>(*this,\n                    const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));\n            }\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const volatile void*, const volatile void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p, __p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,\n#endif\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get(), __r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                !is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*,\n                                     reference_wrapper<typename remove_reference<_Dp>::type>,\n                                     allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, \n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, \n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n        __throw_bad_weak_ptr();\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp = void> struct owner_less;\n#else\ntemplate <class _Tp> struct owner_less;\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<void>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x,  weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    typedef void is_transparent;\n};\n#endif\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<_Tp> weak_from_this() _NOEXCEPT\n       { return __weak_this_; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<const _Tp> weak_from_this() const _NOEXCEPT\n        { return __weak_this_; }\n#endif // _LIBCPP_STD_VER > 14\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    shared_ptr<_Tp> __temp;\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        _VSTD::swap(__temp, *__p);\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    _VSTD::swap(__temp, *__v);\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\n//enum class\n#if defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE)\n# ifndef _LIBCPP_CXX03_LANG\nenum class pointer_safety : unsigned char {\n  relaxed,\n  preferred,\n  strict\n};\n# endif\n#else\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety() : __v_() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n#endif\n\n#if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) && \\\n    defined(_LIBCPP_BUILDING_MEMORY)\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n#else\n// This function is only offered in C++03 under ABI v1.\n# if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) || !defined(_LIBCPP_CXX03_LANG)\ninline _LIBCPP_INLINE_VISIBILITY\npointer_safety get_pointer_safety() _NOEXCEPT {\n  return pointer_safety::relaxed;\n}\n# endif\n#endif\n\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n// --- Helper for container swap --\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    __swap_allocator(__a1, __a2, \n      integral_constant<bool, _VSTD::allocator_traits<_Alloc>::propagate_on_container_swap::value>());\n}\n\ntemplate <typename _Alloc>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    using _VSTD::swap;\n    swap(__a1, __a2);\n}\n\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc &, _Alloc &, false_type) _NOEXCEPT {}\n\ntemplate <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >\nstruct __noexcept_move_assign_container : public integral_constant<bool, \n    _Traits::propagate_on_container_move_assignment::value\n#if _LIBCPP_STD_VER > 14\n        || _Traits::is_always_equal::value\n#else\n        && is_nothrow_move_assignable<_Alloc>::value\n#endif\n    > {};\n\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class _Tp, class _Alloc>\nstruct __temp_value {\n    typedef allocator_traits<_Alloc> _Traits;\n    \n    typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;\n    _Alloc &__a;\n\n    _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }\n    _Tp &   get() { return *__addr(); }\n        \n    template<class... _Args>\n    __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc)\n    { _Traits::construct(__a, __addr(), _VSTD::forward<_Args>(__args)...); }\n    \n    ~__temp_value() { _Traits::destroy(__a, __addr()); }\n    };\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;   // C++11\n    typedef integral_constant<bool, false> false_type;  // C++11\n    \n    template <bool B>                                   // C++14\n    using bool_constant = integral_constant<bool, B>;   // C++14\n    typedef bool_constant<true> true_type;              // C++14\n    typedef bool_constant<false> false_type;            // C++14\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n    template <class T> struct is_final; // C++14\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T, class U>       struct is_swappable_with;       // C++17\n    template <class T>                struct is_swappable;            // C++17\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T, class U>       struct is_nothrow_swappable_with; // C++17\n    template <class T>                struct is_nothrow_swappable;      // C++17\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    template <class, class R = void> struct is_callable; // not defined\n    template <class Fn, class... ArgTypes, class R>\n      struct is_callable<Fn(ArgTypes...), R>;\n\n    template <class, class R = void> struct is_nothrow_callable; // not defined\n    template <class Fn, class... ArgTypes, class R>\n      struct is_nothrow_callable<Fn(ArgTypes...), R>;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n  \n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n  \n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n  \n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class F, class... ArgTypes>\n      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14\n\n    template <class...>\n      using void_t = void;   // C++17\n      \n      // See C++14 20.10.4.1, primary type categories\n      template <class T> constexpr bool is_void_v\n        = is_void<T>::value;                                             // C++17\n      template <class T> constexpr bool is_null_pointer_v\n        = is_null_pointer<T>::value;                                     // C++17\n      template <class T> constexpr bool is_integral_v\n        = is_integral<T>::value;                                         // C++17\n      template <class T> constexpr bool is_floating_point_v\n        = is_floating_point<T>::value;                                   // C++17\n      template <class T> constexpr bool is_array_v\n        = is_array<T>::value;                                            // C++17\n      template <class T> constexpr bool is_pointer_v\n        = is_pointer<T>::value;                                          // C++17\n      template <class T> constexpr bool is_lvalue_reference_v\n        = is_lvalue_reference<T>::value;                                 // C++17\n      template <class T> constexpr bool is_rvalue_reference_v\n        = is_rvalue_reference<T>::value;                                 // C++17\n      template <class T> constexpr bool is_member_object_pointer_v\n        = is_member_object_pointer<T>::value;                            // C++17\n      template <class T> constexpr bool is_member_function_pointer_v\n        = is_member_function_pointer<T>::value;                          // C++17\n      template <class T> constexpr bool is_enum_v\n        = is_enum<T>::value;                                             // C++17\n      template <class T> constexpr bool is_union_v\n        = is_union<T>::value;                                            // C++17\n      template <class T> constexpr bool is_class_v\n        = is_class<T>::value;                                            // C++17\n      template <class T> constexpr bool is_function_v\n        = is_function<T>::value;                                         // C++17\n\n      // See C++14 20.10.4.2, composite type categories\n      template <class T> constexpr bool is_reference_v\n        = is_reference<T>::value;                                        // C++17\n      template <class T> constexpr bool is_arithmetic_v\n        = is_arithmetic<T>::value;                                       // C++17\n      template <class T> constexpr bool is_fundamental_v\n        = is_fundamental<T>::value;                                      // C++17\n      template <class T> constexpr bool is_object_v\n        = is_object<T>::value;                                           // C++17\n      template <class T> constexpr bool is_scalar_v\n        = is_scalar<T>::value;                                           // C++17\n      template <class T> constexpr bool is_compound_v\n        = is_compound<T>::value;                                         // C++17\n      template <class T> constexpr bool is_member_pointer_v\n        = is_member_pointer<T>::value;                                   // C++17\n\n      // See C++14 20.10.4.3, type properties\n      template <class T> constexpr bool is_const_v\n        = is_const<T>::value;                                            // C++17\n      template <class T> constexpr bool is_volatile_v\n        = is_volatile<T>::value;                                         // C++17\n      template <class T> constexpr bool is_trivial_v\n        = is_trivial<T>::value;                                          // C++17\n      template <class T> constexpr bool is_trivially_copyable_v\n        = is_trivially_copyable<T>::value;                               // C++17\n      template <class T> constexpr bool is_standard_layout_v\n        = is_standard_layout<T>::value;                                  // C++17\n      template <class T> constexpr bool is_pod_v\n        = is_pod<T>::value;                                              // C++17\n      template <class T> constexpr bool is_literal_type_v\n        = is_literal_type<T>::value;                                     // C++17\n      template <class T> constexpr bool is_empty_v\n        = is_empty<T>::value;                                            // C++17\n      template <class T> constexpr bool is_polymorphic_v\n        = is_polymorphic<T>::value;                                      // C++17\n      template <class T> constexpr bool is_abstract_v\n        = is_abstract<T>::value;                                         // C++17\n      template <class T> constexpr bool is_final_v\n        = is_final<T>::value;                                            // C++17\n      template <class T> constexpr bool is_signed_v\n        = is_signed<T>::value;                                           // C++17\n      template <class T> constexpr bool is_unsigned_v\n        = is_unsigned<T>::value;                                         // C++17\n      template <class T, class... Args> constexpr bool is_constructible_v\n        = is_constructible<T, Args...>::value;                           // C++17\n      template <class T> constexpr bool is_default_constructible_v\n        = is_default_constructible<T>::value;                            // C++17\n      template <class T> constexpr bool is_copy_constructible_v\n        = is_copy_constructible<T>::value;                               // C++17\n      template <class T> constexpr bool is_move_constructible_v\n        = is_move_constructible<T>::value;                               // C++17\n      template <class T, class U> constexpr bool is_assignable_v\n        = is_assignable<T, U>::value;                                    // C++17\n      template <class T> constexpr bool is_copy_assignable_v\n        = is_copy_assignable<T>::value;                                  // C++17\n      template <class T> constexpr bool is_move_assignable_v\n        = is_move_assignable<T>::value;                                  // C++17\n      template <class T, class U> constexpr bool is_swappable_with_v\n        = is_swappable_with<T, U>::value;                                // C++17\n      template <class T> constexpr bool is_swappable_v\n        = is_swappable<T>::value;                                        // C++17\n      template <class T> constexpr bool is_destructible_v\n        = is_destructible<T>::value;                                     // C++17\n      template <class T, class... Args> constexpr bool is_trivially_constructible_v\n        = is_trivially_constructible<T, Args...>::value;                 // C++17\n      template <class T> constexpr bool is_trivially_default_constructible_v\n        = is_trivially_default_constructible<T>::value;                  // C++17\n      template <class T> constexpr bool is_trivially_copy_constructible_v\n        = is_trivially_copy_constructible<T>::value;                     // C++17\n      template <class T> constexpr bool is_trivially_move_constructible_v\n        = is_trivially_move_constructible<T>::value;                     // C++17\n      template <class T, class U> constexpr bool is_trivially_assignable_v\n        = is_trivially_assignable<T, U>::value;                          // C++17\n      template <class T> constexpr bool is_trivially_copy_assignable_v\n        = is_trivially_copy_assignable<T>::value;                        // C++17\n      template <class T> constexpr bool is_trivially_move_assignable_v\n        = is_trivially_move_assignable<T>::value;                        // C++17\n      template <class T> constexpr bool is_trivially_destructible_v\n        = is_trivially_destructible<T>::value;                           // C++17\n      template <class T, class... Args> constexpr bool is_nothrow_constructible_v\n        = is_nothrow_constructible<T, Args...>::value;                   // C++17\n      template <class T> constexpr bool is_nothrow_default_constructible_v\n        = is_nothrow_default_constructible<T>::value;                    // C++17\n      template <class T> constexpr bool is_nothrow_copy_constructible_v\n        = is_nothrow_copy_constructible<T>::value;                       // C++17\n      template <class T> constexpr bool is_nothrow_move_constructible_v\n        = is_nothrow_move_constructible<T>::value;                       // C++17\n      template <class T, class U> constexpr bool is_nothrow_assignable_v\n        = is_nothrow_assignable<T, U>::value;                            // C++17\n      template <class T> constexpr bool is_nothrow_copy_assignable_v\n        = is_nothrow_copy_assignable<T>::value;                          // C++17\n      template <class T> constexpr bool is_nothrow_move_assignable_v\n        = is_nothrow_move_assignable<T>::value;                          // C++17\n      template <class T, class U> constexpr bool is_nothrow_swappable_with_v\n        = is_nothrow_swappable_with<T, U>::value;                       // C++17\n      template <class T> constexpr bool is_nothrow_swappable_v\n        = is_nothrow_swappable<T>::value;                               // C++17\n      template <class T> constexpr bool is_nothrow_destructible_v\n        = is_nothrow_destructible<T>::value;                             // C++17\n      template <class T> constexpr bool has_virtual_destructor_v\n        = has_virtual_destructor<T>::value;                              // C++17\n\n      // See C++14 20.10.5, type property queries\n      template <class T> constexpr size_t alignment_of_v\n        = alignment_of<T>::value;                                        // C++17\n      template <class T> constexpr size_t rank_v\n        = rank<T>::value;                                                // C++17\n      template <class T, unsigned I = 0> constexpr size_t extent_v\n        = extent<T, I>::value;                                           // C++17\n\n      // See C++14 20.10.6, type relations\n      template <class T, class U> constexpr bool is_same_v\n        = is_same<T, U>::value;                                          // C++17\n      template <class Base, class Derived> constexpr bool is_base_of_v\n        = is_base_of<Base, Derived>::value;                              // C++17\n      template <class From, class To> constexpr bool is_convertible_v\n        = is_convertible<From, To>::value;                               // C++17\n      template <class T, class R = void> constexpr bool is_callable_v\n        = is_callable<T, R>::value;                                      // C++17\n      template <class T, class R = void> constexpr bool is_nothrow_callable_v\n        = is_nothrow_callable<T, R>::value;                              // C++17\n\n      // [meta.logical], logical operator traits:\n      template<class... B> struct conjunction;                           // C++17\n      template<class... B> \n        constexpr bool conjunction_v = conjunction<B...>::value;         // C++17\n      template<class... B> struct disjunction;                           // C++17\n      template<class... B>\n        constexpr bool disjunction_v = disjunction<B...>::value;         // C++17\n      template<class B> struct negation;                                 // C++17\n      template<class B> \n        constexpr bool negation_v = negation<B>::value;                  // C++17\n\n}\n\n*/\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair;\ntemplate <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper;\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash;\n\ntemplate <class>\nstruct __void_t { typedef void type; };\n\ntemplate <class _Tp>\nstruct __identity { typedef _Tp type; };\n\ntemplate <class _Tp, bool>\nstruct _LIBCPP_TEMPLATE_VIS __dependent_type : public _Tp {};\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TEMPLATE_VIS conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TEMPLATE_VIS conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TEMPLATE_VIS enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n// addressof\n#ifndef _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n\ntemplate <class _Tp>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\n_LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return __builtin_addressof(__x);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n  return reinterpret_cast<_Tp *>(\n      const_cast<char *>(&reinterpret_cast<const volatile char &>(__x)));\n}\n\n#endif // _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\n#if !defined(_LIBCPP_CXX03_LANG)\ntemplate <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;\n#endif\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TEMPLATE_VIS integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const _NOEXCEPT {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\n#if _LIBCPP_STD_VER > 14\ntemplate <bool __b>\nusing bool_constant = integral_constant<bool, __b>;\n#define _LIBCPP_BOOL_CONSTANT(__b) bool_constant<(__b)>\n#else\n#define _LIBCPP_BOOL_CONSTANT(__b) integral_constant<bool,(__b)>\n#endif\n\ntypedef _LIBCPP_BOOL_CONSTANT(true)  true_type;\ntypedef _LIBCPP_BOOL_CONSTANT(false) false_type;\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\n// __lazy_and\n\ntemplate <bool _Last, class ..._Preds>\nstruct __lazy_and_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_and_impl<false, _Preds...> : false_type {};\n\ntemplate <>\nstruct __lazy_and_impl<true> : true_type {};\n\ntemplate <class _Pred>\nstruct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_or\n\ntemplate <bool _List, class ..._Preds>\nstruct __lazy_or_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_or_impl<true, _Preds...> : true_type {};\n\ntemplate <>\nstruct __lazy_or_impl<false> : false_type {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_or_impl<false, _Hp, _Tp...>\n        : __lazy_or_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_not\n\ntemplate <class _Pred>\nstruct __lazy_not : integral_constant<bool, !_Pred::type::value> {};\n\n// __and_\ntemplate<class...> struct __and_;\ntemplate<> struct __and_<> : true_type {};\n\ntemplate<class _B0> struct __and_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __and_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};\n\n// __or_\ntemplate<class...> struct __or_;\ntemplate<> struct __or_<> : false_type {};\n\ntemplate<class _B0> struct __or_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __or_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};\n\n// __not_\ntemplate<class _Tp> \nstruct __not_ : conditional<_Tp::value, false_type, true_type>::type {};\n\n#endif // !defined(_LIBCPP_CXX03_LANG)\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const<_Tp const> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_const_v\n    = is_const<_Tp>::value;\n#endif\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile<_Tp volatile> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_volatile_v\n    = is_volatile<_Tp>::value;\n#endif\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};\ntemplate <>          struct __libcpp_is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_void\n    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_void_v\n    = is_void<_Tp>::value;\n#endif\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};\ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __is_nullptr_t\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_null_pointer\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_null_pointer_v\n    = is_null_pointer<_Tp>::value;\n#endif\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};\ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};\ntemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_integral\n    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_integral_v\n    = is_integral<_Tp>::value;\n#endif\n\n// is_floating_point\n\ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};\ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_floating_point\n    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_floating_point_v\n    = is_floating_point<_Tp>::value;\n#endif\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[_Np]>\n    : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_array_v\n    = is_array<_Tp>::value;\n#endif\n\n// is_pointer\n\ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};\ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pointer\n    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pointer_v\n    = is_pointer<_Tp>::value;\n#endif\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&&> : public true_type {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_reference_v\n    = is_reference<_Tp>::value;\n\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_lvalue_reference_v\n    = is_lvalue_reference<_Tp>::value;\n\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_rvalue_reference_v\n    = is_rvalue_reference<_Tp>::value;\n#endif\n// is_union\n\n#if __has_feature(is_union) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_union_v\n    = is_union<_Tp>::value;\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_class_v\n    = is_class<_Tp>::value;\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TEMPLATE_VIS is_same<_Tp, _Tp> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Up> _LIBCPP_CONSTEXPR bool is_same_v\n    = is_same<_Tp, _Up>::value;\n#endif\n\n// is_function\n\nnamespace __libcpp_is_function_imp\n{\nstruct __dummy_type {};\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> char __test(__dummy_type);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source(int);\ntemplate <class _Tp> __dummy_type __source(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __libcpp_is_function\n    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>\n    {};\ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_function\n    : public __libcpp_is_function<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_function_v\n    = is_function<_Tp>::value;\n#endif\n\n// is_member_function_pointer\n\n// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};\n// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n// \n\ntemplate <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{  // forward declaration; specializations later\n};\n\n\ntemplate <class _Tp> struct __libcpp_is_member_function_pointer\n    : public false_type {};\n\ntemplate <class _Ret, class _Class>\nstruct __libcpp_is_member_function_pointer<_Ret _Class::*>\n    : public is_function<_Ret> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_function_pointer\n    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_function_pointer_v\n    = is_member_function_pointer<_Tp>::value;\n#endif\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_pointer\n    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_pointer_v\n    = is_member_pointer<_Tp>::value;\n#endif\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_object_pointer_v\n    = is_member_object_pointer<_Tp>::value;\n#endif\n\n// is_enum\n\n#if __has_feature(is_enum) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_enum_v\n    = is_enum<_Tp>::value;\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_arithmetic_v\n    = is_arithmetic<_Tp>::value;\n#endif\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_fundamental_v\n    = is_fundamental<_Tp>::value;\n#endif\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TEMPLATE_VIS is_scalar<nullptr_t> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_scalar_v\n    = is_scalar<_Tp>::value;\n#endif\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_object_v\n    = is_object<_Tp>::value;\n#endif\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_compound_v\n    = is_compound<_Tp>::value;\n#endif\n\n\n// __is_referenceable  [defns.referenceable]\n\nstruct __is_referenceable_impl {\n    template <class _Tp> static _Tp& __test(int);\n    template <class _Tp> static __two __test(...);\n};\n\ntemplate <class _Tp>\nstruct __is_referenceable : integral_constant<bool,\n    !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};\n\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl            { typedef _Tp  type; };\ntemplate <class _Tp                                       > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_lvalue_reference\n{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl            { typedef _Tp   type; };\ntemplate <class _Tp                                       > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_rvalue_reference\n{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> _Tp&& __declval(int);\ntemplate <class _Tp> _Tp   __declval(long);\n\ntemplate <class _Tp>\ndecltype(_VSTD::__declval<_Tp>(0))\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// __uncvref\n\ntemplate <class _Tp>\nstruct __uncvref  {\n    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __unconstref {\n    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;\n};\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp>\nusing __uncvref_t = typename __uncvref<_Tp>::type;\n#endif\n\n// __is_same_uncvref\n\ntemplate <class _Tp, class _Up>\nstruct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,\n                                   typename __uncvref<_Up>::type> {};\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp, \n        bool = __is_referenceable<_Tp>::value || \n                is_same<typename remove_cv<_Tp>::type, void>::value>\nstruct __add_pointer_impl\n    {typedef typename remove_reference<_Tp>::type* type;};\ntemplate <class _Tp> struct __add_pointer_impl<_Tp, false> \n    {typedef _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_pointer\n    {typedef typename __add_pointer_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_signed_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(-1) < _Tp(0)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_signed : public __libcpp_is_signed<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_signed_v\n    = is_signed<_Tp>::value;\n#endif\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_unsigned_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(0) < _Tp(-1)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_unsigned : public __libcpp_is_unsigned<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_unsigned_v\n    = is_unsigned<_Tp>::value;\n#endif\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR size_t rank_v\n    = rank<_Tp>::value;\n#endif\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TEMPLATE_VIS extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, unsigned _Ip = 0> _LIBCPP_CONSTEXPR size_t extent_v\n    = extent<_Tp, _Ip>::value;\n#endif\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_abstract\n    : public integral_constant<bool, __is_abstract(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_abstract_v\n    = is_abstract<_Tp>::value;\n#endif\n\n// is_final\n\n#if defined(_LIBCPP_HAS_IS_FINAL)\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\n__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};\n#else\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\n__libcpp_is_final : public false_type {};\n#endif\n\n#if defined(_LIBCPP_HAS_IS_FINAL) && _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\nis_final : public integral_constant<bool, __is_final(_Tp)> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_final_v\n    = is_final<_Tp>::value;\n#endif\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // _LIBCPP_HAS_IS_BASE_OF\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // _LIBCPP_HAS_IS_BASE_OF\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Bp, class _Dp> _LIBCPP_CONSTEXPR bool is_base_of_v\n    = is_base_of<_Bp, _Dp>::value;\n#endif\n\n// is_convertible\n\n#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> void  __test_convert(_Tp);\n\ntemplate <class _From, class _To, class = void>\nstruct __is_convertible_test : public false_type {};\n\ntemplate <class _From, class _To>\nstruct __is_convertible_test<_From, _To,\n    decltype(_VSTD::__is_convertible_imp::__test_convert<_To>(_VSTD::declval<_From>()))> : public true_type\n{};\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n        __is_convertible_imp::__is_convertible_test<_T1, _T2>::value\n#if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _From, class _To> _LIBCPP_CONSTEXPR bool is_convertible_v\n    = is_convertible<_From, _To>::value;\n#endif\n\n// is_empty\n\n#if __has_feature(is_empty) || (_GNUC_VER >= 407)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_empty_v\n    = is_empty<_Tp>::value;\n#endif\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic) || defined(_LIBCPP_COMPILER_MSVC)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_polymorphic_v\n    = is_polymorphic<_Tp>::value;\n#endif\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool has_virtual_destructor_v\n    = has_virtual_destructor<_Tp>::value;\n#endif\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS alignment_of\n    : public integral_constant<size_t, __alignof__(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR size_t alignment_of_v\n    = alignment_of<_Tp>::value;\n#endif\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_CXX03_LANG\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = alignment_of<_Tp>::value;\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TEMPLATE_VIS aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TEMPLATE_VIS aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[(_Len + n - 1)/n * n];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// PE/COFF does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<__alignof__(_Type0),\n                                                       __alignof__(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __numeric_type\n{\n   static void __test(...);\n   static float __test(float);\n   static double __test(char);\n   static double __test(int);\n   static double __test(unsigned);\n   static double __test(long);\n   static double __test(unsigned long);\n   static double __test(long long);\n   static double __test(unsigned long long);\n   static double __test(double);\n   static long double __test(long double);\n\n   typedef decltype(__test(declval<_Tp>())) type;\n   static const bool value = !is_same<type, void>::value;\n};\n\ntemplate <>\nstruct __numeric_type<void>\n{\n   static const bool value = true;\n};\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = __numeric_type<_A1>::value &&\n                 __numeric_type<_A2>::value &&\n                 __numeric_type<_A3>::value>\nclass __promote_imp\n{\npublic:\n    static const bool value = false;\n};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote_imp<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\n    typedef typename __promote_imp<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote_imp<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1>\nclass __promote_imp<_A1, void, void, true>\n{\npublic:\n    typedef typename __numeric_type<_A1>::type type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2 = void, class _A3 = void>\nclass __promote : public __promote_imp<_A1, _A2, _A3> {};\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__int128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__uint128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};\ntemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};\ntemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class _Vp = void>\nstruct _LIBCPP_TEMPLATE_VIS common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp>::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, void, void>\n{\npublic:\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, void>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n      )>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// bullet 1 - sizeof...(Tp) == 0\n\ntemplate <class ..._Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type {};\n\n// bullet 2 - sizeof...(Tp) == 1\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp>\n{\n    typedef typename decay<_Tp>::type type;\n};\n\n// bullet 3 - sizeof...(Tp) == 2\n\ntemplate <class _Tp, class _Up, class = void>\nstruct __common_type2_imp {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type2_imp<_Tp, _Up,\n    typename __void_t<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type type;\n};\n\ntemplate <class _Tp, class _Up,\n          class _DTp = typename decay<_Tp>::type,\n          class _DUp = typename decay<_Up>::type>\nusing __common_type2 =\n  typename conditional<\n    is_same<_Tp, _DTp>::value && is_same<_Up, _DUp>::value,\n    __common_type2_imp<_Tp, _Up>,\n    common_type<_DTp, _DUp>\n  >::type;\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up>\n    : __common_type2<_Tp, _Up> {};\n\n// bullet 4 - sizeof...(Tp) > 2\n\ntemplate <class ...Tp> struct __common_types;\n\ntemplate <class, class = void>\nstruct __common_type_impl {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type_impl<\n    __common_types<_Tp, _Up>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n{\n  typedef typename common_type<_Tp, _Up>::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n  : __common_type_impl<\n      __common_types<typename common_type<_Tp, _Up>::type, _Vp...> >\n{\n\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, _Vp...>\n    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n__is_assignable_test(int);\n\ntemplate <class, class>\nfalse_type __is_assignable_test(...);\n\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public decltype((_VSTD::__is_assignable_test<_Tp, _Arg>(0))) {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_assignable_v\n    = is_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_assignable_v\n    = is_copy_assignable<_Tp>::value;\n#endif\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                           typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_assignable_v\n    = is_move_assignable<_Tp>::value;\n#endif\n\n// is_destructible\n\n//  if it's a reference, return true\n//  if it's a function, return false\n//  if it's   void,     return false\n//  if it's an array of unknown bound, return false\n//  Otherwise, return \"std::declval<_Up&>().~_Up()\" is well-formed\n//    where _Up is remove_all_extents<_Tp>::type\n\ntemplate <class>\nstruct __is_destructible_apply { typedef int type; };\n\ntemplate <typename _Tp>\nstruct __is_destructor_wellformed {\n    template <typename _Tp1>\n    static char  __test (\n        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type\n    );\n\n    template <typename _Tp1>\n    static __two __test (...);\n    \n    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);\n};\n\ntemplate <class _Tp, bool>\nstruct __destructible_imp;\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, false> \n   : public _VSTD::integral_constant<bool, \n        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public _VSTD::true_type {};\n\ntemplate <class _Tp, bool>\nstruct __destructible_false;\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public _VSTD::false_type {};\n\ntemplate <>\nstruct is_destructible<void>\n    : public _VSTD::false_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_destructible_v\n    = is_destructible<_Tp>::value;\n#endif\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp&&\nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp&&\nforward(typename remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!is_lvalue_reference<_Tp>::value,\n                  \"can not forward an rvalue as an lvalue\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#if __has_feature(cxx_reference_qualified_functions) || \\\n    (defined(_GNUC_VER) && _GNUC_VER >= 409)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions) || _GNUC_VER >= 409\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n//     typedef ... _FnType;\n};\n\n\ntemplate <class _DecayedFp>\nstruct __member_pointer_class_type {};\n\ntemplate <class _Ret, class _ClassType>\nstruct __member_pointer_class_type<_Ret _ClassType::*> {\n  typedef _ClassType type;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public __identity<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\nnamespace __is_construct\n{\nstruct __nat {};\n}\n\n#if !defined(_LIBCPP_CXX03_LANG) && (!__has_feature(is_constructible) || \\\n    defined(_LIBCPP_TESTING_FALLBACK_IS_CONSTRUCTIBLE))\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_constructible;\n\ntemplate <class _To, class _From>\nstruct __is_invalid_base_to_derived_cast {\n  static_assert(is_reference<_To>::value, \"Wrong specialization\");\n  using _RawFrom = __uncvref_t<_From>;\n  using _RawTo = __uncvref_t<_To>;\n  static const bool value = __lazy_and<\n        __lazy_not<is_same<_RawFrom, _RawTo>>,\n        is_base_of<_RawFrom, _RawTo>,\n        __lazy_not<__libcpp_is_constructible<_RawTo, _From>>\n  >::value;\n};\n\ntemplate <class _To, class _From>\nstruct __is_invalid_lvalue_to_rvalue_cast : false_type {\n  static_assert(is_reference<_To>::value, \"Wrong specialization\");\n};\n\ntemplate <class _ToRef, class _FromRef>\nstruct __is_invalid_lvalue_to_rvalue_cast<_ToRef&&, _FromRef&> {\n  using _RawFrom = __uncvref_t<_FromRef>;\n  using _RawTo = __uncvref_t<_ToRef>;\n  static const bool value = __lazy_and<\n      __lazy_not<is_function<_RawTo>>,\n      __lazy_or<\n        is_same<_RawFrom, _RawTo>,\n        is_base_of<_RawTo, _RawFrom>>\n    >::value;\n};\n\nstruct __is_constructible_helper\n{\n    template <class _To>\n    static void __eat(_To);\n\n    // This overload is needed to work around a Clang bug that disallows\n    // static_cast<T&&>(e) for non-reference-compatible types.\n    // Example: static_cast<int&&>(declval<double>());\n    // NOTE: The static_cast implementation below is required to support\n    //  classes with explicit conversion operators.\n    template <class _To, class _From,\n              class = decltype(__eat<_To>(_VSTD::declval<_From>()))>\n    static true_type __test_cast(int);\n\n    template <class _To, class _From,\n              class = decltype(static_cast<_To>(_VSTD::declval<_From>()))>\n    static integral_constant<bool,\n        !__is_invalid_base_to_derived_cast<_To, _From>::value &&\n        !__is_invalid_lvalue_to_rvalue_cast<_To, _From>::value\n    > __test_cast(long);\n\n    template <class, class>\n    static false_type __test_cast(...);\n\n    template <class _Tp, class ..._Args,\n        class = decltype(_Tp(_VSTD::declval<_Args>()...))>\n    static true_type __test_nary(int);\n    template <class _Tp, class...>\n    static false_type __test_nary(...);\n\n    template <class _Tp, class _A0, class = decltype(::new _Tp(_VSTD::declval<_A0>()))>\n    static is_destructible<_Tp> __test_unary(int);\n    template <class, class>\n    static false_type __test_unary(...);\n};\n\ntemplate <class _Tp, bool = is_void<_Tp>::value>\nstruct __is_default_constructible\n    : decltype(__is_constructible_helper::__test_nary<_Tp>(0))\n{};\n\ntemplate <class _Tp>\nstruct __is_default_constructible<_Tp, true> : false_type {};\n\ntemplate <class _Tp>\nstruct __is_default_constructible<_Tp[], false> : false_type {};\n\ntemplate <class _Tp, size_t _Nx>\nstruct __is_default_constructible<_Tp[_Nx], false>\n    : __is_default_constructible<typename remove_all_extents<_Tp>::type>  {};\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_constructible\n{\n  static_assert(sizeof...(_Args) > 1, \"Wrong specialization\");\n  typedef decltype(__is_constructible_helper::__test_nary<_Tp, _Args...>(0))\n      type;\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_constructible<_Tp> : __is_default_constructible<_Tp> {};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp, _A0>\n    : public decltype(__is_constructible_helper::__test_unary<_Tp, _A0>(0))\n{};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp&, _A0>\n    : public decltype(__is_constructible_helper::\n    __test_cast<_Tp&, _A0>(0))\n{};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp&&, _A0>\n    : public decltype(__is_constructible_helper::\n    __test_cast<_Tp&&, _A0>(0))\n{};\n\n#endif\n\n#if __has_feature(is_constructible)\ntemplate <class _Tp, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>\n    {};\n#elif !defined(_LIBCPP_CXX03_LANG)\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public __libcpp_is_constructible<_Tp, _Args...>::type {};\n#else\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\n#endif // __has_feature(is_constructible)\n\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_constructible_v\n    = is_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_default_constructible_v\n    = is_default_constructible<_Tp>::value;\n#endif\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_copy_constructible\n    : public is_constructible<_Tp, \n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_constructible_v\n    = is_copy_constructible<_Tp>::value;\n#endif\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_constructible_v\n    = is_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class... _Args> _LIBCPP_CONSTEXPR bool is_trivially_constructible_v\n    = is_trivially_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_default_constructible_v\n    = is_trivially_default_constructible<_Tp>::value;\n#endif\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_constructible_v\n    = is_trivially_copy_constructible<_Tp>::value;\n#endif\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_constructible_v\n    = is_trivially_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_assignable)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_trivially_assignable_v\n    = is_trivially_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_assignable_v\n    = is_trivially_copy_assignable<_Tp>::value;\n#endif\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v\n    = is_trivially_move_assignable<_Tp>::value;\n#endif\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible\n    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_destructible_v\n    = is_trivially_destructible<_Tp>::value;\n#endif\n\n// is_nothrow_constructible\n\n#if 0\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>\n{\n};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp>\nvoid __implicit_conversion_to(_Tp) noexcept { }\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>\n{\n};\n\ntemplate <class _Tp, bool _IsReference, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp[_Ns]>\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_nothrow_constructible)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_nothrow_constructible_v\n    = is_nothrow_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_default_constructible_v\n    = is_nothrow_default_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_constructible_v\n    = is_nothrow_copy_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_constructible_v\n    = is_nothrow_move_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable\n    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_nothrow_assignable_v\n    = is_nothrow_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_assignable_v\n    = is_nothrow_copy_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_assignable_v\n    = is_nothrow_move_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible\n    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_destructible_v\n    = is_nothrow_destructible<_Tp>::value;\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pod_v\n    = is_pod<_Tp>::value;\n#endif\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_literal_type\n#ifdef _LIBCPP_IS_LITERAL\n    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_literal_type_v\n    = is_literal_type<_Tp>::value;\n#endif\n\n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_standard_layout\n#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_standard_layout_v\n    = is_standard_layout<_Tp>::value;\n#endif\n\n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#elif _GNUC_VER >= 501\n    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copyable_v\n    = is_trivially_copyable<_Tp>::value;\n#endif\n\n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivial\n#if __has_feature(is_trivial) || _GNUC_VER >= 407\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivial_v\n    = is_trivial<_Tp>::value;\n#endif\n\ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};\ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};\n\n#ifndef _LIBCPP_CXX03_LANG\n\n// Check for complete types\n\ntemplate <class ..._Tp> struct __check_complete;\n\ntemplate <>\nstruct __check_complete<>\n{\n};\n\ntemplate <class _Hp, class _T0, class ..._Tp>\nstruct __check_complete<_Hp, _T0, _Tp...>\n    : private __check_complete<_Hp>,\n      private __check_complete<_T0, _Tp...>\n{\n};\n\ntemplate <class _Hp>\nstruct __check_complete<_Hp, _Hp>\n    : private __check_complete<_Hp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp>\n{\n    static_assert(sizeof(_Tp) > 0, \"Type must be complete.\");\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (*)(_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (*)(_Param...)>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (_Param...)>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...)>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class>\nstruct __check_complete<_Rp _Class::*>\n    : private __check_complete<_Class>\n{\n};\n\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet1 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet2 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet3 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet4 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet5 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet6 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\n#define _LIBCPP_INVOKE_RETURN(...) \\\n    noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) \\\n    { return __VA_ARGS__; }\n\ntemplate <class ..._Args>\nauto __invoke(__any, _Args&& ...__args) -> __nat;\n\ntemplate <class ..._Args>\nauto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;\n\n// bullets 1, 2 and 3\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\n// bullets 4, 5 and 6\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\n// bullet 7\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\n#undef _LIBCPP_INVOKE_RETURN\n\n// __invokable\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __invokable_r\n    : private __check_complete<_Fp>\n{\n    using _Result = decltype(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n\n    static const bool value =\n        conditional<\n            !is_same<_Result, __nat>::value,\n            typename conditional<\n                is_void<_Ret>::value,\n                true_type,\n                is_convertible<_Result, _Ret>\n            >::type,\n            false_type\n        >::type::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nusing __invokable = __invokable_r<void, _Fp, _Args...>;\n\ntemplate <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp {\n  static const bool value = false;\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>\n{\n    typedef __nothrow_invokable_r_imp _ThisT;\n\n    template <class _Tp>\n    static void __test_noexcept(_Tp) noexcept;\n\n    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>\n{\n    static const bool value = noexcept(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nusing __nothrow_invokable_r =\n    __nothrow_invokable_r_imp<\n            __invokable_r<_Ret, _Fp, _Args...>::value,\n            is_void<_Ret>::value,\n            _Ret, _Fp, _Args...\n    >;\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public enable_if<\n        __invokable<_Fp, _Args...>::value,\n        typename __invokable_r<void, _Fp, _Args...>::_Result>\n{\n};\n\n// result_of\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#if _LIBCPP_STD_VER > 14\n\n// is_callable\n\ntemplate <class _Fn, class _Ret = void>\nstruct _LIBCPP_TEMPLATE_VIS is_callable;\n\ntemplate <class _Fn, class ..._Args, class _Ret>\nstruct _LIBCPP_TEMPLATE_VIS is_callable<_Fn(_Args...), _Ret>\n    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};\n\ntemplate <class _Fn, class _Ret = void>\nconstexpr bool is_callable_v = is_callable<_Fn, _Ret>::value;\n\n// is_nothrow_callable\n\ntemplate <class _Fn, class _Ret = void>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_callable;\n\ntemplate <class _Fn, class ..._Args, class _Ret>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_callable<_Fn(_Args...), _Ret>\n    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value>\n{};\n\ntemplate <class _Fn, class _Ret = void>\nconstexpr bool is_nothrow_callable_v = is_nothrow_callable<_Fn, _Ret>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Tp> struct __is_swappable;\ntemplate <class _Tp> struct __is_nothrow_swappable;\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_CXX03_LANG\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Tp>::value\n>::type\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value);\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n// ALL generic swap overloads MUST already have a declaration available at this point.\n\ntemplate <class _Tp, class _Up = _Tp,\n          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>\nstruct __swappable_with\n{\n    template <class _LHS, class _RHS>\n    static decltype(swap(_VSTD::declval<_LHS>(), _VSTD::declval<_RHS>()))\n    __test_swap(int);\n    template <class, class>\n    static __nat __test_swap(long);\n\n    // Extra parens are needed for the C++03 definition of decltype.\n    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;\n    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;\n\n    static const bool value = !is_same<__swap1, __nat>::value\n                           && !is_same<__swap2, __nat>::value;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __swappable_with<_Tp, _Up,  false> : false_type {};\n\ntemplate <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>\nstruct __nothrow_swappable_with {\n  static const bool value =\n#ifndef _LIBCPP_HAS_NO_NOEXCEPT\n      noexcept(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>()))\n  &&  noexcept(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>()));\n#else\n      false;\n#endif\n};\n\ntemplate <class _Tp, class _Up>\nstruct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>\n{\n};\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS is_swappable_with\n    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable_with\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_nothrow_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nconstexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\nconstexpr bool is_swappable_v = is_swappable<_Tp>::value;\n\ntemplate <class _Tp, class _Up>\nconstexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\nconstexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#ifdef _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCPP_UNDERLYING_TYPE\n\n\ntemplate <class _Tp, bool = is_enum<_Tp>::value>\nstruct __sfinae_underlying_type\n{\n    typedef typename underlying_type<_Tp>::type type;\n    typedef decltype(((type)1) + 0) __promoted_type;\n};\n\ntemplate <class _Tp>\nstruct __sfinae_underlying_type<_Tp, false> {};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __convert_to_integral(int __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned __convert_to_integral(unsigned __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong __convert_to_integral(long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long __convert_to_integral(unsigned long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong long __convert_to_integral(long long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long __convert_to_integral(unsigned long long __val) {return __val; }\n\n#ifndef _LIBCPP_HAS_NO_INT128\ninline _LIBCPP_INLINE_VISIBILITY\n__int128_t __convert_to_integral(__int128_t __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\n__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __sfinae_underlying_type<_Tp>::__promoted_type\n__convert_to_integral(_Tp __val) { return __val; }\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_member_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(_VSTD::declval<_Up>().operator&()), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_free_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(operator&(_VSTD::declval<_Up>())), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value\n                                  || __has_operator_addressof_free_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 14\n\n#define __cpp_lib_void_t 201411\ntemplate <class...> using void_t = void;\n\n# ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class... _Args>\nstruct conjunction : __and_<_Args...> {};\ntemplate<class... _Args> constexpr bool conjunction_v = conjunction<_Args...>::value;\n\ntemplate <class... _Args>\nstruct disjunction : __or_<_Args...> {};\ntemplate<class... _Args> constexpr bool disjunction_v = disjunction<_Args...>::value;\n\ntemplate <class _Tp>\nstruct negation : __not_<_Tp> {};\ntemplate<class _Tp> constexpr bool negation_v = negation<_Tp>::value;\n# endif // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_STD_VER > 14\n\n// These traits are used in __tree and __hash_table\n#ifndef _LIBCPP_CXX03_LANG\nstruct __extract_key_fail_tag {};\nstruct __extract_key_self_tag {};\nstruct __extract_key_first_tag {};\n\ntemplate <class _ValTy, class _Key,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_key\n    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,\n                  __extract_key_fail_tag>::type {};\n\ntemplate <class _Pair, class _Key, class _First, class _Second>\nstruct __can_extract_key<_Pair, _Key, pair<_First, _Second>>\n    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,\n                  __extract_key_first_tag, __extract_key_fail_tag>::type {};\n\n// __can_extract_map_key uses true_type/false_type instead of the tags.\n// It returns true if _Key != _ContainerValueTy (the container is a map not a set)\n// and _ValTy == _Key.\ntemplate <class _ValTy, class _Key, class _ContainerValueTy,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_map_key\n    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};\n\n// This specialization returns __extract_key_fail_tag for non-map containers\n// because _Key == _ContainerValueTy\ntemplate <class _ValTy, class _Key, class _RawValTy>\nstruct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>\n    : false_type {};\n\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TYPE_TRAITS\n","// -*- C++ -*-\n//===----------------------------- new ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_NEW\n#define _LIBCPP_NEW\n\n/*\n    new synopsis\n\nnamespace std\n{\n\nclass bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() noexcept;\n    bad_alloc(const bad_alloc&) noexcept;\n    bad_alloc& operator=(const bad_alloc&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_array_length : public bad_alloc // FIXME: Not part of C++\n{\npublic:\n    bad_array_length() noexcept;\n};\n\nclass bad_array_new_length : public bad_alloc // C++14\n{\npublic:\n    bad_array_new_length() noexcept;\n};\n\nenum class align_val_t : size_t {}; // C++17\nstruct nothrow_t {};\nextern const nothrow_t nothrow;\ntypedef void (*new_handler)();\nnew_handler set_new_handler(new_handler new_p) noexcept;\nnew_handler get_new_handler() noexcept;\n\n}  // std\n\nvoid* operator new(std::size_t size);                                   // replaceable\nvoid* operator new(std::size_t size, std::align_val_t alignment);       // replaceable, C++17\nvoid* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable\nvoid* operator new(std::size_t size, std::align_val_t alignment,\n                   const std::nothrow_t&) noexcept;                     // replaceable, C++17\nvoid  operator delete(void* ptr) noexcept;                              // replaceable\nvoid  operator delete(void* ptr, std::size_t size) noexcept;            // replaceable, C++14\nvoid  operator delete(void* ptr, std::align_val_t alignment) noexcept;  // replaceable, C++17\nvoid  operator delete(void* ptr, std::size_t size,\n                      std::align_val_t alignment) noexcept;             // replaceable, C++17\nvoid  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable\nvoid  operator delete(void* ptr, std:align_val_t alignment,\n                      const std::nothrow_t&) noexcept;                  // replaceable, C++17\n\nvoid* operator new[](std::size_t size);                                 // replaceable\nvoid* operator new[](std::size_t size,\n                     std::align_val_t alignment) noexcept;              // replaceable, C++17\nvoid* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable\nvoid* operator new[](std::size_t size, std::align_val_t alignment,\n                     const std::nothrow_t&) noexcept;                   // replaceable, C++17\nvoid  operator delete[](void* ptr) noexcept;                            // replaceable\nvoid  operator delete[](void* ptr, std::size_t size) noexcept;          // replaceable, C++14\nvoid  operator delete[](void* ptr,\n                        std::align_val_t alignment) noexcept;           // replaceable, C++17\nvoid  operator delete[](void* ptr, std::size_t size,\n                        std::align_val_t alignment) noexcept;           // replaceable, C++17\nvoid  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable\nvoid  operator delete[](void* ptr, std::align_val_t alignment,\n                        const std::nothrow_t&) noexcept;                // replaceable, C++17\n\nvoid* operator new  (std::size_t size, void* ptr) noexcept;\nvoid* operator new[](std::size_t size, void* ptr) noexcept;\nvoid  operator delete  (void* ptr, void*) noexcept;\nvoid  operator delete[](void* ptr, void*) noexcept;\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#if !(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER >= 14 || \\\n    (defined(__cpp_sized_deallocation) && __cpp_sized_deallocation >= 201309))\n# define _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) && \\\n    (!(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER > 14 || \\\n    (defined(__cpp_aligned_new) && __cpp_aligned_new >= 201606)))\n# define _LIBCPP_HAS_NO_ALIGNED_ALLOCATION\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() _NOEXCEPT;\n    virtual ~bad_alloc() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_new_length\n    : public bad_alloc\n{\npublic:\n    bad_array_new_length() _NOEXCEPT;\n    virtual ~bad_array_new_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec\n\n#if defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_length\n    : public bad_alloc\n{\npublic:\n    bad_array_length() _NOEXCEPT;\n    virtual ~bad_array_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#define _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n\n#endif  // defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\n#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) || _LIBCPP_STD_VER > 14\n#ifndef _LIBCPP_CXX03_LANG\nenum class _LIBCPP_ENUM_VIS align_val_t : size_t { };\n#else\nenum align_val_t { __zero = 0, __max = (size_t)-1 };\n#endif\n#endif\n\nstruct _LIBCPP_TYPE_VIS nothrow_t {};\nextern _LIBCPP_FUNC_VIS const nothrow_t nothrow;\ntypedef void (*new_handler)();\n_LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;\n\n}  // std\n\n#if defined(_LIBCPP_CXX03_LANG)\n#define _THROW_BAD_ALLOC throw(std::bad_alloc)\n#else\n#define _THROW_BAD_ALLOC\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_ALIGNED_ALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;\n#endif\n#endif\n\ninline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {}\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ninline _LIBCPP_INLINE_VISIBILITY void *__allocate(size_t __size) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  return ::operator new(__size);\n#else\n  return __builtin_operator_new(__size);\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void __libcpp_deallocate(void *__ptr) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  ::operator delete(__ptr);\n#else\n  __builtin_operator_delete(__ptr);\n#endif\n}\n\n#ifdef _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_array_length()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_array_length();\n#else\n\t_VSTD::abort();\n#endif\n}\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_NEW\n","// -*- C++ -*-\n//===--------------------------- stdexcept --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STDEXCEPT\n#define _LIBCPP_STDEXCEPT\n\n/*\n    stdexcept synopsis\n\nnamespace std\n{\n\nclass logic_error;\n    class domain_error;\n    class invalid_argument;\n    class length_error;\n    class out_of_range;\nclass runtime_error;\n    class range_error;\n    class overflow_error;\n    class underflow_error;\n\nfor each class xxx_error:\n\nclass xxx_error : public exception // at least indirectly\n{\npublic:\n    explicit xxx_error(const string& what_arg);\n    explicit xxx_error(const char*   what_arg);\n\n    virtual const char* what() const noexcept // returns what_arg\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <iosfwd>  // for string forward decl\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_HIDDEN __libcpp_refstring\n{\n    const char* __imp_;\n\n    bool __uses_refcount() const;\npublic:\n    explicit __libcpp_refstring(const char* msg);\n    __libcpp_refstring(const __libcpp_refstring& s) _NOEXCEPT;\n    __libcpp_refstring& operator=(const __libcpp_refstring& s) _NOEXCEPT;\n    ~__libcpp_refstring();\n\n    const char* c_str() const _NOEXCEPT {return __imp_;}\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI logic_error\n    : public exception\n{\nprivate:\n    _VSTD::__libcpp_refstring __imp_;\npublic:\n    explicit logic_error(const string&);\n    explicit logic_error(const char*);\n\n    logic_error(const logic_error&) _NOEXCEPT;\n    logic_error& operator=(const logic_error&) _NOEXCEPT;\n\n    virtual ~logic_error() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI runtime_error\n    : public exception\n{\nprivate:\n    _VSTD::__libcpp_refstring __imp_;\npublic:\n    explicit runtime_error(const string&);\n    explicit runtime_error(const char*);\n\n    runtime_error(const runtime_error&) _NOEXCEPT;\n    runtime_error& operator=(const runtime_error&) _NOEXCEPT;\n\n    virtual ~runtime_error() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI domain_error\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const char* __s)   : logic_error(__s) {}\n\n    virtual ~domain_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI invalid_argument\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const char* __s)   : logic_error(__s) {}\n\n    virtual ~invalid_argument() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI length_error\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit length_error(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit length_error(const char* __s)   : logic_error(__s) {}\n\n    virtual ~length_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI out_of_range\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const char* __s)   : logic_error(__s) {}\n\n    virtual ~out_of_range() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI range_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit range_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit range_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~range_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI overflow_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~overflow_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI underflow_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~underflow_error() _NOEXCEPT;\n};\n\n}  // std\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// in the dylib\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_logic_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw logic_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_domain_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw domain_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_invalid_argument(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw invalid_argument(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_length_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_out_of_range(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_range_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw range_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_overflow_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw overflow_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_underflow_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw underflow_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STDEXCEPT\n","// -*- C++ -*-\n//===-------------------------- __string ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___STRING\n#define _LIBCPP___STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static constexpr void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static constexpr int    compare(const char_type* s1, const char_type* s2, size_t n);\n    static constexpr size_t length(const char_type* s);\n    static constexpr const char_type* \n                            find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <algorithm>  // for search and min\n#include <cstdio>     // For EOF.\n#include <memory>     // for __murmur2_or_cityhash\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TEMPLATE_VIS char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void _LIBCPP_CONSTEXPR_AFTER_CXX14\n        assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\n_LIBCPP_CONSTEXPR_AFTER_CXX14 int\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 size_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 const _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static inline size_t _LIBCPP_CONSTEXPR_AFTER_CXX14\n    length(const char_type* __s)  _NOEXCEPT {return __builtin_strlen(__s);}\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*) memmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)memcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_memcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return memcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char*\nchar_traits<char>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return NULL;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_char_memchr(__s, to_int_type(__a), __n);\n#elif _LIBCPP_STD_VER <= 14\n    return (const char_type*) memchr(__s, to_int_type(__a), __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return NULL;\n#endif\n}\n\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*)wmemmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)wmemset(__s, __a, __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<wchar_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wmemcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<wchar_t>::length(const char_type* __s) _NOEXCEPT\n{\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wcslen(__s);\n#elif _LIBCPP_STD_VER <= 14\n    return wcslen(__s);\n#else\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst wchar_t*\nchar_traits<wchar_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return NULL;\n#if __has_feature(cxx_constexpr_string_builtins)\n        return __builtin_wmemchr(__s, __a, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemchr(__s, __a, __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return NULL;\n#endif\n}\n\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char16_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char32_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// helper fns for basic_string and string_view\n\n// __str_find\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n             _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos >= __sz)\n        return __npos;\n    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 const _CharT *\n__search_substring(const _CharT *__first1, const _CharT *__last1,\n                   const _CharT *__first2, const _CharT *__last2) {\n  // Take advantage of knowing source and pattern lengths.\n  // Stop short when source is smaller than pattern.\n  const ptrdiff_t __len2 = __last2 - __first2;\n  if (__len2 == 0)\n    return __first1;\n\n  ptrdiff_t __len1 = __last1 - __first1;\n  if (__len1 < __len2)\n    return __last1;\n\n  // First element of __first2 is loop invariant.\n  _CharT __f2 = *__first2;\n  while (true) {\n    __len1 = __last1 - __first1;\n    // Check whether __first1 still has at least __len2 bytes.\n    if (__len1 < __len2)\n      return __last1;\n\n    // Find __f2 the first byte matching in __first1.\n    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);\n    if (__first1 == 0)\n      return __last1;\n\n    // It is faster to compare from the first byte of __first1 even if we\n    // already know that it matches the first byte of __first2: this is because\n    // __first2 is most likely aligned, as it is user's \"pattern\" string, and\n    // __first1 + 1 is most likely not aligned, as the match is in the middle of\n    // the string.\n    if (_Traits::compare(__first1, __first2, __len2) == 0)\n      return __first1;\n\n    ++__first1;\n  }\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n       const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos > __sz)\n        return __npos;\n\n    if (__n == 0) // There is nothing to search, just return __pos.\n        return __pos;\n\n    const _CharT *__r = __search_substring<_CharT, _Traits>(\n        __p + __pos, __p + __sz, __s, __s + __n);\n\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_rfind\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n              _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__sz < 1)\n        return __npos;\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n    {\n        if (_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n        const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const _CharT* __r = _VSTD::__find_end(\n                  __p, __p + __pos, __s, __s + __n, _Traits::eq, \n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__n > 0 && __r == __p + __pos)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n// __str_find_first_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_of(const _CharT *__p, _SizeT __sz,\n                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos >= __sz || __n == 0)\n        return __npos;\n    const _CharT* __r = _VSTD::__find_first_of_ce\n        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_find_last_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_of(const _CharT *__p, _SizeT __sz,\n               const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n    {\n    if (__n != 0)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        {\n            const _CharT* __r = _Traits::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<_SizeT>(__ps - __p);\n        }\n    }\n    return __npos;\n}\n\n\n// __str_find_first_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (_Traits::find(__s, __n, *__ps) == 0)\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                          _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!_Traits::eq(*__ps, __c))\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\n// __str_find_last_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                   const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (_Traits::find(__s, __n, *--__ps) == 0)\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                         _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (!_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\ntemplate<class _Ptr>\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\ntemplate <class _CharT, class _Iter, class _Traits=char_traits<_CharT> >\nstruct __quoted_output_proxy\n{\n    _Iter  __first;\n    _Iter  __last;\n    _CharT  __delim;\n    _CharT  __escape;\n\n    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)\n    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}\n    //  This would be a nice place for a string_ref \n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___STRING\n","#include \"../unrar/rar.hpp\"\n#include <string>\n\nextern \"C\" {\n  extern FileHandle jsOpen(const wchar *);\n  extern FileHandle jsCreate(const wchar *);\n  extern void jsClose(FileHandle);\n  extern int jsRead(FileHandle, void*, size_t);\n  extern bool jsWrite(FileHandle, const void*, size_t);\n  extern int64 jsTell(FileHandle);\n  extern bool jsSeek(FileHandle, long, const char*);\n}\n\n\nFile::File()\n{\n  hFile=FILE_BAD_HANDLE;\n  *FileName=0;\n  NewFile=false;\n  LastWrite=false;\n  HandleType=FILE_HANDLENORMAL;\n  SkipClose=false;\n  IgnoreReadErrors=false;\n  ErrorType=FILE_SUCCESS;\n  OpenShared=false;\n  AllowDelete=true;\n  AllowExceptions=true;\n}\n\n\nFile::~File()\n{\n  if (hFile!=FILE_BAD_HANDLE && !SkipClose)\n    if (NewFile)\n      Delete();\n    else\n      Close();\n}\n\n\nvoid File::operator = (File &SrcFile)\n{\n  hFile=SrcFile.hFile;\n  NewFile=SrcFile.NewFile;\n  LastWrite=SrcFile.LastWrite;\n  HandleType=SrcFile.HandleType;\n  wcsncpyz(FileName,SrcFile.FileName,ASIZE(FileName));\n  SrcFile.SkipClose=true;\n}\n\n\nbool File::Open(const wchar *Name,uint Mode)\n{\n  ErrorType=FILE_SUCCESS;\n  FileHandle hNewFile;\n  bool OpenShared=File::OpenShared || (Mode & FMF_OPENSHARED)!=0;\n  bool UpdateMode=(Mode & FMF_UPDATE)!=0;\n  bool WriteMode=(Mode & FMF_WRITE)!=0;\n  int flags=UpdateMode ? O_RDWR:(WriteMode ? O_WRONLY:O_RDONLY);\n  char NameA[NM];\n  WideToChar(Name,NameA,ASIZE(NameA));\n\n  // int handle=open(NameA,flags);\n  // if (handle==-1)\n  //   hNewFile=FILE_BAD_HANDLE;\n  // else\n  // {\n  //   hNewFile=fdopen(handle,UpdateMode ? UPDATEBINARY:READBINARY);\n  // }\n  hNewFile = jsOpen(Name);\n  if (hNewFile==FILE_BAD_HANDLE && errno==ENOENT)\n    ErrorType=FILE_NOTFOUND;\n  NewFile=false;\n  HandleType=FILE_HANDLENORMAL;\n  SkipClose=false;\n  bool Success=hNewFile!=FILE_BAD_HANDLE;\n  if (Success)\n  {\n    hFile=hNewFile;\n    wcsncpyz(FileName,Name,ASIZE(FileName));\n  }\n  return Success;\n}\n\n\n#if !defined(SHELL_EXT) && !defined(SFX_MODULE)\nvoid File::TOpen(const wchar *Name)\n{\n  if (!WOpen(Name))\n    ErrHandler.Exit(RARX_OPEN);\n}\n#endif\n\n\nbool File::WOpen(const wchar *Name)\n{\n  if (Open(Name))\n    return true;\n  ErrHandler.OpenErrorMsg(Name);\n  return false;\n}\n\n\nbool File::Create(const wchar *Name,uint Mode)\n{\n  // OpenIndiana based NAS and CIFS shares fail to set the file time if file\n  // was created in read+write mode and some data was written and not flushed\n  // before SetFileTime call. So we should use the write only mode if we plan\n  // SetFileTime call and do not need to read from file.\n  bool WriteMode=(Mode & FMF_WRITE)!=0;\n  char NameA[NM];\n  WideToChar(Name,NameA,ASIZE(NameA));\n  // hFile=fopen(NameA,WriteMode ? WRITEBINARY:CREATEBINARY);\n  hFile=jsCreate(Name);\n  NewFile=true;\n  HandleType=FILE_HANDLENORMAL;\n  SkipClose=false;\n  wcsncpyz(FileName,Name,ASIZE(FileName));\n  return hFile!=FILE_BAD_HANDLE;\n}\n\n\n#if !defined(SHELL_EXT) && !defined(SFX_MODULE)\nvoid File::TCreate(const wchar *Name,uint Mode)\n{\n  if (!WCreate(Name,Mode))\n    ErrHandler.Exit(RARX_FATAL);\n}\n#endif\n\n\nbool File::WCreate(const wchar *Name,uint Mode)\n{\n  if (Create(Name,Mode))\n    return true;\n  ErrHandler.CreateErrorMsg(Name);\n  return false;\n}\n\n\nbool File::Close()\n{\n  bool Success=true;\n\n  if (hFile!=FILE_BAD_HANDLE)\n  {\n    if (!SkipClose)\n    {\n      // Success=fclose(hFile)!=EOF;\n      jsClose(hFile);\n      Success = true;\n    }\n    hFile=FILE_BAD_HANDLE;\n  }\n  HandleType=FILE_HANDLENORMAL;\n  if (!Success && AllowExceptions)\n    ErrHandler.CloseError(FileName);\n  return Success;\n}\n\n\nbool File::Delete()\n{\n  return DelFile(FileName);\n}\n\n\nbool File::Rename(const wchar *NewName)\n{\n  return true;\n}\n\n\nbool File::Write(const void *Data,size_t Size)\n{\n  if (Size==0)\n    return true;\n  return jsWrite(hFile, Data,Size);\n  // if (HandleType==FILE_HANDLESTD)\n  // {\n  //   // Cannot use the standard stdout here, because it already has wide orientation.\n  //   if (hFile==FILE_BAD_HANDLE)\n  //   {\n  //     hFile=fdopen(dup(STDOUT_FILENO),\"w\"); // Open new stdout stream.\n  //   }\n  // }\n  // bool Success;\n  // while (1)\n  // {\n  //   Success=false;\n  //   int Written=fwrite(Data,1,Size,hFile);\n  //   Success=Written==Size && !ferror(hFile);\n  //   if (!Success && AllowExceptions && HandleType==FILE_HANDLENORMAL)\n  //   {\n  //     if (ErrHandler.AskRepeatWrite(FileName,false))\n  //     {\n  //       if (Written<Size && Written>0)\n  //         Seek(Tell()-Written,SEEK_SET);\n  //       continue;\n  //     }\n  //     ErrHandler.WriteError(NULL,FileName);\n  //   }\n  //   break;\n  // }\n  // LastWrite=true;\n  // return Success; // It can return false only if AllowExceptions is disabled.\n}\n\n\nint File::Read(void *Data,size_t Size)\n{\n  int64 FilePos=0; // Initialized only to suppress some compilers warning.\n\n  if (IgnoreReadErrors)\n    FilePos=Tell();\n  int ReadSize;\n  while (true)\n  {\n    ReadSize=DirectRead(Data,Size);\n    if (ReadSize==-1)\n    {\n      ErrorType=FILE_READERROR;\n      if (AllowExceptions)\n        if (IgnoreReadErrors)\n        {\n          ReadSize=0;\n          for (size_t I=0;I<Size;I+=512)\n          {\n            Seek(FilePos+I,SEEK_SET);\n            size_t SizeToRead=Min(Size-I,512);\n            int ReadCode=DirectRead(Data,SizeToRead);\n            ReadSize+=(ReadCode==-1) ? 512:ReadCode;\n          }\n        }\n        else\n        {\n          if (HandleType==FILE_HANDLENORMAL && ErrHandler.AskRepeatRead(FileName))\n            continue;\n          ErrHandler.ReadError(FileName);\n        }\n    }\n    break;\n  }\n  return ReadSize;\n}\n\n\n// Returns -1 in case of error.\nint File::DirectRead(void *Data,size_t Size)\n{\n  if (HandleType==FILE_HANDLESTD)\n  {\n    hFile=stdin;\n  }\n  if (LastWrite)\n  {\n    // fflush(hFile);\n    LastWrite=false;\n  }\n  // clearerr(hFile);\n  // size_t ReadSize=fread(Data,1,Size,hFile);\n  // if (ferror(hFile))\n    // return -1;\n  // return (int)ReadSize;\n  return jsRead(hFile,Data,Size);\n}\n\n\nvoid File::Seek(int64 Offset,int Method)\n{\n  if (!RawSeek(Offset,Method) && AllowExceptions)\n    ErrHandler.SeekError(FileName);\n}\n\n\nbool File::RawSeek(int64 Offset,int Method)\n{\n  if (hFile==FILE_BAD_HANDLE)\n    return true;\n  if (Offset<0 && Method!=SEEK_SET)\n  {\n    Offset=(Method==SEEK_CUR ? Tell():FileLength())+Offset;\n    Method=SEEK_SET;\n  }\n  LastWrite=false;\n  return jsSeek(hFile,(long)Offset, Method == SEEK_CUR ? \"CUR\" : Method == SEEK_SET ? \"SET\" : \"END\" );\n}\n\n\nint64 File::Tell()\n{\n  if (hFile==FILE_BAD_HANDLE)\n    if (AllowExceptions)\n      ErrHandler.SeekError(FileName);\n    else\n      return -1;\n  return jsTell(hFile);\n}\n\n\nvoid File::Prealloc(int64 Size)\n{\n// #if defined(_UNIX) && defined(USE_FALLOCATE)\n//   // fallocate is rather new call. Only latest kernels support it.\n//   // So we are not using it by default yet.\n//   int fd = GetFD();\n//   if (fd >= 0)\n//     fallocate(fd, 0, 0, Size);\n// #endif\n}\n\n\nbyte File::GetByte()\n{\n  byte Byte=0;\n  Read(&Byte,1);\n  return Byte;\n}\n\n\nvoid File::PutByte(byte Byte)\n{\n  Write(&Byte,1);\n}\n\n\nbool File::Truncate()\n{\n  return true;\n}\n\n\nvoid File::Flush()\n{\n}\n\n\nvoid File::SetOpenFileTime(RarTime *ftm,RarTime *ftc,RarTime *fta)\n{\n}\n\n\nvoid File::SetCloseFileTime(RarTime *ftm,RarTime *fta)\n{\n  // SetCloseFileTimeByName(FileName,ftm,fta);\n}\n\n\nvoid File::SetCloseFileTimeByName(const wchar *Name,RarTime *ftm,RarTime *fta)\n{\n}\n\n\nvoid File::GetOpenFileTime(RarTime *ft)\n{\n}\n\n\nint64 File::FileLength()\n{\n  \n  SaveFilePos SavePos(*this);\n  Seek(0,SEEK_END);\n  return Tell();\n}\n\n\nbool File::IsDevice()\n{\n  return false;\n}\n\n\n#ifndef SFX_MODULE\nint64 File::Copy(File &Dest,int64 Length)\n{\n  return 0;\n}\n#endif\n","#include \"../unrar/rar.hpp\"\n\nMKDIR_CODE MakeDir(const wchar *Name,bool SetAttr,uint Attr)\n{\n  return MKDIR_SUCCESS;\n}\n\n\nbool CreatePath(const wchar *Path,bool SkipLastName)\n{\n  bool Success=true;\n  return Success;\n}\n\n\nvoid SetDirTime(const wchar *Name,RarTime *ftm,RarTime *ftc,RarTime *fta)\n{\n}\n\n\nbool IsRemovable(const wchar *Name)\n{\n  return false;\n}\n\n\nint64 GetFreeDisk(const wchar *Name)\n{\n  return 0;\n}\n\n\n\nbool FileExist(const wchar *Name)\n{\n  return false;\n}\n \n\nbool WildFileExist(const wchar *Name)\n{\n  return false;\n}\n\n\nbool IsDir(uint Attr)\n{\n  return (Attr & 0xF000)==0x4000;\n}\n\n\nbool IsUnreadable(uint Attr)\n{\n  return false;\n}\n\n\nbool IsLink(uint Attr)\n{\n  return false;\n}\n\n\nbool IsDeleteAllowed(uint FileAttr)\n{\n  return true;\n}\n\n\nvoid PrepareToDelete(const wchar *Name)\n{\n}\n\n\nuint GetFileAttr(const wchar *Name)\n{\n  return 0;\n}\n\n\nbool SetFileAttr(const wchar *Name,uint Attr)\n{\n  return true;\n}\n\n\n#if !defined(SFX_MODULE) && !defined(SHELL_EXT) && !defined(SETUP)\nvoid CalcFileSum(File *SrcFile,uint *CRC32,byte *Blake2,uint Threads,int64 Size,uint Flags)\n{\n}\n#endif\n\n\nbool RenameFile(const wchar *SrcName,const wchar *DestName)\n{\n  return true;\n}\n\n\nbool DelFile(const wchar *Name)\n{\n  return true;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n","#include \"../unrar/rar.hpp\"\n\nFindFile::FindFile()\n{\n  *FindMask=0;\n  FirstCall=true;\n  dirp=NULL;\n}\n\n\nFindFile::~FindFile()\n{\n}\n\n\nvoid FindFile::SetMask(const wchar *Mask)\n{\n  FirstCall=true;\n}\n\n\nbool FindFile::Next(FindData *fd,bool GetSymLink)\n{\n  return false;\n}\n\n\nbool FindFile::FastFind(const wchar *FindMask,FindData *fd,bool GetSymLink)\n{\n  return false;\n}\n","#include <emscripten/bind.h>\n#ifdef USE_CXA_DEMANGLE\n#include <../lib/libcxxabi/include/cxxabi.h>\n#endif\n#include <list>\n#include <vector>\n#include <typeinfo>\n#include <algorithm>\n#include <emscripten/emscripten.h>\n#include <emscripten/wire.h>\n#include <climits>\n#include <limits>\n\nusing namespace emscripten;\n\nextern \"C\" {\n    const char* __attribute__((used)) __getTypeName(const std::type_info* ti) {\n        if (has_unbound_type_names) {\n#ifdef USE_CXA_DEMANGLE\n            int stat;\n            char* demangled = abi::__cxa_demangle(ti->name(), NULL, NULL, &stat);\n            if (stat == 0 && demangled) {\n                return demangled;\n            }\n\n            switch (stat) {\n                case -1:\n                    return strdup(\"<allocation failure>\");\n                case -2:\n                    return strdup(\"<invalid C++ symbol>\");\n                case -3:\n                    return strdup(\"<invalid argument>\");\n                default:\n                    return strdup(\"<unknown error>\");\n            }\n#else\n            return strdup(ti->name());\n#endif\n        } else {\n            char str[80];\n            sprintf(str, \"%p\", reinterpret_cast<const void*>(ti));\n            return strdup(str);\n        }\n    }\n}\n\nnamespace {\n    template<typename T>\n    static void register_integer(const char* name) {\n        using namespace internal;\n        _embind_register_integer(TypeID<T>::get(), name, sizeof(T), std::numeric_limits<T>::min(), std::numeric_limits<T>::max());\n    }\n\n    template<typename T>\n    static void register_float(const char* name) {\n        using namespace internal;\n        _embind_register_float(TypeID<T>::get(), name, sizeof(T));\n    }\n\n\n    // matches typeMapping in embind.js\n    enum TypedArrayIndex {\n        Int8Array,\n        Uint8Array,\n        Int16Array,\n        Uint16Array,\n        Int32Array,\n        Uint32Array,\n        Float32Array,\n        Float64Array,\n    };\n\n    template<typename T>\n    constexpr TypedArrayIndex getTypedArrayIndex() {\n        static_assert(internal::typeSupportsMemoryView<T>(),\n            \"type does not map to a typed array\");\n        return std::is_floating_point<T>::value\n            ? (sizeof(T) == 4\n               ? Float32Array\n               : Float64Array)\n            : (sizeof(T) == 1\n               ? (std::is_signed<T>::value ? Int8Array : Uint8Array)\n               : (sizeof(T) == 2\n                  ? (std::is_signed<T>::value ? Int16Array : Uint16Array)\n                  : (std::is_signed<T>::value ? Int32Array : Uint32Array)));\n    }\n\n    template<typename T>\n    static void register_memory_view(const char* name) {\n        using namespace internal;\n        _embind_register_memory_view(TypeID<memory_view<T>>::get(), getTypedArrayIndex<T>(), name);\n    }\n}\n\nEMSCRIPTEN_BINDINGS(native_and_builtin_types) {\n    using namespace emscripten::internal;\n\n    _embind_register_void(TypeID<void>::get(), \"void\");\n\n    _embind_register_bool(TypeID<bool>::get(), \"bool\", sizeof(bool), true, false);\n\n    register_integer<char>(\"char\");\n    register_integer<signed char>(\"signed char\");\n    register_integer<unsigned char>(\"unsigned char\");\n    register_integer<signed short>(\"short\");\n    register_integer<unsigned short>(\"unsigned short\");\n    register_integer<signed int>(\"int\");\n    register_integer<unsigned int>(\"unsigned int\");\n    register_integer<signed long>(\"long\");\n    register_integer<unsigned long>(\"unsigned long\");\n\n    register_float<float>(\"float\");\n    register_float<double>(\"double\");\n\n    _embind_register_std_string(TypeID<std::string>::get(), \"std::string\");\n    _embind_register_std_string(TypeID<std::basic_string<unsigned char> >::get(), \"std::basic_string<unsigned char>\");\n    _embind_register_std_wstring(TypeID<std::wstring>::get(), sizeof(wchar_t), \"std::wstring\");\n    _embind_register_emval(TypeID<val>::get(), \"emscripten::val\");\n\n    // Some of these types are aliases for each other. Luckily,\n    // embind.js's _embind_register_memory_view ignores duplicate\n    // registrations rather than asserting, so the first\n    // register_memory_view call for a particular type will take\n    // precedence.\n\n    register_memory_view<char>(\"emscripten::memory_view<char>\");\n    register_memory_view<signed char>(\"emscripten::memory_view<signed char>\");\n    register_memory_view<unsigned char>(\"emscripten::memory_view<unsigned char>\");\n\n    register_memory_view<short>(\"emscripten::memory_view<short>\");\n    register_memory_view<unsigned short>(\"emscripten::memory_view<unsigned short>\");\n    register_memory_view<int>(\"emscripten::memory_view<int>\");\n    register_memory_view<unsigned int>(\"emscripten::memory_view<unsigned int>\");\n    register_memory_view<long>(\"emscripten::memory_view<long>\");\n    register_memory_view<unsigned long>(\"emscripten::memory_view<unsigned long>\");\n\n    register_memory_view<int8_t>(\"emscripten::memory_view<int8_t>\");\n    register_memory_view<uint8_t>(\"emscripten::memory_view<uint8_t>\");\n    register_memory_view<int16_t>(\"emscripten::memory_view<int16_t>\");\n    register_memory_view<uint16_t>(\"emscripten::memory_view<uint16_t>\");\n    register_memory_view<int32_t>(\"emscripten::memory_view<int32_t>\");\n    register_memory_view<uint32_t>(\"emscripten::memory_view<uint32_t>\");\n\n    register_memory_view<float>(\"emscripten::memory_view<float>\");\n    register_memory_view<double>(\"emscripten::memory_view<double>\");\n#if __SIZEOF_LONG_DOUBLE__ == __SIZEOF_DOUBLE__\n    register_memory_view<long double>(\"emscripten::memory_view<long double>\");\n#endif\n}\n","// -*- C++ -*-\n//===-------------------------- typeinfo ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __LIBCPP_TYPEINFO\n#define __LIBCPP_TYPEINFO\n\n/*\n\n    typeinfo synopsis\n\nnamespace std {\n\nclass type_info\n{\npublic:\n    virtual ~type_info();\n\n    bool operator==(const type_info& rhs) const noexcept;\n    bool operator!=(const type_info& rhs) const noexcept;\n\n    bool before(const type_info& rhs) const noexcept;\n    size_t hash_code() const noexcept;\n    const char* name() const noexcept;\n\n    type_info(const type_info& rhs) = delete;\n    type_info& operator=(const type_info& rhs) = delete;\n};\n\nclass bad_cast\n    : public exception\n{\npublic:\n    bad_cast() noexcept;\n    bad_cast(const bad_cast&) noexcept;\n    bad_cast& operator=(const bad_cast&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() noexcept;\n    bad_typeid(const bad_typeid&) noexcept;\n    bad_typeid& operator=(const bad_typeid&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#include <cstdint>\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#if defined(_LIBCPP_NONUNIQUE_RTTI_BIT)\n#define _LIBCPP_HAS_NONUNIQUE_TYPEINFO\n#else\n#define _LIBCPP_HAS_UNIQUE_TYPEINFO\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI type_info\n{\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\n\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    _LIBCPP_INLINE_VISIBILITY\n    int __compare_nonunique_names(const type_info &__arg) const _NOEXCEPT\n    { return __builtin_strcmp(name(), __arg.name()); }\n#endif\n\nprotected:\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    // A const char* with the non-unique RTTI bit possibly set.\n    uintptr_t __type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n)\n      : __type_name(reinterpret_cast<uintptr_t>(__n)) {}\n#else\n    const char *__type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n) : __type_name(__n) {}\n#endif\n\npublic:\n    virtual ~type_info();\n\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n    {\n      return reinterpret_cast<const char*>(__type_name &\n                                           ~_LIBCPP_NONUNIQUE_RTTI_BIT);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n    {\n      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return __type_name < __arg.__type_name;\n      return __compare_nonunique_names(__arg) < 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n    {\n      if (!(__type_name & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return __type_name;\n\n      const char* __ptr = name();\n      size_t __hash = 5381;\n      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))\n        __hash = (__hash * 33) ^ __c;\n      return __hash;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n    {\n      if (__type_name == __arg.__type_name)\n        return true;\n\n      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return false;\n      return __compare_nonunique_names(__arg) == 0;\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n    { return __type_name; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n    { return __type_name < __arg.__type_name; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n    { return reinterpret_cast<size_t>(__type_name); }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n    { return __type_name == __arg.__type_name; }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const type_info& __arg) const _NOEXCEPT\n    { return !operator==(__arg); }\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_cast\n    : public exception\n{\npublic:\n    bad_cast() _NOEXCEPT;\n    virtual ~bad_cast() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() _NOEXCEPT;\n    virtual ~bad_typeid() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n}  // std\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_cast()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_cast();\n#else\n\t_VSTD::abort();\n#endif\n}\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // __LIBCPP_TYPEINFO\n"]}